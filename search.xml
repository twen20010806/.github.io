<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Ajax&amp;json</title>
      <link href="2021/05/15/ajax-json/"/>
      <url>2021/05/15/ajax-json/</url>
      
        <content type="html"><![CDATA[<h4 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h4><p>1.概念 ASynchronous JavaScript And XML 异步的JavaScript 和 XML<br>    1. 异步,同步:客户端和服务器通信的基础上<br>        1. 同步:客户端必须等待服务器的响应,在等待的期间客户端不能做其他操作<br>        2. 异步:客户端不需要等待服务器端的响应,在服务器处理请求的过程中,客户端可以进行其他操作<br>            * 客户端的各个元素之间异步,互不影响</p><pre><code>3. Ajax即Asynchronous Javascript And XML（异步JavaScript和XML）在 2005年被Jesse James Garrett提出的新术语，用来描述一种使用现有技术集合的‘新’方法，包括: HTML 或 XHTML, CSS, JavaScript, DOM, XML, XSLT, 以及最重要的XMLHttpRequest。 使用Ajax技术网页应用能够快速地将增量更新呈现在用户界面上，而不需要重载（刷新）整个页面，这使得程序能够更快地回应用户的操作。</code></pre><ol start="2"><li><p>实现方式</p><ol><li><p>原生的Js实现方式(了解)</p></li><li><p>JQuery实现方式</p><ol><li><p>$.ajax()</p><pre><code> $.ajax(&#123;   url:&quot;/Ajax/ajaxServlet&quot;,   type:&quot;post&quot;,   data:&#123;&quot;username&quot;:&quot;twen&quot;,&quot;age&quot;:&quot;23&quot;&#125;,   success:function (data)&#123;     alert(data);   &#125; &#125;);</code></pre><ul><li>success:function,error:function里的data为response里的响应内容</li></ul></li><li><p>$.get()</p><ul><li>用来发送get请求</li><li>语法:$.get(url,[data],[SuccessCallback],[type])</li><li>url:请求路径</li><li>请求参数</li><li>回调函数</li><li>响应数据类型</li><li>使用get不再需要写键名</li></ul></li><li><p>$.post()</p><ul><li>用来发送post请求</li><li>语法:$.post(url(必写),[data],[callback],[type]</li></ul></li></ol><ul><li>常用的键:<ul><li>url</li><li>type:”post”,”get”</li><li>data:发送的数据</li><li>success:function(data)</li><li>error:function(data)</li><li>dataType:获取的响应的格式(MIME类型)</li></ul></li></ul></li></ol></li></ol><h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><ol><li><p>概念:JavaScript Object Notation JavaScript对象表示法</p><pre><code> var p = (&quot;name&quot;:张三,&quot;age&quot;:23,&quot;gender&quot;:&quot;男);</code></pre><ul><li>JSON现多用于存储和交换文本信息的语法</li><li>进行数据的传输</li><li>JSON比XML更小,更快,更易解析</li></ul></li><li><p>语法:</p><ol><li><p>基本规则</p><ol><li>数据在名称键值对中:Json数据由键值对构成<ul><li>键用引号(单双都行)引起来,也可以不使用引号</li><li>值的取值类型:<ul><li>数字(正数或浮点型)</li><li>字符型(在双引号中)</li><li>逻辑值(true或false)</li><li>数值(在方括号中):{“person”:[{},{}]}</li><li>对象(在花括号中):{“address”:{“province”:”陕西”,….}}</li><li>null</li></ul></li></ul></li><li>数据由逗号分隔</li><li>花括号保存对象</li><li>方括号保存数组</li></ol></li><li><p><strong>获取数据</strong></p><ol><li><p>json对象.键名</p></li><li><p>json对象[“键名”]</p></li><li><p>数组对象[索引]</p></li><li><p><strong>对于Json对象和Json数组的遍历</strong></p><ol><li><p>对象<br> ** for中的key是字符串,所以不能用person.key获取数据</p><pre><code> for(key in person)&#123;      alert(person[key]);  &#125;</code></pre></li><li><p>键值对,数组对象的嵌套</p><pre><code> var persons =&#123; &quot;person&quot;:  [&#123;&quot;name&quot;: &quot;张三&quot;, age: 23, &quot;gender&quot;: true&#125;,       &#123;&quot;name&quot;: &quot;李四&quot;, age: 24, &quot;gender&quot;: false&#125;,       &#123;&quot;name&quot;: &quot;王五&quot;, age: 25, &quot;gender&quot;: true&#125;]   &#125;;      for (let i = 0; i &lt; persons.person.length; i++) &#123;   var person = persons.person[i];   for(key in person)&#123;       alert(person[key]);   &#125;   &#125;    </code></pre></li></ol></li></ol></li></ol></li><li><p>JSON数据和java对象的相互转换</p><ol><li><p>Json解析器</p><ul><li>常见的解析器:Jsonlib,Gson(Google提供),fastjson(阿里),jackson(Spring MVC框架内置)</li></ul></li><li><p>Json转为Java对象        </p><ol><li>redValue(json数据,Class)</li></ol></li><li><p>Java对象转换Json</p><ol><li><p>使用步骤</p><ol><li><p>导入jackson的相关jar包</p></li><li><p>创建Jackson核心对象ObjectMapper</p></li><li><p>调用ObjectMapper的相关方法</p><ol><li><p>转换方法</p><ul><li>writeValue(参数1,参数2)<ul><li>参数1<ul><li>file:将obj对象转换为JSON字符串,并保存到指定的文件中</li><li>Writer:将obj对象转换为Json字符串,并将json数据填充到字符输出流中</li><li>OutputStream:子节输出流</li></ul></li></ul></li><li>writeValueAsString(),传入对象将对象转换为Json字符串    </li></ul></li><li><p>注解:</p><ol><li>@JsonIgnore:排除属性</li><li>@JsonFormat:属性值的格式化(格式化与DateFormat要求一样)</li></ol></li><li><p>复杂的java对象转换</p><ol><li>list:数组</li><li>Map:和对象格式一致</li></ol></li></ol></li></ol></li></ol></li></ol></li></ol><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><ul><li>校验用户名是否存在</li><li>tips:$.get;$.post方法的返回值需要设置MIME类型(json),如果不设置,默认text纯文本类型。服务器也可以指定MIME类型application/jason/setContentType(;charset);</li></ul>]]></content>
      
      
      <categories>
          
          <category> front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> front-end </tag>
            
            <tag> Ajax </tag>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jquery</title>
      <link href="2021/05/15/jQuery/"/>
      <url>2021/05/15/jQuery/</url>
      
        <content type="html"><![CDATA[<h4 id="JQuery基础"><a href="#JQuery基础" class="headerlink" title="JQuery基础"></a>JQuery基础</h4><ul><li><p>概念: 一个Javscript框架,能够简化javascript代码</p></li><li><p>本质: js文件,封装了js的原生代码</p></li><li><p>版本</p><ol><li>1.x:<ul><li>兼容ie,使用最广泛,官方只做BUG维护,功能不再新增。一般项目用1.x版本就可以</li><li>最终版本:1.12.4(2016/5/20)</li></ul></li><li>2.x:<ul><li>使用最少</li></ul></li><li>3.x:<ul><li>最新版本:新浏览器支持</li></ul></li><li>jquery-xxx.js 与 jquery-xxx.min.js区别<ol><li>jquery-xxx.js:开发版本,良好的缩进与注释,给程序员看</li><li>jquery-xxx.min.js:生产版本,程序中使用,没有缩进,体积小,程序加载更快<h4 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h4></li></ol></li></ol></li><li><p>步骤</p></li><li><p>导入Jquery文件,导入min.js文件</p></li><li><p>使用</p><pre><code>  var div1 = $(&quot;#div1&quot;);  alert(div1.html());</code></pre></li><li><p>优势</p><ul><li>jquery对象在操作时更加方便’</li><li>jquery对象和js对象不通用</li></ul></li><li><p>Jquery与js对象转换</p></li><li><p>jq – &gt; js:jsq对象[索引] 或者 jq对象.get(索引)(jq对象本质上是Object的数组)</p></li><li><p>js – &gt; jq:$(js对象)</p><pre><code>       let $div2 = $(&quot;div&quot;);       alert($div2.length)       $div2.html(&quot;bbb&quot;)            $div2[0].innerHTML = &quot;ccc&quot;;       $div2.get(1).innerHTML = &quot;ddd&quot;;</code></pre></li><li><p>选择器:筛选具有相似特征的元素(标签）</p><ol><li><p>基本语法学习</p><ol><li>事件绑定</li><li>入口函数<ol><li>js中的window.onload方法会被下一个函数覆盖</li><li>Jquery中的$(function())可以重复</li></ol></li><li>样式控制<ul><li>$(function(){$(“#div1”.css(“backgroundColour”,”pink”))})</li></ul></li></ol></li><li><p>分类</p><ol><li><p>基本选择器</p><ol><li>标签选择器（元素选择器）<ul><li>语法： $(“html标签名”) 获得所有匹配标签名称的元素</li></ul></li><li>id选择器 <ul><li>语法： $(“#id的属性值”) 获得与指定id属性值匹配的元素</li></ul></li><li>类选择器<ul><li>语法： $(“.class的属性值”) 获得与指定的class属性值匹配的元素</li></ul></li><li>并集选择器：<ul><li>语法： $(“选择器1,选择器2….”) 获取多个选择器选中的所有元素</li></ul></li></ol></li><li><p>层级选择器</p><ol><li>后代选择器<ul><li>语法: $(“A B”) 选择A元素内部的所有B元素(包括所有后辈)</li></ul></li><li>自带选择器<ul><li>语法: $(“A &gt; B”) 选择A元素内部的自带B元素</li></ul></li></ol></li><li><p>属性选择器</p><ol><li><p>属性名称选择器 </p><ul><li>语法： $(“A[属性名]”) 包含指定属性的选择器</li></ul></li><li><p>属性选择器</p><ul><li>语法： $(“A[属性名=’值’]”) 包含指定属性等于指定值的选择器</li></ul></li><li><p>复合属性选择器</p><ul><li>语法： $(“A[属性名=’值’][]…”) 包含多个属性条件的选择器</li></ul></li><li><p>属性选择器里的正则表达式</p><ol><li><p>开头</p><ul><li>$(“A[属性^=’ee’]”);</li></ul></li><li><p>结尾</p><ul><li>$(“A[属性$=’ee’]”);</li></ul></li><li><p>包含</p><ul><li>$(“A[属性*=’ee’]”);</li></ul><ol start="4"><li>过滤选择器</li></ol></li><li><p>首元素选择器 </p><ul><li>语法： :first 获得选择的元素中的第一个元素</li></ul></li><li><p>尾元素选择器 </p><ul><li>语法： :last 获得选择的元素中的最后一个元素</li></ul></li><li><p>非元素选择器</p><ul><li>语法： :not(selector) 不包括指定内容的元素</li></ul></li><li><p>偶数选择器</p><ul><li>语法： :even 偶数，从 0 开始计数</li></ul></li><li><p>奇数选择器</p><ul><li>语法： :odd 奇数，从 0 开始计数</li></ul></li><li><p>等于索引选择器</p><ul><li>语法： :eq(index) 指定索引元素</li></ul></li><li><p>大于索引选择器 </p><ul><li>语法： :gt(index) 大于指定索引元素,不等于</li></ul></li><li><p>小于索引选择器 </p><ul><li>语法： :lt(index) 小于指定索引元素,不等于</li></ul></li><li><p>标题选择器</p><ul><li>语法： :header 获得标题（h1~h6）元素，固定写法</li></ul></li></ol></li><li><p>表单过滤选择器</p><ol><li>可用元素选择器 <ul><li>语法： :enabled 获得可用元素</li></ul></li><li>不可用元素选择器 <ul><li>语法： :disabled 获得不可用元素</li></ul></li><li>选中选择器 <ul><li>语法： :checked 获得单选/复选框选中的元素</li></ul></li><li>选中选择器 <ul><li>语法： :selected 获得下拉框选中的元素</li></ul></li></ol></li></ol></li></ol></li></ol></li></ul><h4 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h4><ol><li><p>内容操作</p><ol><li><p>html(): 获取/设置元素的标签体内容</p><pre><code> &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt;  --&gt; &lt;font&gt;内容&lt;/font&gt;</code></pre></li><li><p>text(): 获取/设置元素的题纯文本内容,设置text内容时会换掉其所在的标题标签</p><pre><code> 获取/设置元素的标签体纯文本内容   &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt; --&gt; 内容</code></pre></li><li><p>val(): 获取/设置元素的value属性值</p></li></ol></li><li><p>属性操作</p><ol><li><p>通用属性操作</p><ol><li>attr(): 获取/设置元素的属性</li><li>removeAttr(): 删除属性</li><li>prop(): 获取/设置元素的属性</li><li>removeProp(): 删除属性</li></ol><ul><li>attr和prop区别<ol><li>如果操作的是元素的固有属性,建议使用prop</li><li>如果操作的是自定义属性,建议使用attr</li></ol></li></ul></li><li><p>对class属性的操作</p><ol><li>addClass():添加class属性值</li><li>removerClass():删除class属性值</li><li>toggleClass():切换class属性值<ul><li>如果元素对象有class则删除,如果不存在则添加</li></ul></li><li>css():获取/设置css样式</li></ol></li></ol></li><li><p>CRUD操作</p><ol><li>添加<ol><li>父级元素的添加<ol><li>append():父元素将子元素追加到末尾<ul><li>对象1.append(对象2):将对象2添加到对象1元素内部,并且在末尾</li></ul></li><li>prepend():父元素将子元素追加到开头<ul><li>对象1.prepend(对象2):将对象2添加到对象1元素内部,并且在开头</li></ul></li><li>appentTO():括号里追加调用方法者在末尾<ul><li>对象1.appendTo(对象2):将对象1添加到对象2内部,并且在末尾</li></ul></li><li>prepentTo():括号里追加调用方法者在开头<ul><li>对象1.appendTo(对象2):将对象1添加到对象2内部,并且在开头</li></ul></li></ol></li><li>兄弟元素的添加<ol><li>after():将元素添加到元素后面<ul><li>对象1.after(对象2):将对象2添加到对象1后,为兄弟关系</li></ul></li><li>before():将元素添加到元素前边<ul><li>对象1.before(对象2):将对象2添加到对象1后,为兄弟关系</li></ul></li><li>insertAfter():插队</li><li>insertBefore():插队</li></ol></li></ol></li><li>移除<ol><li>remove():移除元素<ul><li>对象.remove():将此对象删除</li></ul></li><li>empty():清空元素的所有后代元素<ul><li>对象.empty():将此元素的所有子节点删除,但保留该节点和属性</li></ul></li></ol></li></ol></li></ol><h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><ul><li>this是dom对象不是jQuery对象,需要$(this)才能调用this的Jquery对象</li></ul><h4 id="Jquery高级"><a href="#Jquery高级" class="headerlink" title="Jquery高级"></a>Jquery高级</h4><ol><li><p>动画</p><ol><li><p>三种方式显示和隐藏元素</p><ol><li><p>默认显示和隐藏方式</p><ol><li>show([speed,[easing],[fn]])<ol><li>参数：<ol><li>speed：动画的速度。三个预定义的值(“slow”,”normal”, “fast”)或表示动画时长的毫秒数值(如：1000)</li><li>easing：用来指定切换效果，默认是”swing”，可用参数”linear”<ul><li>swing：动画执行时效果是 先慢，中间快，最后又慢</li><li>linear：动画执行时速度是匀速的</li></ul></li><li>fn：在动画完成时执行的函数，每个元素执行一次。</li></ol></li></ol></li><li>hide([speed,[easing],[fn]])</li><li>toggle([speed],[easing],[fn])</li></ol></li><li><p>滑动显示和隐藏方式</p><ol><li>slideDown([speed],[easing],[fn])</li><li>slideUp([speed,[easing],[fn]])</li><li>slideToggle([speed],[easing],[fn])</li></ol></li><li><p>淡入淡出显示和隐藏方式</p><ol><li>fadeIn([speed],[easing],[fn])</li><li>fadeOut([speed],[easing],[fn])</li><li>fadeToggle([speed,[easing],[fn]])</li></ol></li></ol></li></ol></li><li><p>遍历</p><ol><li>js的遍历方式</li></ol><ul><li>for(初始化值;循环结束条件;步长)</li></ul><ol start="2"><li><p>jq的遍历方式</p><ol><li>jq对象.each(callback)<ol><li>语法：<br> jquery对象.each(function(index,element){});<pre><code> * index:就是元素在集合中的索引 * element：就是集合中的每一个元素对象 * this：集合中的每一个元素对象 * function中的index,element固定位置,但是可以省略</code></pre></li><li>回调函数返回值：<ul><li>true:如果当前function返回为false，则结束循环(break)。</li><li>false:如果当前function返回为true，则结束本次循环，继续下次循环(continue)</li></ul></li></ol></li><li>$.each(object, [callback]):可以传递js数组对象,不仅jq对象</li><li>for..of: jquery 3.0 版本之后提供的方式<br> for(元素对象 of 容器对象)</li><li>tips:如果callback()函数里有返回false,则相当于break,如果是true,则相当于continue</li></ol></li><li><p>事件绑定</p><ol><li>jQuery标准的绑定方式<ul><li>jq对象.事件方法(回调函数);</li><li>tips:如果调用事件方法,不传递回调函数,则会出发浏览器默认行为。<ul><li>对象.submit,提交表单</li><li>对象.focus(如果没有回调函数,默认设置焦点)</li></ul></li></ul></li><li>on绑定事件/off解绑事件<ul><li>jq对象.on(“事件名称”,回调函数);</li><li>jq对象.off(“事件名称”);</li><li>tips:如果off不传入任何参数,则会默认解绑所有事件</li></ul></li><li>事件切换:toggle<ul><li>jq对象.toggle(fn1,fn2);<ul><li>点击会依次循环切换执行函数。</li><li>jQuery1.9取消此功能,导入jQuery-migrate.js可以执行</li></ul></li></ul></li></ol></li><li><p>插件:增强JQuery的功能</p><ol><li>实现方式:<ol><li>$.fn.extend(object)<ul><li>增强通过Jquery获取的对象的功能 $(“#id”)</li></ul></li><li>$.extend(object)<ul><li>增强Jquery对象自身的功能 $/jQuery</li><li>调用方式$.插件名</li></ul></li></ol></li></ol></li></ol></li></ol><h4 id="案例"><a href="#案例" class="headerlink" title="案例:"></a>案例:</h4><ul><li>需求:<ol><li>提供index.html页面,页面中有一个省份 下拉列表</li><li>当页面加载完成后 发送ajax请求,请求json省份信息</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> front-end </tag>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC获取数据库连接</title>
      <link href="2021/04/28/jdbc%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5/"/>
      <url>2021/04/28/jdbc%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="获取数据库连接"><a href="#获取数据库连接" class="headerlink" title="获取数据库连接"></a>获取数据库连接</h3><ol><li>Driver接口实现类:驱动<ul><li>mysql 8.0驱动 com.mysql.cj.jdbc.Driver</li><li>加载与注册JDBC驱动<ul><li>加载驱动:加载JDBC驱动需调用Class类的静态方法forName(),向其传递要加载的JDBC驱动的类名<ul><li>Class.forName(“com.mysql.cj.jdbc.Driver”) /* 反射 */</li></ul></li><li>注册驱动:DreiverManager类是驱动程序管理器类,负责管理驱动程序<ul><li>使用DriverManage.registerDriver(com.mysql.cj.jdbc.Driver)注册驱动</li><li>通常不显示调用DriverManager类的registerDriver方法来注册驱动程序类的实例?</li></ul></li></ul></li><li>数据库厂商根据jdk的Driver接口编写Driver的实现类</li></ul></li></ol><p>2 URL</p><ul><li><p>JDBC URL用于标识一个被注册的驱动程序,驱动程序管理器通过这个URL选择正确的驱动程序,从而建立到数据库的连接</p></li><li><p>JDBC URl的标准由三部分组成,各部分间用冒号分隔</p><ul><li>jdbc:子协议:子名称</li><li>协议:JDBC URL中的协议总是jdbc</li><li>子协议:子协议用于标识一个数据库驱动程序</li><li>子名称:一种标识数据库的方法。子名称额可以依不同的子协议而变化,用子名称的目的是为了定位数据库提供足够的信息。包括<strong>主机名</strong>(对应的服务端的ip地址),<strong>端口号</strong>,<strong>数据库名</strong><ul><li>举例</li><li>jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone = GMT</li><li>在 mysql 8.0应该这样写,加上时区</li></ul></li></ul></li><li><p>几种常用的数据库的jdbc url</p><ul><li>mysql连接URL编写的方法<ul><li>jdbc:mysql://主机名称:mysql服务端口号/数据库名称?参数=值&amp;参数=值</li><li>jdbc:mysql://localhost:3306/test</li><li>jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf8(如果jdbc程序与服务器段的字符集不一致,会导致乱码,那么可以通过参数指定服务器端的字符集)</li><li>jdbc:mysql://localhost:3306/test?user=root&amp;password=123456</li></ul></li><li>Oracle 9i的连接URL编写方式：<ul><li>jdbc:oracle:thin:@主机名称:oracle服务端口号:数据库名称</li><li>jdbc:oracle:thin:@localhost:1521:atguigu</li></ul></li><li>SQLServer的连接URL编写方式：<ul><li>jdbc:sqlserver://主机名称:sqlserver服务端口号:DatabaseName=数据库名称</li><li>jdbc:sqlserver://localhost:1433:DatabaseName=atguigu</li></ul></li></ul></li></ul><ol start="3"><li><p>用户名和密码</p><ul><li>user,password可以用”属性名=属性值”方式告诉数据库</li><li>可以调用DriverManager类的getConnection()方法建立到数据库的连接 <h3 id="获取数据库连接的方法"><a href="#获取数据库连接的方法" class="headerlink" title="获取数据库连接的方法"></a>获取数据库连接的方法</h3></li></ul></li><li><p>连接的方式1(出现了第三方API)</p><pre><code> //方式一    Driver driver = new com.mysql.cj.jdbc.Driver();    String url = &quot;jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone = GMT&quot;;    //将用户名和秘密码封装在Properties中    Properties info = new Properties();    info.setProperty(&quot;user&quot;, &quot;root&quot;);    info.setProperty(&quot;password&quot;, &quot;123456&quot;);    Connection connection = driver.connect(url,info);    System.out.println(connection);</code></pre></li><li><p>连接的方式2(利用反射实现Dynamic动态性,使程序具有更好的可移植性)</p><pre><code>     //方式二     //1.根据反射获取Driver的mysql接口子类实现类     Class clazz = Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);     Driver driver = (Driver) clazz.getDeclaredConstructor().newInstance();     //2.提供要连接的数据库     String url =&quot;jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone = GMT&quot;;     //3.提供连接需要的用户名和密码     Properties info = new Properties();     info.setProperty(&quot;user&quot;, &quot;root&quot;);     info.setProperty(&quot;password&quot;, &quot;123456&quot;);     //4.获取连接     Connection connection = driver.connect(url,info);     System.out.println(connection);</code></pre></li><li><p>连接的方式3(利用DriverManager实现的管理Driver)</p><pre><code> //方式三 利用DriverManager类而不用Driver获取连接,需要注册驱动 //1.根据反射获取Driver的mysql接口子类实现类 Class clazz = Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); Driver driver = (Driver) clazz.getDeclaredConstructor().newInstance(); //2.提供另外三个连接的基本信息 String url = &quot;jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone = GMT&quot;; String user = &quot;root&quot;; String password = &quot;123456&quot;; //注册驱动 DriverManager.registerDriver(driver); //获取连接 Connection connection = DriverManager.getConnection(url,user,password); System.out.println(connection);</code></pre></li><li><p>连接方式4(优化获取Driver实现类的对象)</p><pre><code> //方式四 优化方式三 优化获取Driver实现类的对象 // ※可以省略创建Driver对象,注册driver的操作mysql的Driver实现类中在类加载时注册了driver实现类 //1.加载mysql的Driver Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); //Driver driver = (Driver) clazz.getDeclaredConstructor().newInstance(); //2.提供另外三个连接的基本信息 String url = &quot;jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone = GMT&quot;; String user = &quot;root&quot;; String password = &quot;123456&quot;; //获取连接 Connection connection = DriverManager.getConnection(url,user,password); System.out.println(connection); </code></pre></li><li><p>连接方式5(最终版,将数据库的驱动与程序解耦写入配置文件)</p><pre><code> //方式五 将数据与程序结构,写入配置文件 //得到properties文件 InputStream is = ConnectionTest.class.getClassLoader().getResourceAsStream(&quot;mysql.properties&quot;); Properties initial = new Properties(); initial.load(is); String driver = initial.getProperty(&quot;driver&quot;); String url = initial.getProperty(&quot;url&quot;); String user = initial.getProperty(&quot;user&quot;); String password = initial.getProperty(&quot;password&quot;); //加载驱动 Class.forName(driver); //获得连接 Connection connection = DriverManager.getConnection(url,user,password); System.out.println(connection);</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jdbc_connection </tag>
            
            <tag> java_sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jdbc中的crud操作</title>
      <link href="2021/04/28/jdbc%E4%B8%AD%E7%9A%84Crud/"/>
      <url>2021/04/28/jdbc%E4%B8%AD%E7%9A%84Crud/</url>
      
        <content type="html"><![CDATA[<h3 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h3><ul><li>预编译的SQL语句</li></ul><h3 id="SQL中的CRUD"><a href="#SQL中的CRUD" class="headerlink" title="SQL中的CRUD"></a>SQL中的CRUD</h3><ul><li><p>总的流程</p><ol><li>获取数据库连接</li><li>预编译sql语句,返回PreparedStatement实例</li><li>填充占位符</li><li>执行</li><li>关闭资源</li></ol></li><li><p>小技巧</p><ol><li>占位符:?<ul><li>将自己想要改变的参数填上占位符</li><li>表不能用占位符</li></ul></li><li>将获得连接与关闭流写在一个工具类里面</li></ol></li><li><p>INSERT</p><pre><code>    //预编译sql语句,返回PreparedStatement实例  String sql = &quot;INSERT INTO customers(name,email,birth) VALUES (?,?,?)&quot;;//?:占位符  pr = connection.prepareStatement(sql);  //填充占位符,数据索引从1开始  pr.setString(1,&quot;哪吒&quot;);  pr.setString(2,&quot;nezha@gmail.com&quot;);  SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);  java.util.Date date = sdf.parse(&quot;1001-01-01&quot;);  pr.setDate(3,new Date(date.getTime()));  //执行操作  pr.execute();</code></pre></li><li><p>UPDATE</p><pre><code>  //1.获取数据库连接  Connection connection = JDBCUtils.getConnection();  //2.预编译sql语句,返回PreparedStatement的实例  String sql = &quot;UPDATE customers SET name = ? WHERE id = ?&quot;;  //预编译SQL语句  PreparedStatement ps = connection.prepareStatement(sql);  //3.填充占位符  ps.setObject(1,&quot;莫扎特&quot;);  ps.setObject(2,18);  //4.执行  ps.execute();  //5.资源的关闭  JDBCUtils.closeResource(connection,ps);</code></pre></li><li><p>通用的增删改操作</p><pre><code>  Connection connection = null;  PreparedStatement ps = null;  try &#123;      //1.获取连接      connection = JDBCUtils.getConnection();      //2.获取PreparedStatement类      ps = connection.prepareStatement(sql);      //3.填充占位符      for (int i = 0; i &lt; objects.length; i++) &#123;          ps.setObject(i + 1, objects[i]);      &#125;      //4.执行      ps.execute();      //5.关闭流  &#125; catch (Exception e)&#123;      JDBCUtils.closeResource(connection, ps);  &#125;</code></pre></li><li><p>SELECT</p><ul><li><p>针对单个表的查询的固定查询</p><pre><code>  Connection connection = null;  PreparedStatement ps = null;  ResultSet resultSet = null;  try &#123;      //1.获取数据库连接      connection = JDBCUtils.getConnection();      //2.预编译SQL      ps = connection.prepareStatement(sql);      //3.填充占位符      for (int i = 0; i &lt; objects.length; i++) &#123;          ps.setObject(i + 1, objects[i]);      &#125;      //4.获取结果Set      resultSet = ps.executeQuery();      //5.打印结果      while (resultSet.next()) &#123;          int id = resultSet.getInt(1);          String name = resultSet.getString(2);          String email = resultSet.getString(3);          java.sql.Date date = resultSet.getDate(4);          Customers customers = new Customers(id, name, email, date);          System.out.println(customers);      &#125;  &#125;catch (Exception e)&#123;      e.printStackTrace();  &#125;finally &#123;      //6.关闭流      JDBCUtils.closeResource(connection,ps,resultSet);  &#125;</code></pre></li><li><p>针对单个表的通用查询:</p><ul><li>需要获取ResultSetMetaDate()来获取列长度,列名</li><li>如果有order_id等字段与java属性不符,需要将查询出来的字段label改为java属性名<pre><code>  List&lt;Customers&gt; list = new ArrayList&lt;&gt;();  Connection connection = null;  PreparedStatement ps = null;  ResultSet rs = null;  try &#123;      //1.获取sql连接      connection = JDBCUtils.getConnection();      //2.执行sql预编译      ps = connection.prepareStatement(sql);      //3.编译sql      for (int i = 0; i &lt; objects.length; i++) &#123;          ps.setObject(i + 1, objects[i]);      &#125;      //4.1获得结果集合      rs = ps.executeQuery();      //4.2获得结果元集合      ResultSetMetaData rsmd = rs.getMetaData();      //4.3得到列的长度      int colCounts = rsmd.getColumnCount();      //4.4循环添加对象      while (rs.next()) &#123;          //创建Customer对象          Customers cus = new Customers();          for (int i = 0; i &lt; colCounts; i++) &#123;              //得到每一列的值              Object val = rs.getObject(i + 1);              //得到每一列的名字              String colName = rsmd.getColumnLabel(i + 1);              //根据列名和值通过反射设置              Field field = Customers.class.getDeclaredField(colName);              field.setAccessible(true);              field.set(cus, val);          &#125;          //将设置好的cus对象存入队列          list.add(cus);      &#125;  &#125;catch (Exception e)&#123;      e.printStackTrace();  &#125;finally &#123;      JDBCUtils.closeResource(connection,ps,rs);  &#125;  return list;</code></pre></li></ul></li><li><p>针对多个表的通用查询&lt;运用泛型&gt;</p><pre><code>  List&lt;T&gt; list = new ArrayList&lt;&gt;();  Connection connection = null;  PreparedStatement ps = null;  ResultSet rs = null;  try &#123;      //1.建立连接     connection = JDBCUtils.getConnection();      //2.获取PreparedStatement      ps = connection.prepareStatement(sql);      //3.填充占位符      for (int i = 0; i &lt; objects.length; i++) &#123;          ps.setObject(i+1,objects[i]);      &#125;      //4结果处理      //4.1获取结果集      rs = ps.executeQuery();      //4.2获取结果元组      ResultSetMetaData rsmd = rs.getMetaData();      //4.3获取列的长度      int colCounts = rsmd.getColumnCount();      //4.4循环进行操作      while(rs.next())&#123;          T t = clazz.getDeclaredConstructor().newInstance();          for (int i = 0; i &lt; colCounts; i++) &#123;              //获取每一列的val              Object val = rs.getObject(i+1);              //反射设置每一列的值              String colName = rsmd.getColumnLabel(i+1);              Field field = clazz.getDeclaredField(colName);              field.setAccessible(true);              field.set(t,val);          &#125;          list.add(t);      &#125;  &#125;catch (Exception e)&#123;      e.printStackTrace();  &#125;finally &#123;      JDBCUtils.closeResource(connection,ps,rs);  &#125;  return list;</code></pre><p>  }</p><h4 id="PreparedStatement好处"><a href="#PreparedStatement好处" class="headerlink" title="PreparedStatement好处"></a>PreparedStatement好处</h4></li></ul></li><li><p>解决Statement拼串问题</p></li><li><p>解决sql注入问题,预编译之后数据的关系不会改变</p></li><li><p>PreparedStatement可以操作Blob数据,而Statement做不到</p></li><li><p>PreparedStatement可以更高效实现批量操作</p><ul><li>预编译只需要对sql语句校验一次</li><li>Statement每一次sql语句都需要校验</li><li>提高效率方式1:可以使用batch减少与磁盘的io次数,但是Mysql默认不支持Batch操作,需要我们在url中添加参数rewriteBatchedStatements=true(8.0以后mysql默认支持batch)</li><li>提高效率方式2:在获取连接时设置不允许自动提交数据,在结束后再提交</li><li>关键语句:addBatch(),ExecuteBatch(),clearBatch,setAutoCommit(),commit()<pre><code>  public void testAbandont()&#123;      Connection connection = null;      PreparedStatement ps = null;      long start = System.currentTimeMillis();      try &#123;          connection = JDBCUtils.getConnection();          connection.setAutoCommit(false);          ps = connection.prepareStatement(&quot;INSERT INTO test1(name) VALUES(?)&quot;);          for (int i = 0; i &lt; 200000; i++) &#123;              ps.setObject(1,&quot;tom&quot;+i);              ps.addBatch();              if(i%500 == 0||i==200000)&#123;                  ps.executeBatch();                  ps.clearBatch();              &#125;          &#125;          connection.commit();          System.out.println(System.currentTimeMillis()-start);      &#125;catch (Exception e)&#123;          e.printStackTrace();      &#125;finally &#123;          JDBCUtils.closeResource(connection,ps);      &#125;</code></pre></li></ul></li></ul><h4 id="实现通用查询的方法"><a href="#实现通用查询的方法" class="headerlink" title="实现通用查询的方法"></a>实现通用查询的方法</h4><ul><li>反射<ul><li>设置属性</li></ul></li><li>泛型<ul><li>针对不同对象</li></ul></li></ul><h4 id="BLOB类"><a href="#BLOB类" class="headerlink" title="BLOB类"></a>BLOB类</h4><ul><li><p>blob的类型</p><ul><li>TINYBLOB 1B</li><li>BLOB 64KB</li><li>MEDIUMBLOB 16MB</li><li>LONGBLOB 4GB</li></ul></li><li><p>tips</p><ul><li>相对路径的根路径是proj项目文件不是src</li><li>如果引入Blob文件大于mysql配置文件的限定大小,会出现Date too long异常,设置max_allowd_packet=16M</li></ul></li><li><p>添加到数据库</p><pre><code>  InputStream is = new InputStream(url)  ps.setBlob(index,is)</code></pre></li><li><p>从数据库读取Blob类型并下载至本地</p><pre><code>  Blob b = resultSet.getBlob(lable)  //获取流  InputStream is = b.getBinaryStream();  //设置输出流  FileOutputStream fos = new FileOutputStream(url);  //读取输入流设置缓存  byte[] buffer = new byte[1024]  int len = 0  //利用缓存区读取          while((len = is.read(buffer))!=0)&#123;      fos.write(buffer,0,len);  &#125;</code></pre></li><li><p>Blob类型的插入</p><ul><li>Blob类型的插入需要用到setBlob方法(index,inputStream)</li><li>其中inputStream指向需要插入文件 <pre><code>  public void insertBlob()&#123;  Connection connection = null;  PreparedStatement ps = null;  InputStream is = null;  try &#123;      //建立连接      connection = JDBCUtils.getConnection();      //预编译sql      String sql = &quot;INSERT INTO customers VALUES(?,?,?,?,?)&quot;;      ps = connection.prepareStatement(sql);      //填充占位符      ps.setObject(1,&quot;24&quot;);      ps.setObject(2,&quot;刘亦菲&quot;);      ps.setObject(3,&quot;yifei@gmail.com&quot;);      ps.setObject(4,&quot;1990-02-06&quot;);      //获取读入流      is = new FileInputStream(&quot;src//liuyifei1.png&quot;);      ps.setBlob(5,is);      //执行      ps.execute();  &#125;catch (Exception e)&#123;      e.printStackTrace();  &#125;finally &#123;      JDBCUtils.closeResource(connection,ps);      try&#123;          if(is != null) is.close();      &#125;catch (Exception e)&#123;          e.printStackTrace();      &#125;  &#125;  </code></pre></li></ul></li></ul><ul><li><p>Blob类型的读取</p><ul><li><p>Blob类型的读取需要用java的java.sql.Blob类型接取</p></li><li><p>Blob类型有一个方法得到其二进制输入流Blob.inputBinaryStream</p><p>  Connection connection = null;<br>  PreparedStatement ps = null;<br>  InputStream is = null;<br>  OutputStream os = null;<br>  ResultSet rs = null;<br>  try {</p><pre><code>  //建立连接  connection = JDBCUtils.getConnection();  //查询  String sql = &quot;SELECT id,name,email,birth,photo FROM customers WHERE id = ?&quot;;  ps = connection.prepareStatement(sql);  ps.setObject(1,20);  rs = ps.executeQuery();  if(rs.next()) &#123;      Customers cus = new Customers();      cus.setId(rs.getInt(&quot;id&quot;));      cus.setBirth(rs.getDate(&quot;birth&quot;));      cus.setEmail(rs.getString(&quot;email&quot;));      cus.setName(rs.getString(&quot;name&quot;));      //获取blob      Blob blob = rs.getBlob(&quot;photo&quot;);      //获取输入流      is = blob.getBinaryStream();      //设置输出流      os = new FileOutputStream(&quot;output.png&quot;);      byte[] buffer = new byte[1024];      int len = 0;      while((len = is.read(buffer)) != -1)&#123;          os.write(buffer,0,len);      &#125;  &#125;</code></pre><p>  }catch (Exception e){</p><pre><code>  e.printStackTrace();</code></pre><p>  }finally {</p><pre><code>  JDBCUtils.closeResource(connection,ps,rs);  try&#123;      if(os != null) os.close();  &#125;catch (Exception e)&#123;      e.printStackTrace();  &#125;  try&#123;      if(is != null) is.close();  &#125;catch (Exception e)&#123;      e.printStackTrace();  &#125;</code></pre><p>  }</p></li></ul></li></ul><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><ol><li><p>插入操作</p><ul><li>mysqldate隐式转换”yyyy-MM-dd”;</li><li>ps.execute()<ul><li>查询操作,有返回结果,则此方法返回true</li><li>如果时曾删改没有返回结果,返回false</li></ul></li><li>ps.executeUpdate()<ul><li>返回值是影响的行数</li></ul></li></ul></li><li><ol><li>创立数据库表examStudent,表结构如下<ul><li>FlowID 流水号 int(10)</li><li>Type 四级/六级 int(5)</li><li>IDCard 身份证号码 varchar(18)</li><li>ExamCard 准考证号码 varchar(15)</li><li>StudentName 学生姓名 varchar(20)</li><li>Location 区域 varchar(20)</li><li>Grade 成绩 int(10)</li></ul></li><li>向表中添加数据</li></ol></li></ol><h4 id="PreparedStatement与Statement区别"><a href="#PreparedStatement与Statement区别" class="headerlink" title="PreparedStatement与Statement区别"></a>PreparedStatement与Statement区别</h4><ul><li>都是Sun公司提供的</li><li>Pre是Statement的子接口</li><li>PreparedStatement可以防止SQL注入</li><li>PreparedStatement可以最大程度提高性能</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jdbc_crud </tag>
            
            <tag> jdbc_preparedStatment </tag>
            
            <tag> java_reflect </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL中的变量</title>
      <link href="2021/04/24/MYSQL%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F/"/>
      <url>2021/04/24/MYSQL%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul><li>分类<ul><li>系统变量<ul><li>全局变量</li><li>会话变量</li></ul></li><li>自定义变量<ul><li>用户变量</li><li>局部变量</li></ul></li></ul></li></ul><h4 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h4><ul><li><p>说明:变量由系统提供,不是用户定义,属于服务器层面</p></li><li><p>语法:</p><ol><li><p>查看所有的系统变量</p><pre><code> SHOW (GLOBAL 全局,SESSION 会话)VARIABLES;</code></pre></li><li><p>查看满足条件的部分系统变量</p><pre><code> SHOW GLOBAL|SESSION VARIABLES LIKE &#39;%char%&#39;;</code></pre></li><li><p>查看指定的某个系统变量的值</p><pre><code> SELECT @@global|session.系统变量名;</code></pre></li><li><p>为某个系统变量赋值<br> 方式1:</p><pre><code>     SET GLOBAL|SESSION 系统变量名 = 值;</code></pre><p> 方式2:</p><pre><code>     SET @@GLOBAL|SESSION.系统变量名 = 值;</code></pre></li></ol></li><li><p>注意</p><ul><li>如果时全局级别,则需要加global</li><li>如果时会话级别,默认或session<h4 id="系统变量-1"><a href="#系统变量-1" class="headerlink" title="系统变量"></a>系统变量</h4></li></ul></li></ul><ol><li>全局变量<pre><code> * 跨连接有效 * 作用域:服务器每次启动将为所有的全局变量赋初始值,针对于所有的会话(连接),但是不能跨重启 * 如果需求每次重启服务器都为自己预想的变量,则需要修改配置文件</code></pre><ol><li>查看所有的全局变量<pre><code> SHOW GLOBAL VARIABLES;</code></pre></li><li>查看部分的全局变量<pre><code> SHOW GLOBAL VARIABLES LIKE &#39;%char%&#39;;</code></pre></li><li>查看指定的全局变量的值<pre><code> SELECT @@global.autocommit; SELECT @@TRANSACTION_ISOLATION;</code></pre></li><li>为某个指定的全局变量赋值<pre><code> SET global autocommit = 0; SET @@global.autocommit = 0;</code></pre></li></ol></li><li>会话变量<pre><code> * 仅仅针对于当前会话(连接)有效 </code></pre><ol><li>查看所有的会话变量<pre><code> SHOW [SESSION] VARIABLES</code></pre></li><li>查看部分的会话变量<pre><code> SHOW [SESSION] VARIABLES LIKE&#39; &#39;</code></pre></li><li>查看指定的全局变量的值<pre><code> SELECT @@SESSION.autocommit; SELECT @@TRANSACTOIN_ISOLATION; </code></pre></li><li>为某个会话变量赋值<ol><li>方式一<pre><code> SET @@TRANSACIONT = &#39;read-uncommitted&#39;;</code></pre></li><li>方式二<pre><code> SET SESSION TRANSACTION_ISOLATION = &#39;read_committed&#39;; </code></pre><h4 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h4></li></ol></li></ol><ul><li>变量由用户自定义的,不是由系统定义的</li><li>使用步骤:<pre><code>      声明      赋值      使用(查看、比较、运算等)</code></pre></li></ul></li><li>用户变量<ul><li>作用域<ul><li>针对于当前会话(连接)连接有效,等同关于会话变量的作用域</li><li>应用在任何地方,也就是begin end里面或begin end外面    </li></ul></li><li>使用:用户变量使用时需要加@<pre><code>  1. 声明并初始化:赋值的操作符: = 或 :=      SET @用户变量名 = 值;      SET @用户变量名:= 值;      SELECT @用户变量名:=值;  2. 赋值(更新用户变量的值)      方式一:通过SET 或 SELECT          SET @用户变量名=值          SET @用户变量名:=值          SELECT @用户变量名:=值      方式二:通过SELECT INTO          SELECT 字段 INTO @变量名          FROM 表;    </code></pre></li></ul></li><li>局部变量<ul><li>作用域<ul><li>仅仅在定义它的begin end 中有效</li><li>begin end中的第一句话</li></ul></li><li>使用</li></ul></li></ol><pre><code>        1. 声明            DECLARE 变量名 类型;            DECLARE 变量名 类型 DEFAULT 值;        2. 赋值            方式一:通过SET 或 SELECT                SET 局部变量名=值                SET 局部变量名:=值                SELECT @局部变量名:=值            方式二:通过SELECT INTO                SELECT 字段 INTO 局部变量名                FROM 表;            3. 使用            SELECT 局部变量名</code></pre><h4 id="用户变量与局部变量对比"><a href="#用户变量与局部变量对比" class="headerlink" title="用户变量与局部变量对比"></a>用户变量与局部变量对比</h4><ul><li>作用域<ul><li>用户变量针对当前会话</li><li>局部变量针对BEGIN END中</li></ul></li><li>定义和使用位置<ul><li>用户变量会话中的任何地方</li><li>局部变量只能在BEGIN END中,且为第一句话</li></ul></li><li>语法<ul><li>用户变量必须加@符号,不用限定类型</li><li>局部变量一般不用加@符号,需要限定类型</li><li>用户变量与局部变量的声明不同,赋值相似,使用相似</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> MYSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> VARIABLES </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL中的视图</title>
      <link href="2021/04/24/MYSQl%E4%B8%AD%E7%9A%84%E8%A7%86%E5%9B%BE/"/>
      <url>2021/04/24/MYSQl%E4%B8%AD%E7%9A%84%E8%A7%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h4 id="视图-VIEW"><a href="#视图-VIEW" class="headerlink" title="视图:VIEW"></a>视图:VIEW</h4><ul><li>含义: 虚拟表,和普通表一样使用<ul><li>保存的查询语句,可以直接调用,需要查询的时候直接调用视图<ul><li>类似于java的方法</li></ul></li><li>mysql 5.1版本出现的新特性,是通过表动态生成的数据</li></ul></li><li>特点<ul><li>临时性:视图只有在被调用时虚拟表才会产生,没有保存数据,只保存了SQL逻辑,不保存查询结果</li></ul></li><li>应用场景<ul><li>多个地方用到同样的查询结果</li><li>该查询结果使用的SQL语句较复杂</li></ul></li><li>好处<ul><li>重用了sql语句</li><li>简化复杂的SQL操作,不必知道它的查询细节</li><li>保护数据、提高安全性,只提供了一个接口,没提供原表<h4 id="视图的创建与使用"><a href="#视图的创建与使用" class="headerlink" title="视图的创建与使用"></a>视图的创建与使用</h4></li></ul></li><li>案例<ol><li>查询姓名中中包含a字符的员工名、部门名和工种信息<ul><li>创建<pre><code>  CREATE VIEW       myv1  AS      SELECT       last_name,department_id,j.job_title  FROM      employees e  JOIN          jobs j  ON      e.job_id = j.job_id;</code></pre></li><li>使用<pre><code>  SELECT      *      FROM      myv1  WHERE      last_name LIKE &quot;%a%&quot;;</code></pre></li></ul></li><li>查询各部门的平均工资级别<ul><li>创建视图查看每个部门的平均工资<pre><code>  CREATE VIEW      deparment_avg_salary  AS  SELECT          department_id,AVG(salary) ag  FROM      employees  GROUP BY      department_id</code></pre></li><li>使用<pre><code>  SELECT      department_id,grade_level  FROM      department_avg_salary d  JOIN      job_grades j  ON      d.ag BETWEEN j.lowest_sal AND j.highest_sal;    </code></pre></li></ul></li><li>查询平均工资最低的部门信息<ul><li>创建视图:同2</li><li>使用视图:同4</li></ul></li><li>查询平均工资最低的部门名和工资<ul><li>创建视图:同2、3</li><li>使用视图<pre><code>  SELECT      *  FROM      department_avg_salary  WHERE      ag = (  SELECT      MIN(ag)  FROM      department_avg_salary);</code></pre><h4 id="视图的修改"><a href="#视图的修改" class="headerlink" title="视图的修改"></a>视图的修改</h4></li></ul></li></ol></li><li>方式一<ul><li>语法<pre><code>  CREATE OR REPLACE VIEW       视图名  AS          查询语句；</code></pre></li><li>作用<ul><li>创建或者改变视图<ul><li>视图不存在创建</li><li>视图存在改变</li></ul></li></ul></li></ul></li><li>方式二<ul><li>语法<pre><code>  ALTER VIEW      视图名  AS      查询语句</code></pre></li><li>作用<ul><li>改变视图,不能创建视图</li></ul></li></ul></li></ul><h4 id="视图的删除"><a href="#视图的删除" class="headerlink" title="视图的删除"></a>视图的删除</h4><ul><li><p>语法</p><pre><code>  DROP VIEW      视图名,视图名;</code></pre><h4 id="视图结构的查看"><a href="#视图结构的查看" class="headerlink" title="视图结构的查看"></a>视图结构的查看</h4></li><li><p>语法</p><ol><li>展示视图结构,和展示表结构类似<pre><code> DESC     视图名;</code></pre></li><li>展示详细信息(创建语句,视图名,字符集等等)<pre><code> SHOW CREATE VIEW     视图名;</code></pre><h4 id="视图的更新"><a href="#视图的更新" class="headerlink" title="视图的更新"></a>视图的更新</h4></li></ol></li><li><p>视图不允许更新的特点</p><ol><li><p>具有以下关键字的SQL语句:分组函数、distinct、group by、having、union、union all</p><ul><li>不是原表原数据的数组不允许更改</li></ul></li><li><p>常量视图</p></li><li><p>SELECT 中包含子查询</p></li><li><p>SELECT 中包含join,92,99语法都不行</p></li><li><p>FROM一个不能更新的视图</p></li><li><p>WHERE子句的子查询引用了FROM子句中的表    </p></li></ol></li><li><p>总结</p><ul><li>视图更新时必须只能参照原表的数据,不能更新由原表数据进行任何操作形成的视图。</li><li>视图的更新会对原表的数据进行更新,这就是为什么视图更新只能参照原表的数据。</li><li>对于创建视图时引用了不能跟新的视图时也不能更新,级联更新</li><li>视图的更新只能对单个表,单行数据更新</li><li>视图中不允许更新可能是不允许CRUD中的某一项也可能都不支持</li></ul></li></ul><h4 id="视图和表的对比"><a href="#视图和表的对比" class="headerlink" title="视图和表的对比"></a>视图和表的对比</h4><pre><code>* 创建语法    * CREATE VIEW    * CREATE TABLE* 是否占用物理空间    * 视图不占用数据存储空间,占用逻辑语句存储的空间,只保留了SQL逻辑    * 表占用数据空间* 使用    * VIEW可以使用增删改查,但一般不用,且使用起来有限制    * TABLE使用见DML</code></pre>]]></content>
      
      
      <categories>
          
          <category> MYSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VIEW </tag>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaScript DOM树基础</title>
      <link href="2021/04/22/js-dom/"/>
      <url>2021/04/22/js-dom/</url>
      
        <content type="html"><![CDATA[<h4 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h4><ul><li><p>概念: Document Object Model 文档对象模型</p><ul><li>将标记语言文档的各个组成部分,封装为对象.可以使用这些对象,都标记语言文档进行CRUD的动态操作</li></ul></li><li><p>W3C DOM标准被分为3个不同的部分:</p><ul><li><p>核心 DOM - 针对任何结构化文档的标准模型</p><ul><li><p>Document : 文档对象</p></li><li><p>Element: 元素对象</p></li><li><p>Attribute: 属性对象</p></li><li><p>Text: 文本对象</p></li><li><p>Comment: 注释对象</p></li><li><p>Node: 节点对象,其它5个的父对象</p></li></ul></li><li><p>XML DOM - 针对XML文档的标准模型</p></li><li><p>HTML DOM - 针对HTML文档的标准类型                 </p></li></ul></li><li><p>核心DOM模型:                                                 </p><ul><li>Document:文档对象<ol><li>创建(获取):在html dom模型中可以使用windox对象获取<ol><li>window.document</li><li>document</li></ol></li><li>方法<ol><li>获取Element对象:<ol><li>getElementById():根据id属性值获取元素对象。id属性值一般唯一</li><li>getElementsByTagName():根据元素名称获得元素对象们,返回值时元素数组</li><li>getElementsByClassName():根据Class属性值获取元素对象们。返回值是一个数组</li><li>getElementsByName():根据name属性值获取元素对象们</li></ol></li><li>创建其他DOM对象:<ol><li>createAttribute(name)</li><li>createComment()</li><li>createElement()</li><li>createaTextNode()</li></ol></li></ol></li><li>属性</li></ol></li><li>Element:元素对象<ul><li>创建/获取：通过document来获取和创建</li><li>方法:<ol><li>removeAttribute():删除属性</li><li>setAttribute():设置属性</li></ol></li></ul></li><li>Node:节点对象,其他5个的父对象<ul><li>特点:所有dom对象都可以被认为是一个节点</li><li>方法:<ul><li>CRUD dom树:<ul><li>appendChild():向节点的子节点列表的结尾添加新的子节点</li><li>removeChild():删除(并返回)当前节点的指定子节点</li><li>replaceChild():用新节点替换一个子节点</li></ul></li></ul></li><li>属性<ul><li>parentNode:返回节点的父节点</li></ul></li></ul></li></ul></li><li><p>HTML DOM                                    </p><ol><li><p>标签体的设置和获取:innerHTML</p><pre><code>  &lt;div id=&quot;div1&quot;&gt;     div   &lt;/div&gt; &lt;script&gt;   var div = document.getElementById(&quot;div1&quot;);   var innerHTML = div.innerHTML;   div.innerHTML += &quot;&lt;input type=&#39;text&#39;&#39;&gt;&quot;;   //div标签追加一个文本输入框   &lt;/script&gt;</code></pre></li><li><p>使用html元素对象的属性</p></li><li><p>控制元素样式        </p><pre><code> &lt;div id=&quot;div1&quot;&gt;   div &lt;/div&gt;   &lt;script&gt;   var div1 = document.getElementById(&quot;div1&quot;);   div1.onclick = function ()&#123;     //修改样式方式1,使用元素的style属性设置     div1.style.border = &quot;1px solid red&quot;     div1.style.fontSize = &quot;20px&quot;;     //修改样式方式2     提前定义好class选择器的样式,通过元素的className属性来设置class属性     &#125;     div2.onclick = function ()&#123;     div2.className = &quot;d2&quot;;     &#125;                  &lt;/script&gt;    </code></pre></li></ol></li></ul><h4 id="事件监听机制"><a href="#事件监听机制" class="headerlink" title="事件监听机制:"></a>事件监听机制:</h4><ul><li>概念:某些组件被执行了某些操作后,出发某些代码的执行        <ul><li>事件:某些操作,如:单击,双击,键盘按下,鼠标移动                                    <ul><li>事件源：组件 如:按钮 文本输入框…</li><li>监听器: 代码</li><li>注册监听: 将事件,事件源,监听器结合在一起。当事件源上发生了某个事件，则出发执行某个监听器代码</li></ul></li><li>常见的事件<ol><li>点击事件:<ol><li>onclick 单机事件</li><li>ondbclick 双击事件</li></ol></li><li>焦点事件<ol><li>onblur:失去焦点<ul><li>一般用于表单校验(失去焦点时判断内容是否符合规则)    </li></ul></li><li>onfocus:元素获得焦点</li></ol></li><li>加载事件<ol><li>onload：一张页面或一幅图像完成加载<ul><li>window.onload<pre><code>     window.onload = function ()&#123;        document.getElementById(&quot;username&quot;).onblur = function ()&#123;         alert(&quot;失去焦点了&quot;);        &#125;      &#125;</code></pre></li></ul></li></ol></li><li>鼠标事件<ol><li>onmousedown 鼠标被按下<ul><li>定义方法时，定义一个形参，接受event对象</li><li>event对象俺的button属性可以后去鼠标按钮被点击了</li><li>左中右 012</li></ul></li><li>onmouseup 鼠标被松开</li><li>onmousemove 鼠标被移动</li><li>onmouseover 鼠标移到某元素</li><li>onmouseout 鼠标从某元素移开</li></ol></li><li>键盘事件    <ol><li>onkeydown 某个键被按下</li><li>onkeyup 某个键被松开</li><li>onkeypress 某个键被按下并松开</li></ol></li><li>选择和改变<ol><li>onchange 域的内容被改变</li><li>onselect 文本被选中</li></ol></li><li>表单事件<ol><li>onsubmit 确认按钮被点击<ul><li>可以阻止表单提交<ul><li>方法 return false:表单被阻止提交</li></ul></li></ul></li><li>onreset 重置按钮被重置 </li></ol></li></ol></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> javaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaScript </tag>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL中的事务</title>
      <link href="2021/04/21/MySQL%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1/"/>
      <url>2021/04/21/MySQL%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h4 id="TCL-Transaction-Control-Language-事务控制语言"><a href="#TCL-Transaction-Control-Language-事务控制语言" class="headerlink" title="TCL:Transaction Control Language 事务控制语言"></a>TCL:Transaction Control Language 事务控制语言</h4><ul><li><p>简介</p><ul><li>事务:一个或一组sql语句组成一个执行单元,这个执行单元要么全部执行,要么全部不执行.如果单元中某条sql语句一旦执行失败或产生错误,整个单元将会回滚。所有受到影响的数据将返回到事务开始以前的状态</li><li>引入案例: 转账<ul><li>不能一个转出后发生Exception另一个不转入</li></ul></li></ul></li><li><p>事务的acid属性</p><ol><li>原子性(Atomicity):事务不可分割,食物中的操作要么都发生,要么都不发生</li><li>一致性(Consistency):事务必须从数据库从一个状态切换到另一个一致性的状态</li><li>隔离性(Isolation):一个事务的执行不能被其他事务干扰.即一个事务内部的操作及使用的数据对并发的其他事务时隔离的,并发执行的各个事务之间不能互相干扰.</li><li>持久性(Durability):一个事务一旦被提交,它对数据库中数据的改变就是永久性的,接下来的其他操作和数据库故障不应该对其有任何影响</li></ol></li><li><p>使用</p><ul><li>事务的创建<ul><li>隐式事务:事务没有明显的开启和结束的标记<ul><li>INSERT</li><li>UPDATE</li><li>DELETE</li></ul></li><li>显示事务:事务具有明显的开启和结束的标记<ul><li>前体:必须先设置自动提交功能为禁用<pre><code>  步骤1:              SET           autocommit = 0      start          transaction; 可选,只要autocommit = 0 默认开启事务  步骤2:编写事务中的sql语句(SELECT,INSERT,UPDATE,DELETE)  步骤3:结束事务      commit;提交事务      rollback;回滚事务  SAVEPOINT 节点名;设置保存点</code></pre></li></ul></li></ul></li></ul></li><li><p>并发    </p><ul><li><p>并发问题</p><ul><li>脏读:对于两个事务T1,T2,T1读取了已经被T2更新但还没有被提交的字段之后,若T2回滚,T1 读取的内容就是临时且无效的。</li><li>不可重复读;对于两个事务T1,T2,T1读取了一个字段,然后T2更新了该字段之后,T1再次读取同一个字段,值就不同了</li><li>幻读:对于两个事务T1,T2,T1从一个表中读取了一个字段,然后T2再该表中插入了一些新的行之后,如果T1再次读取同一个表,就会多出几行</li></ul></li><li><p>事务隔离级别</p><ul><li>READ UNCOMMITTED:脏读、不可重复读、和幻读都不能阻止</li><li>READ COMMITED:能阻止脏读、不能阻止不可重复读、不能阻止幻读</li><li>REPEATABLE READ:能阻止脏读、不可重复读、不能阻止幻读</li><li>SERIALIZABLE:脏读、不可重复读、幻读都能阻止,效率较慢</li></ul></li><li><p>MYSQL 支持4种事务隔离级别.MYSQL默认的事务隔离级别 REPEATABLE READ;</p><h4 id="DELETE和TRUNCATE在事务使用时的区别"><a href="#DELETE和TRUNCATE在事务使用时的区别" class="headerlink" title="DELETE和TRUNCATE在事务使用时的区别"></a>DELETE和TRUNCATE在事务使用时的区别</h4></li></ul></li><li><p>DELETE ROLLBACK可以回滚</p></li><li><p>TRUNCATE ROLLBACK不可以回滚</p><pre><code>  SET autocommit = 0;  START TRANSACTION;    DELETE FROM account;  ROLLBACK;</code></pre></li></ul><h4 id="savepoint"><a href="#savepoint" class="headerlink" title="savepoint"></a>savepoint</h4><ul><li>回滚点</li></ul><ul><li>回滚点的使用<pre><code>  SET autocommit = 0;  START TANSACTION;  DELETE FROM       account WHERE id = 25;  SAVEPOINT a;//设置保存点  DELETE FROM account WHERE id = 28;  ROLLBACK TO a;  //回滚到25被删除28被保留的时候</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> transaction </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql Basic</title>
      <link href="2021/04/21/MySQL%E5%9F%BA%E7%A1%80/"/>
      <url>2021/04/21/MySQL%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h3 id="MySQL服务端的登陆和退出"><a href="#MySQL服务端的登陆和退出" class="headerlink" title="MySQL服务端的登陆和退出"></a>MySQL服务端的登陆和退出</h3><pre><code>方式一:通过mysql自带的客户端只限于root用户方式二:通过windows自带的客户端登陆:(如果有-h -P)就是另一台主机    mysql -h主机名 -P端口号 -u用户名 -p密码退出:exit</code></pre><h3 id="MYSQL的常见命令"><a href="#MYSQL的常见命令" class="headerlink" title="MYSQL的常见命令"></a>MYSQL的常见命令</h3><pre><code>1.查看当前所有的数据库SHOW databases;2.打开指定的库USE 库名3.查看当前库的所有表SHOW tables4.查看其它库的所有表SHOW tables FROM 库名5.创建表CREATE table 表名(    列名 列类型,    列名 列类型,    。。。    列名 列类型);6.查看表结构desc 表名;7.查看服务器的版本方法一:登陆到mysql服务端SELECT version();方法二:cmdmysql --version OR mysql -V</code></pre><h3 id="MYSQL语言规范"><a href="#MYSQL语言规范" class="headerlink" title="MYSQL语言规范"></a>MYSQL语言规范</h3><pre><code>1.不区分大小写,但建议关键字大写,表明、列名小写2.每条命令用分号结尾3.每条命令根据需要,可以进行缩进或换行4.注释    单行注释:# 注释文字    单行注释:- - 注释文字(空格)    多行注释:/* 注释文字 */</code></pre>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/04/21/hello-world/"/>
      <url>2021/04/21/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> inital </category>
          
      </categories>
      
      
        <tags>
            
            <tag> init </tag>
            
            <tag> hello </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
