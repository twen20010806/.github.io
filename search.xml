<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>leetcode刷题</title>
      <link href="2021/08/08/leetcode/"/>
      <url>2021/08/08/leetcode/</url>
      
        <content type="html"><![CDATA[<h1 id="data-2021-8-8"><a href="#data-2021-8-8" class="headerlink" title="data 2021-8-8"></a>data 2021-8-8</h1><h2 id="seq-1"><a href="#seq-1" class="headerlink" title="seq-1"></a>seq-1</h2><p><code>https://leetcode-cn.com/problems/two-sum/</code></p><blockquote><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p></blockquote><p>实例:</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h3><p>这道题可以用暴力法但是时间复杂度是O(n^2),显然不是我们想要的解法。那么我们该如何解呢?其实可以用<strong>hash表对数组进行映射</strong>,用经典的空间换时间的方法对事件复杂度进行优化。</p><p><code>我们第一使用循环将数组里面所有值都映射为value-index形式,再用第二次循环去map里找到target - nums[i]的数的index。此时会出现两个问题</code></p><ol><li>映射时如果出现重复的value该如何处理?</li></ol><blockquote><p>重复的value加起来等于target直接返回</p><p>不等于target覆盖也没关系</p></blockquote><ol start="2"><li>找index时该如何去除当前的nums[i]?</li></ol><blockquote><p>//因为前面去过重,所以当nums[i] * 2 = target时可以break;</p></blockquote><p>这里break的原因是map里没有重复的元素,nums[i] * 2重复时就相当于当前数需要重复才能得到target显然与题意不符</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="comment">//map映射 value,index</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; arrayMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//因为value可能会重复,所以需要判断</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length;i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arrayMap.containsKey(nums[i]))&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] * <span class="number">2</span> == target)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;arrayMap.get(nums[i]),i&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            arrayMap.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length;i ++)&#123;</span><br><span class="line">            <span class="keyword">int</span> needNum = target - nums[i];</span><br><span class="line">            <span class="comment">//因为前面去过重,所以相同直接返回</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] * <span class="number">2</span> == target)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从hashmap中获取数值</span></span><br><span class="line">            <span class="keyword">int</span> index = arrayMap.getOrDefault(needNum,-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//判断index是否存在</span></span><br><span class="line">            <span class="keyword">if</span>(index != -<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,index&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;匹配失败&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/leetcode/image-20210808184514679.png" alt="image-20210808184312997"></p><blockquote><p>效果不太理想,需要优化</p></blockquote><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>此处用了两个for循环,我们能否将其减少为一个呢?</p><p>答案是可以的,因为每次我们比较时都会和前面的值凑成的map比较,所以完全可以将其减少为一个map,而且上面的两个问题也将不复存在。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length;i ++)&#123;</span><br><span class="line">            <span class="keyword">int</span> needNum = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span>(arrayMap.containsKey(needNum))&#123;</span><br><span class="line">                <span class="comment">//如果key里包含needNum则返回答案</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;arrayMap.get(needNum),i&#125;;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//如果不包含则将当前数加入map</span></span><br><span class="line">                arrayMap.put(nums[i],i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/leetcode/image-20210808184531628.png"></p><h2 id="sque-2"><a href="#sque-2" class="headerlink" title="sque-2"></a>sque-2</h2><p><code>https://leetcode-cn.com/problems/reverse-integer/</code></p><blockquote><p>给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。</p><p>如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。</p><p>假设环境不允许存储 64 位整数（有符号或无符号）。</p></blockquote><p>实例:</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = -123</span><br><span class="line">输出：-321</span><br></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路:"></a>思路:</h3><p>这道题用%与/可以完成当然也可以使用左移或右移。</p><p>这题最重要的部分在于判断溢出,此题只有两处会有溢出。</p><ol><li>结果 * 10的时候</li><li>结果与mod相加的时候</li></ol><p>因此我们需要提前判断这两个地方是否溢出,请看代码怎么判断</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当x!=0时进入循环</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mod = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxValue = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> minValue = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//本次x还不为0,说明接下来还会对res进行加</span></span><br><span class="line">            <span class="comment">//得到最后一位数</span></span><br><span class="line">            mod = x % <span class="number">10</span>;</span><br><span class="line">            <span class="comment">//判断res是否已经达到了int最大值或最小值</span></span><br><span class="line">            <span class="keyword">if</span>( res &gt; maxValue / <span class="number">10</span> ||  res == maxValue / <span class="number">10</span> &amp;&amp; mod &gt; maxValue % <span class="number">10</span> ||</span><br><span class="line">            res &lt; minValue / <span class="number">10</span> || res == minValue / <span class="number">10</span> &amp;&amp; mod &lt; minValue % <span class="number">10</span> )&#123;</span><br><span class="line">                res = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将x左移一位</span></span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            res = res * <span class="number">10</span> + mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/leetcode/image-20210808204943285.png" alt="image-20210808204943285"></p>]]></content>
      
      
      <categories>
          
          <category> algorithem </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithem </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务解决方案 springcloud Alibaba</title>
      <link href="2021/08/08/springcloud-learn/"/>
      <url>2021/08/08/springcloud-learn/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> microserve </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springcloud </tag>
            
            <tag> backend </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集群状态管理-zookeeper</title>
      <link href="2021/08/08/zookeeper-learn/"/>
      <url>2021/08/08/zookeeper-learn/</url>
      
        <content type="html"><![CDATA[<h1 id="Zookeeper入门"><a href="#Zookeeper入门" class="headerlink" title="Zookeeper入门"></a>Zookeeper入门</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>Zookeeper是一个开源的,分布式的,为分布式框架提供协调服务的Apache项目</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/zookeeper/image-20210806140621124.png" alt="image-20210806140621124"></p><ul><li>Zookeeper从设计模式角度来理解:是一个基于<strong>观察者模式</strong>设计的<strong>分布式服务管理框架</strong>,它负责存储和管理大家都关心的数据,然后接受观察者的注册。一旦这些<strong>数据的状态发生变化</strong>,Zookeeper就将负责通知已经在Zookeeper上注册的哪些观察者做出相应的反映。<ul><li>Zookeeper=文件系统+通知机制</li><li>服务上线会在zookeeper中注册,服务器可以监听ZooKeeper里的配置文件,数据等</li><li>客户端请求时(观察者)会在zookeeper里面找寻项目</li></ul></li></ul><h2 id="Zookeeper的特点"><a href="#Zookeeper的特点" class="headerlink" title="Zookeeper的特点"></a>Zookeeper的特点</h2><ul><li>读写分离,守卫机制,数据冗余的高可用机制,数据更新原子性</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/zookeeper/image-20210806141202439.png" alt="image-20210806141202439"></p><ol><li><p>一个领导者(Leader),多个跟随着(Follower)组成的集群,Leader写,Followers读</p></li><li><p>集群中只要有<strong>半数以上</strong>节点存活,Zookeeper集群就能正常服务。所以Zookeeper适合安装奇数台服务器</p></li><li><p>全局数据一致:每个Server保存一份相同的数据副本,Client无论连接到哪个Server,数据都是一致的</p></li><li><p>更新请求顺序执行,来自同一个Client的更新请求按其发送顺序依次执行</p></li><li><p>数据更新原子性,一次数据更新要么成功,要么失败。每次操作都有事务id(zxid)</p></li><li><p>实时性,在一定时间范围内,Client能读到最新数据(Zookeeper需要同步数据)</p></li></ol><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul><li>ZooKeeper数据模型的结构与Unix文件系统很类似,整体上可以看作是一颗树,每个节点做一个Znode。每一个ZNode默认能够存储1MB的数据,每个ZNoed都可以通过其路径唯一标识。</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/zookeeper/image-20210806142107524.png" alt="image-20210806142107524"></p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>提供的服务包括:统一命名服务、统一配置管理、统一集群管理、服务器节点动态上下线、软负载均衡等。</li></ul><h3 id="统一命名服务"><a href="#统一命名服务" class="headerlink" title="统一命名服务"></a>统一命名服务</h3><ul><li>在分布式环境下,经常需要对应用/服务进行统一命名,便于识别</li><li>例如:IP不容易记住,而域名容易记住</li><li>Nginx的反向代理也可以做到</li><li>反向代理,负载均衡,高可用特点</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/zookeeper/image-20210806142828161.png" alt="image-20210806142828161"></p><h3 id="统一配置管理"><a href="#统一配置管理" class="headerlink" title="统一配置管理"></a>统一配置管理</h3><ol><li><p>分布式环境下,配置文件同步非常常见</p><ol><li>一半要求一个集群中,所有节点的配置信息是一致的,比如Kafka,rabbitmq集群</li><li>对配置文件修改后,希望能够快速同步到各个节点上</li></ol></li><li><p>配置管理可以由ZooKeeper实现</p><ol><li>课将配置信息写入ZooKeeper上的一个Znode</li><li>各个客户端服务器监听这个Znode</li><li>一旦Znode中配置文件发生修改,ZooKeeper将通知各个客户端服务器</li></ol><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/zookeeper/image-20210806143303799.png" alt="image-20210806143303799"></p></li></ol><h3 id="统一集群管理"><a href="#统一集群管理" class="headerlink" title="统一集群管理"></a>统一集群管理</h3><ol><li>分布式环境中,实时掌握每个节点的状态是必要的。<ol><li>可根据节点实时状态做出一些调整</li></ol></li><li>ZooKeeper可以实现实时监控节点状态变化<ol><li>可将节点信息写入ZooKeeper上的一个ZNode</li><li>监听这个ZNode课获取它的实时状态变化</li></ol></li></ol><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/zookeeper/image-20210806143537943.png" alt="image-20210806143537943"></p><h3 id="服务器动态上下线"><a href="#服务器动态上下线" class="headerlink" title="服务器动态上下线"></a>服务器动态上下线</h3><ul><li>客户端能够实时洞察到服务器上下限的变化</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/zookeeper/image-20210806143658429.png" alt="image-20210806143658429"></p><h3 id="软负载均衡"><a href="#软负载均衡" class="headerlink" title="软负载均衡"></a>软负载均衡</h3><ul><li>在Zookeeper中记录每台服务器的访问数,让访问数量最少的服务器去处理最新的客户端请求</li><li>Zookeeper会根据每个节点的访问数,动态调整访问的服务器</li></ul><h2 id="Zookeeper下载"><a href="#Zookeeper下载" class="headerlink" title="Zookeeper下载"></a>Zookeeper下载</h2><ul><li>官网网址:<a href="https://zookeeper.apache.org/">https://zookeeper.apache.org/</a></li><li>下载稳定3.5.7版本</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/zookeeper/image-20210806144139219.png" alt="image-20210806144139219"></p><h1 id="Zookeeper本地安装"><a href="#Zookeeper本地安装" class="headerlink" title="Zookeeper本地安装"></a>Zookeeper本地安装</h1><h2 id="本地模式安装"><a href="#本地模式安装" class="headerlink" title="本地模式安装"></a>本地模式安装</h2><p>安装前准备</p><ol><li>安装JDK</li><li>拷贝zookeeper安装包到Linux</li><li>解压到指定目录</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf apache-zookeeper-3.5.7-bin.tar.gz-C /opt/module/</span><br></pre></td></tr></table></figure><ol start="4"><li>修改名称</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv apache-zookeeper-3.5.7-bin/ zookeeper-3.5.7</span><br></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/zookeeper/image-20210806145409823.png" alt="image-20210806145409823"></p><ul><li><p>将/opt/module/zookeeper-3.5.7/conf这个路径下的zoo_sample.cfg改为zoo.cfg</p></li><li><p>打开zoo.cfg文件,修改dataDir路径,不能是/tmp路径,会被定期删除</p></li><li><p>参数解读</p><ol><li><p>tickTime=200:通信心跳时间,Zookeeper服务器与客户端,客户端与服务端心跳时间,单位毫秒。</p></li><li><p>initLimit=10:LF初始通信时限单位心跳次数,Leader和Follower初始连接能容忍的最多心跳数</p></li><li><p>syncLimit=5:LF同步通信时限单位心跳次数,Leader和Follower之间通信时间如果超过syncLimit*tickTime,Leader认为Follwer死掉,从服务器列表中删除Follwer</p></li><li><p>dataDir:保存Zookeeper中的数据</p><p>注意:默认的tmp目录.容易被Linux系统定期删除,所以一半不用默认的tmp目录。</p></li><li><p>clientPort=2181:客户端连接端口.通常不做修改</p></li></ol></li></ul><h2 id="操作Zookeeper"><a href="#操作Zookeeper" class="headerlink" title="操作Zookeeper"></a>操作Zookeeper</h2><ol><li>启动Zookeeper</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/zkServer.sh start</span><br></pre></td></tr></table></figure><ol start="2"><li>查看进程是否启动</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@twen-linux bin]<span class="comment"># jps </span></span><br><span class="line">3239 QuorumPeerMain</span><br><span class="line">3596 Jps</span><br><span class="line">[root@twen-linux bin]<span class="comment"># jps -l</span></span><br><span class="line">3239 org.apache.zookeeper.server.quorum.QuorumPeerMain</span><br><span class="line">3802 sun.tools.jps.Jps</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>查看状态</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@twen-linux bin]<span class="comment"># ./zkServer.sh status</span></span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/module/zookeeper-3.5.7/bin/../conf/zoo.cfg</span><br><span class="line">Client port found: 2181. Client address: localhost.</span><br><span class="line">Mode: standalone</span><br></pre></td></tr></table></figure><ol start="4"><li>启动客户端</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./zkCli.sh</span><br></pre></td></tr></table></figure><ol start="5"><li>退出客户端</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quit</span><br></pre></td></tr></table></figure><ol start="6"><li>停止Zookeeper</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;zkServer.sh stop</span><br></pre></td></tr></table></figure><h1 id="集群安装"><a href="#集群安装" class="headerlink" title="集群安装"></a>集群安装</h1><p><code>docke安装集群:3.4版本https://blog.csdn.net/zhangxinping165/article/details/107325942</code></p><p><code>3.5版本:https://blog.csdn.net/qq_37356556/article/details/104151047</code></p><h2 id="集群规划"><a href="#集群规划" class="headerlink" title="集群规划"></a>集群规划</h2><ul><li>集群至少三台机器</li></ul><h2 id="解压安装"><a href="#解压安装" class="headerlink" title="解压安装"></a>解压安装</h2><h2 id="配置服务器编号"><a href="#配置服务器编号" class="headerlink" title="配置服务器编号"></a>配置服务器编号</h2><ol><li>在/opt/module/zookeeper-3.5.7这个目录下创建zkData</li><li>在/opt/module/zookeeper-3.5.7/zkData目录下创建一个myid的文件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi myid</span><br></pre></td></tr></table></figure><p>​            在文件中添加与server对应的编号(上下不要有空行,左右不要有空格)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p>​        注意:添加myid文件,一定要在Linux里面创建,在notepad++里面很可能乱码</p><ol start="3"><li>拷贝配置好的zookeeper到其他机器上</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xsync zookeeper-3.5.7</span><br></pre></td></tr></table></figure><p>​        并分别在各虚拟机上修改myid文件中内容为3、4</p><h2 id="配置zoo-cfg文件"><a href="#配置zoo-cfg文件" class="headerlink" title="配置zoo.cfg文件"></a>配置zoo.cfg文件</h2><p>增加如下配置</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.2=vm101:2888:3888</span><br><span class="line">server.3=vm102:2888:3888</span><br><span class="line">server.4=vm103:2888:3888</span><br></pre></td></tr></table></figure><p>配置详解</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.A=B:C:D</span><br></pre></td></tr></table></figure><ul><li><p>A是一个数字,表示这个是第几号服务器</p><blockquote><p>集群模式下配置一个文件myid,这个文件在dataDir目录下,这个文件里面有一个数据就是A的值,Zookeeper启动时读取此文件,拿到里面的数据与zoo.cfg里面的配置信息比较从而判断到底是哪个server。</p></blockquote></li><li><p>B时这个服务器的地址</p></li><li><p>C是这个服务器Follower与集群中的Leader服务器交换信息的端口</p></li><li><p>D时万一集群中的Leader服务器挂了,需要一个端口来重新进行选举,选出一个新的Leader</p></li></ul><h2 id="Zookeeper的重要概念"><a href="#Zookeeper的重要概念" class="headerlink" title="Zookeeper的重要概念"></a>Zookeeper的重要概念</h2><h3 id="SID"><a href="#SID" class="headerlink" title="SID"></a>SID</h3><blockquote><p>服务器ID。用来唯一标识一台ZooKeeper集群中的机器,每台机器不能重复,和myid一致</p></blockquote><h3 id="ZXID"><a href="#ZXID" class="headerlink" title="ZXID"></a>ZXID</h3><blockquote><p>事务ID,ZXID是一个事务ID,用来标识一次服务器状态的变更。在某一时刻,集群中的每台机器的ZXID值不一定完全一致,这和ZooKeeper服务器对于客户端的”更新请求”的处理逻辑有关</p></blockquote><h3 id="Epoch"><a href="#Epoch" class="headerlink" title="Epoch"></a>Epoch</h3><blockquote><p>每个Leader任期的代号,没有Leader时同一轮投票过程中的逻辑时钟值时相同的。每投完一次票这个数据就会增加。</p></blockquote><h2 id="Zookeeper选举机制-第一次启动"><a href="#Zookeeper选举机制-第一次启动" class="headerlink" title="Zookeeper选举机制-第一次启动"></a>Zookeeper选举机制-第一次启动</h2><ol><li><p>服务器1启动发起一次选举,服务器1投自己一票,此时服务器1票数一票,不够半数以上(3票)，选举无法完成,服务器1状态保持为LOOKING</p></li><li><p>服务器2启动,再发起一次选举,服务器1和2分别投自己一票并交换选票信息；<strong>此时服务器1发现服务器2的myid比自己目前投票推举的(服务器1)大</strong>,更改选票为推举服务器2,此时服务器1票数0票,服务器2票数2票，没有半数以上结果,选举无法完成,服务器1,2状态保持LOOKING</p></li><li><p>服务器3启动,发起一次选举。此时服务器1和2都会更改选票为服务器3.此次投票结果，服务器1为0票,服务器2为0票，服务器3为3票。此时服务器3的票数已经超过半数。服务器3当选Leader。服务器1,2更改状态为FOLLOWING,服务器3更改状态为LEADING</p></li><li><p>服务器4启动,发起一次选举,此时服务器1,2,3已经不是LOOKING状态,不会更改选票信息。交换选票信息结果；服务器3为3票，服务器4为1票。此时服务器4服从多数,更改选票信息为服务器3，并更改状态为FOLLOWING.</p></li><li><p>服务器5启动,同4一样当小弟</p></li></ol><h2 id="Zookeeper选举机制-后续选举"><a href="#Zookeeper选举机制-后续选举" class="headerlink" title="Zookeeper选举机制-后续选举"></a>Zookeeper选举机制-后续选举</h2><ul><li>为什么会出现后续选举?</li></ul><blockquote><p>服务器运行期间无法和Leader保持连接。</p></blockquote><ul><li><p>当一台机器进入Leader选举流程时,当前集群也可能会处于以下两种状态</p><ol><li>集群中本来就已经存在一个Leader:同第一次选举后半段4、5,或者Leader重新连接</li></ol><blockquote><p>对于第一种已经存在Leader的情况,及其试图去选举Leader时,会被告知当前服务器的Leader信息,对于该机器来说,仅仅需要和Leader机器建立连接,并进行状态同步即可</p></blockquote><ol start="2"><li>集群中确实不存在Leader</li></ol><blockquote><p>假设Zookeeper由5台服务器组成,SID分别为1、2、3、4、5,ZXID分别为8、8、8、7、7,并且此时SID为3的服务器是Leader。某一时刻,3和5服务器出现故行,因此开始进行Leader选举</p></blockquote></li><li><p>选举如何进行</p></li></ul><blockquote><p>(Epoch,ZXID,SID):从左到右依次比较Epoch大的胜出,ZXID大的胜出,SID大的胜出</p></blockquote><h1 id="Zookeeper客户端命令行操作"><a href="#Zookeeper客户端命令行操作" class="headerlink" title="Zookeeper客户端命令行操作"></a>Zookeeper客户端命令行操作</h1><h2 id="节点信息"><a href="#节点信息" class="headerlink" title="节点信息"></a>节点信息</h2><ol><li>进入客户端</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zkCli.sh </span><br></pre></td></tr></table></figure><ol start="2"><li>进入集群中某一个zookeeper的客户端</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zkCli.sh -server [主机名(hadoop)/ip地址]:2181</span><br></pre></td></tr></table></figure><ol start="3"><li>ls [option]:查看节点</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 0] ls /</span><br><span class="line">[zookeeper]</span><br></pre></td></tr></table></figure><ol start="4"><li>ls -s /:查看具体信息</li></ol><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/zookeeper/image-20210807132139589.png" alt="image-20210807132139589"></p><p>​     参数详解:</p><ul><li>czxid:创建节点的事务zxid</li></ul><blockquote><p>每次修改ZooKeeper状态都会产生一个ZooKeeper事务ID。事务ID是ZooKeeper中所有修改的总次序。每次修改都会有唯一的zxid,如果zxid1小于zxid2,那么zxid1在zxid2之前发生。</p></blockquote><ul><li>ctim:znode被创建的毫秒数(从1970年开始)</li><li>mzxid:znode最后更新的事务zxid</li><li>mtime:znode最后修改的毫秒数(从1970年开始)</li><li>pZxid:znode最后更新的子节点zxid</li><li>cversion:znode子节点变化后,znode子节点修改的次数</li><li>dataversion:znode数据变化号</li><li>aclVersion:znode访问控制列表的变化号</li><li>ephemeralOwner:如果是临时节点,这个是znode拥有者的session id。如果不是临时节点则是0</li><li>dataLength:znode的数据长度</li><li>numChildren:zonode子节点的数量</li></ul><ol start="5"><li>create /节点名 值:创建一个永久节点不带序号</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create /node <span class="string">&quot;this is a node&quot;</span></span><br></pre></td></tr></table></figure><ol start="6"><li>get -s /节点名:获取节点的信息(包含值)</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get -s /node</span><br></pre></td></tr></table></figure><ol start="7"><li>create -s /节点名 值:创建一个永久节点带序号 -s </li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 13] create -s /sanguo/weiguo/zhangliao <span class="string">&quot;zhangliao&quot;</span></span><br><span class="line">Created /sanguo/weiguo/zhangliao0000000000</span><br></pre></td></tr></table></figure><ol start="8"><li>craete -e /节点名 值:创建一个临时节点带序号 -e -s</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 4] create -e -s /sanguo/wuguo <span class="string">&quot;zhouyu&quot;</span></span><br><span class="line">Created /sanguo/wuguo0000000003</span><br></pre></td></tr></table></figure><ol start="9"><li>修改节点对应的值</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 1] set &#x2F;sanguo&#x2F;weiguo &quot;simayi&quot;</span><br></pre></td></tr></table></figure><h2 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h2><blockquote><p>zookeeper节点类型分为持久/短暂/有序号/无序号</p></blockquote><p>持久节点(Persistent):客户端和服务器端断开连接后,创建的节点不删除</p><ol><li><p>持久化目录节点</p><p>客户端与Zookeeper断开连接后,该节点依旧存在</p></li><li><p>持久化顺序编号目录节点</p><p>客户端与Zookeeper断开连接后,该节点依旧存在,只是Zookeeper给该节点名称进行顺序编号</p><blockquote><p>说明:创建znode时设置顺序标识,znode名称后会附加一个值,顺序号是一个单调递增的计数器,由父节点维护,<strong>带序号的节点可以重复,不带序号的节点不能重复</strong></p></blockquote><p><code>注意:在分布式系统中,顺序号可以用于为所有的事件进行全局排序.这样客户端可以通过顺序号推断事件的顺序</code></p></li></ol><p>短暂(Ephemeral):客户端和服务器断开连接后,创建的节点自己删除</p><ol start="3"><li><p>临时目录节点</p><p>客户端与Zookeeper断开连接后,该节点被删除</p></li><li><p>临时顺序编号目录节点</p><p>客户端与Zookeeper断开连接后,该节点被删除,只是Zookeeper给该节点名称进行顺序编号</p></li></ol><h2 id="监听器操作"><a href="#监听器操作" class="headerlink" title="监听器操作"></a>监听器操作</h2><h3 id="监听原理详解"><a href="#监听原理详解" class="headerlink" title="监听原理详解"></a>监听原理详解</h3><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/zookeeper/image-20210807135716409.png" alt="image-20210807135716409"></p><ol><li>客户端首先要有一个main()线程</li><li>在main线程中创建Zookeeper客户端,这时就会创建两个线程,一个负责网络连接通信(connet),一个负责监听(listener)。</li><li>通过connect线程将注册的监听事件发送给Zookeeper。</li><li>在Zookeeper的注册监听器列表中将注册的监听事件添加到列表中。</li><li>Zookeeper见通道有数据或路径变化,就会将这个消息发送给listener线程</li><li>listener线程内部调用了process()方法。</li></ol><h3 id="常见的监听"><a href="#常见的监听" class="headerlink" title="常见的监听"></a>常见的监听</h3><ol><li>监听节点数据的变化</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get path[watch]</span><br></pre></td></tr></table></figure><ol start="2"><li>监听子节点增减的变化</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls path[watch]</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol><li><strong>节点的值变化监听</strong>在zkCli里面使用get -w path</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get -w &#x2F;node</span><br></pre></td></tr></table></figure><p><code>注意:监听一次,只能获得一次监听的结果</code></p><ol start="2"><li><strong>节点的子节点变化监听</strong>(路径变化)</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -w /node</span><br></pre></td></tr></table></figure><p><code>注意:监听一次,只能获得一次监听结果</code></p><h2 id="节点删除与查看"><a href="#节点删除与查看" class="headerlink" title="节点删除与查看"></a>节点删除与查看</h2><ol><li>删除节点</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete /node</span><br></pre></td></tr></table></figure><ol start="2"><li>递归删除节点</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deleteall /node</span><br></pre></td></tr></table></figure><ol start="3"><li>查看节点状态</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stat</span> /node</span><br></pre></td></tr></table></figure><h1 id="客户端API操作"><a href="#客户端API操作" class="headerlink" title="客户端API操作"></a>客户端API操作</h1><p><code>前提:保证服务器上的Zookeeeper集群服务端启动</code></p><h2 id="创建环境"><a href="#创建环境" class="headerlink" title="创建环境"></a>创建环境</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.apache.zookeeper&#x2F;zookeeper --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.zookeeper&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;zookeeper&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;3.5.7&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="获取连接"><a href="#获取连接" class="headerlink" title="获取连接"></a>获取连接</h2><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/zookeeper/image-20210807152329482.png" alt="image-20210807152329482"></p><blockquote><p>使用命令前先要获取连接</p></blockquote><p>参数详解:</p><ul><li>connectString:连接哪个主机</li><li>sessionTimeout:连接实现</li><li>watcher:监听器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//逗号间不能有空格,这里将ip进行了本地映射myVm = 192.168.200.130</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String connectString = <span class="string">&quot;myVm:2181,myVm:2182,myVm:2183&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> sessionTimout = <span class="number">2000</span>;</span><br><span class="line"><span class="keyword">private</span> ZooKeeper zkClient;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">  zkClient = <span class="keyword">new</span> ZooKeeper(connectString, sessionTimout, WatchedEvent -&gt; &#123;</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建子节点"><a href="#创建子节点" class="headerlink" title="创建子节点"></a>创建子节点</h2><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/zookeeper/image-20210807154208051.png" alt="image-20210807154208051"></p><blockquote><p>得到连接之后,使用Zookeeper.create()</p></blockquote><p>参数详解:</p><ul><li><p>path:创建node的路径</p></li><li><p>data:参数</p></li><li><p>acl:访问控制,可以使用枚举类Ids</p></li><li><p>createMode:节点模式(持久,不持久),使用CreateMode枚举类</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, KeeperException </span>&#123;</span><br><span class="line">    zkClient.create(<span class="string">&quot;/atuguigu&quot;</span>, </span><br><span class="line">                    <span class="string">&quot;ss.avi&quot;</span>.getBytes(StandardCharsets.UTF_8), </span><br><span class="line">                    ZooDefs.Ids.OPEN_ACL_UNSAFE, </span><br><span class="line">                    CreateMode.PERSISTENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取子节点并监听节点路径变化"><a href="#获取子节点并监听节点路径变化" class="headerlink" title="获取子节点并监听节点路径变化"></a>获取子节点并监听节点路径变化</h2><p><code>要实现监听数据,需要在创建连接时的WatchedEvent里面设置</code></p><ul><li>获取子节点</li></ul><blockquote><p>使用Zookeeper.getChildren</p></blockquote><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/zookeeper/image-20210807155550056.png" alt="image-20210807155550056"></p><p>参数详解:</p><ul><li>path:监听哪个路径</li><li>watch:<ul><li>如果时boolean,则执行创建时的watchedEvent,猜测如果为false则不进行监听,如果为true监听,但只进行一次</li><li>如果是Watcher则自定义</li></ul></li></ul><p>多次监听代码:</p><ol><li>使程序不结束,休眠进程</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getChildren</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, KeeperException </span>&#123;</span><br><span class="line">    <span class="comment">//getData可以获取数据</span></span><br><span class="line">    List&lt;String&gt; children = zkClient.getChildren(<span class="string">&quot;/&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">for</span> (String child : children) &#123;</span><br><span class="line">        System.out.println(child);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line">    <span class="comment">//延时让其不结束</span></span><br><span class="line">    Thread.sleep(Long.MAX_VALUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在注册的WatcherEvent事件里面添加新的监听</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">zkClient = <span class="keyword">new</span> ZooKeeper(connectString, sessionTimout, WatchedEvent -&gt; &#123;</span><br><span class="line"></span><br><span class="line">      List&lt;String&gt; children = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=========================&quot;</span>);</span><br><span class="line">        children = zkClient.getChildren(<span class="string">&quot;/&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">for</span> (String child : children) &#123;</span><br><span class="line">          System.out.println(child);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;=========================&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h2 id="判断节点是否存在"><a href="#判断节点是否存在" class="headerlink" title="判断节点是否存在"></a>判断节点是否存在</h2><blockquote><p>使用Zookeeper.exists(path,watch)</p></blockquote><ul><li><p>path:监听的节点</p></li><li><p>watch:是否监听</p></li><li><p>返回值为stat</p><ul><li>目标存在Stat对象有</li><li>不存在Stat为null</li></ul></li></ul><h2 id="客户端向服务端写数据流程"><a href="#客户端向服务端写数据流程" class="headerlink" title="客户端向服务端写数据流程"></a>客户端向服务端写数据流程</h2><h3 id="写流程之写入请求直接发送给Leader节点"><a href="#写流程之写入请求直接发送给Leader节点" class="headerlink" title="写流程之写入请求直接发送给Leader节点"></a>写流程之写入请求直接发送给Leader节点</h3><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/zookeeper/image-20210807163140349.png" alt="image-20210807163140349"></p><ol><li>client写入数据</li><li>Leader写完之后通知从机写入</li><li>从机写完ack</li><li><strong>从机加Leader满足半数以上的server写完就会向客户端client发送ack</strong></li><li>向client客户端ack完毕之后Leader会通知其他从机写</li></ol><p><code>好处:效率高</code></p><h3 id="写流程之写入请求发送给follower节点"><a href="#写流程之写入请求发送给follower节点" class="headerlink" title="写流程之写入请求发送给follower节点"></a>写流程之写入请求发送给follower节点</h3><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/zookeeper/image-20210807163024870.png" alt="image-20210807163024870"></p><ol><li>follower接收到写请求转给Leader</li><li>之后过程与直接请求Leader差不多,<strong>首先同步写的是转发的Fllower</strong></li><li><strong>差别在于这种方式回复ack client的是被请求的Follower</strong></li></ol><blockquote><p>两种方式差别之一是回复应答的是Leader还是Follower</p></blockquote><h1 id="服务器动态上线先监听"><a href="#服务器动态上线先监听" class="headerlink" title="服务器动态上线先监听"></a>服务器动态上线先监听</h1><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/zookeeper/image-20210807164352396.png" alt="image-20210807164352396"></p><h2 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h2><ol><li>Zookeeper里面没有服务器与客户端概念,对于Zookeeper来说都只是节点,只不过服务器是创建节点,客户端时监听节点(经典加一层)。</li><li>自我理解:Zookeeper相当与一个容器,服务器上线就加入这个容器(临时节点),下线就退出。客户端就在这个容器里面监听服务器列表,有服务的就去请求,没有就不去请求。</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="服务器部分"><a href="#服务器部分" class="headerlink" title="服务器部分"></a>服务器部分</h3><blockquote><p>服务器部分着重于create</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> DistributeServer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> twen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/8/7 16:49</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributeServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String connectString = <span class="string">&quot;myVm:2181,myVm:2182,myVm:2183&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> sessiontTimeout = <span class="number">2000</span>;</span><br><span class="line">  <span class="keyword">private</span> ZooKeeper zooKeeper;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException, KeeperException </span>&#123;</span><br><span class="line">    DistributeServer distributeServer = <span class="keyword">new</span> DistributeServer();</span><br><span class="line">    <span class="comment">//1 获取zk连接</span></span><br><span class="line">    distributeServer.getConnect();</span><br><span class="line">    <span class="comment">//2.注册服务器到zk集群</span></span><br><span class="line">    distributeServer.regist(args[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">//3.启动业务逻辑(睡觉)睡10秒</span></span><br><span class="line">    distributeServer.business();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">business</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//睡10秒</span></span><br><span class="line">    Thread.sleep(Long.MAX_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">regist</span><span class="params">(String hostname)</span> <span class="keyword">throws</span> InterruptedException, KeeperException </span>&#123;</span><br><span class="line">    <span class="comment">//临时节点带序号</span></span><br><span class="line">    <span class="keyword">this</span>.zooKeeper.create(<span class="string">&quot;/servers/&quot;</span>+hostname,</span><br><span class="line">      hostname.getBytes(StandardCharsets.UTF_8),</span><br><span class="line">      ZooDefs.Ids.OPEN_ACL_UNSAFE,</span><br><span class="line">      CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">    System.out.println(hostname+<span class="string">&quot; is online&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getConnect</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.zooKeeper = <span class="keyword">new</span> ZooKeeper(<span class="keyword">this</span>.connectString, <span class="keyword">this</span>.sessiontTimeout, watchedEvent -&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端部分"><a href="#客户端部分" class="headerlink" title="客户端部分"></a>客户端部分</h3><blockquote><p>客户端部分着重于watcher</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> DistributeServer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> twen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/8/7 16:49</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributeServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String connectString = <span class="string">&quot;myVm:2181,myVm:2182,myVm:2183&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> sessiontTimeout = <span class="number">2000</span>;</span><br><span class="line">  <span class="keyword">private</span> ZooKeeper zooKeeper;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException, KeeperException </span>&#123;</span><br><span class="line">    DistributeServer distributeServer = <span class="keyword">new</span> DistributeServer();</span><br><span class="line">    <span class="comment">//1 获取zk连接</span></span><br><span class="line">    distributeServer.getConnect();</span><br><span class="line">    <span class="comment">//2.注册服务器到zk集群</span></span><br><span class="line">    distributeServer.regist(args[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">//3.启动业务逻辑(睡觉)睡10秒</span></span><br><span class="line">    distributeServer.business();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">business</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//睡10秒</span></span><br><span class="line">    Thread.sleep(Long.MAX_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">regist</span><span class="params">(String hostname)</span> <span class="keyword">throws</span> InterruptedException, KeeperException </span>&#123;</span><br><span class="line">    <span class="comment">//临时节点带序号</span></span><br><span class="line">    <span class="keyword">this</span>.zooKeeper.create(<span class="string">&quot;/servers/&quot;</span>+hostname,</span><br><span class="line">      hostname.getBytes(StandardCharsets.UTF_8),</span><br><span class="line">      ZooDefs.Ids.OPEN_ACL_UNSAFE,</span><br><span class="line">      CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">    System.out.println(hostname+<span class="string">&quot; is online&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getConnect</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.zooKeeper = <span class="keyword">new</span> ZooKeeper(<span class="keyword">this</span>.connectString, <span class="keyword">this</span>.sessiontTimeout, watchedEvent -&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ZooKeeper分布式锁"><a href="#ZooKeeper分布式锁" class="headerlink" title="ZooKeeper分布式锁"></a>ZooKeeper分布式锁</h1><h2 id="分布式锁概念"><a href="#分布式锁概念" class="headerlink" title="分布式锁概念"></a>分布式锁概念</h2><p>在进程1使用该资源时,会先去获得锁,进程1获得锁以后会对该资源保持独占,这样其他进程就无法访问该资源,进程1用完该资源以后就会将锁释放,让其他进程来获得锁,那么通过这个锁机制,我们就能保证分布式系统中多个进程能够有序的访问该临界资源。</p><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/zookeeper/image-20210807175500275.png" alt="image-20210807175500275"></p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><blockquote><p>思路</p></blockquote><ol><li>获取连接之后进入/locks目录,判断该目录是否存在</li><li>如果不存在创建目录再创建一个带序号的lock</li><li>获取/locks目录下的所有节点并且将其排序</li><li>判断当前lock是否为第一位</li><li>如果为第一位则当前业务立即执行</li><li>如果不为第一位则监听前一个锁直至执行</li></ol><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> DistributeLock</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> twen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/8/7 18:17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributeLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//逗号间不能有空格,这里将ip进行了本地映射myVm = 192.168.200.130</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String connectString = <span class="string">&quot;myVm:2181,myVm:2182,myVm:2183&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> sessionTimout = <span class="number">2000</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ZooKeeper zooKeeper;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String waitPath;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> CountDownLatch waitLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">private</span> String currentNode;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DistributeLock</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException, KeeperException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取连接</span></span><br><span class="line">    zooKeeper = <span class="keyword">new</span> ZooKeeper(connectString, sessionTimout, watchedEvent -&gt; &#123;</span><br><span class="line">      <span class="comment">//countDownLatch 如果连接上zookeeper可以释放,如果状态是同步</span></span><br><span class="line">      <span class="keyword">if</span> (watchedEvent.getState() == Watcher.Event.KeeperState.SyncConnected)&#123;</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(watchedEvent.getType() == Watcher.Event.EventType.NodeDeleted &amp;&amp; watchedEvent.getPath().equals(waitPath))&#123;</span><br><span class="line">        waitLatch.countDown();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//判断根节点/locks是否存在</span></span><br><span class="line">    <span class="comment">//等待zk正常连接后,往下走</span></span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    Stat stat = zooKeeper.exists(<span class="string">&quot;/locks&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span>(stat == <span class="keyword">null</span>)&#123;</span><br><span class="line">      zooKeeper.create(<span class="string">&quot;/locks&quot;</span>,</span><br><span class="line">        <span class="string">&quot;locks&quot;</span>.getBytes(StandardCharsets.UTF_8),</span><br><span class="line">        ZooDefs.Ids.OPEN_ACL_UNSAFE,</span><br><span class="line">        CreateMode.PERSISTENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//对zk加锁</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zkLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, KeeperException </span>&#123;</span><br><span class="line">    <span class="comment">//创建对应的临时带序号的节点,create返回值返回的是path</span></span><br><span class="line">    currentNode = zooKeeper.create(<span class="string">&quot;/locks/&quot;</span> + <span class="string">&quot;seq-&quot;</span>, <span class="keyword">null</span>, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">    <span class="comment">//判断创建的节点是否时最小的序号节点,如果是,获取到锁,如果不是,监听序号前一个节点</span></span><br><span class="line">    List&lt;String&gt; children = zooKeeper.getChildren(<span class="string">&quot;/locks&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">//如果children只有一个值,直接获取锁,如果有多个节点,需要判断谁最小</span></span><br><span class="line">    <span class="keyword">if</span>(children.size() == <span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//排序</span></span><br><span class="line">      Collections.sort(children);</span><br><span class="line">      <span class="comment">//获取节点名称 seq-xxxxxxx</span></span><br><span class="line">      String substring = currentNode.substring(<span class="string">&quot;/locks/&quot;</span>.length());</span><br><span class="line">      <span class="comment">//通过seq-xxxxxxx</span></span><br><span class="line">      <span class="keyword">int</span> index = children.indexOf(substring);</span><br><span class="line">      <span class="comment">//判断</span></span><br><span class="line">      <span class="keyword">if</span>(index == -<span class="number">1</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;数据异常&quot;</span>);</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(index == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//就一个节点,可以获取锁了</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//需要监听前一个节点</span></span><br><span class="line">        waitPath = <span class="string">&quot;/locks/&quot;</span>+children.get(index - <span class="number">1</span>);</span><br><span class="line">        zooKeeper.getData(waitPath, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">        waitLatch.await();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//解锁</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unZkLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, KeeperException </span>&#123;</span><br><span class="line">    <span class="comment">//删除节点</span></span><br><span class="line">    zooKeeper.delete(currentNode, -<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Curator框架实现分布式锁"><a href="#Curator框架实现分布式锁" class="headerlink" title="Curator框架实现分布式锁"></a>Curator框架实现分布式锁</h2><ol><li><p>原生Java API开发存在的问题</p><ol><li>会话连接是异步的,需要自己去处理。比如使用CountDownLatch</li><li>Watch需要重复注册.不然就不能生效</li><li>开发的复杂性还是比较高的</li><li>不支持多节点删除和创建。需要自己去递归。</li></ol></li><li><p>Curator是一个专门解决分布式锁的框架,解决了原生JavaAPI开发分布式遇到的问题</p><p><code>官方文档:https://curator.apache.org/index.html</code></p></li><li><p>Curator案例实操</p><ol><li>添加依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.curator/curator-recipes --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.curator/curator-client --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>编码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> CuratorLockTest</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> twen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/8/7 19:41</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorLockTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建分布式锁1</span></span><br><span class="line">    InterProcessMutex lock1 = <span class="keyword">new</span> InterProcessMutex(getCuratorFramework(), <span class="string">&quot;/locks&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建分布式锁2</span></span><br><span class="line">    InterProcessMutex lock2 = <span class="keyword">new</span> InterProcessMutex(getCuratorFramework(), <span class="string">&quot;/locks&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        lock1.acquire();</span><br><span class="line">        System.out.println(<span class="string">&quot;thread 1 get the lock&quot;</span>);</span><br><span class="line">        lock1.acquire();</span><br><span class="line">        System.out.println(<span class="string">&quot;thread 1 get the lock again&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">        lock1.release();</span><br><span class="line">        System.out.println(<span class="string">&quot;thread 1 release the lock&quot;</span>);</span><br><span class="line">        lock1.release();</span><br><span class="line">        System.out.println(<span class="string">&quot;thread 1 release the lock again&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        lock2.acquire();</span><br><span class="line">        System.out.println(<span class="string">&quot;thread 2 get the lock&quot;</span>);</span><br><span class="line">        lock2.acquire();;</span><br><span class="line">        System.out.println(<span class="string">&quot;thread 2 get the lock again&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">        lock2.release();</span><br><span class="line">        System.out.println(<span class="string">&quot;thread 2 release the lock&quot;</span>);</span><br><span class="line">        lock2.release();</span><br><span class="line">        System.out.println(<span class="string">&quot;thread 2 release the lock again&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> CuratorFramework <span class="title">getCuratorFramework</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CuratorFramework client = CuratorFrameworkFactory</span><br><span class="line">      .builder()</span><br><span class="line">      .connectString(<span class="string">&quot;myVm:2181,myVm:2182,myVm:2183&quot;</span>)</span><br><span class="line">      .connectionTimeoutMs(<span class="number">20000</span>)</span><br><span class="line">      .sessionTimeoutMs(<span class="number">20000</span>)</span><br><span class="line">      .retryPolicy(<span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">3000</span>, <span class="number">3</span>))</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">    client.start();</span><br><span class="line">    System.out.println(<span class="string">&quot;Zookeeper启动成功&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> client;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="企业面试真题"><a href="#企业面试真题" class="headerlink" title="企业面试真题"></a>企业面试真题</h1><h2 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h2><p>半数机制,超过半数的投票通过</p><ol><li><p>第一次启动选举规则</p><p><code>投票过半数时,服务器id大的胜出</code></p></li><li><p>第二次启动选举规则</p><ol><li>EPOCH大的直接胜出</li><li>EPOCH相同,zxid(事务id)大的胜出</li><li>事务id相同,服务器id大的胜出</li></ol></li></ol><h2 id="生产集群安装多少zk合适"><a href="#生产集群安装多少zk合适" class="headerlink" title="生产集群安装多少zk合适?"></a>生产集群安装多少zk合适?</h2><p>安装奇数台</p><p><code>生产经验</code></p><ul><li>10台服务器:3台zk</li><li>20台服务器:5台zk</li><li>100 台服务器:11台zk</li><li>200台服务器:11台zk</li></ul><p><code>服务器台数多:好处,提高可靠性;坏处:提高通信延迟</code></p></li></ol><h1 id="Zookeeper-源码分析"><a href="#Zookeeper-源码分析" class="headerlink" title="Zookeeper(源码分析)"></a>Zookeeper(源码分析)</h1><h2 id="算法基础"><a href="#算法基础" class="headerlink" title="算法基础"></a>算法基础</h2><blockquote><p>拜占庭将军问题</p></blockquote><p>拜占庭将军问题是一个协议问题,拜占庭帝国军队的将军们必须全体一致的决定是否攻击某一支敌军。问题是这些将军再地理上时分隔开来的,并且将军中存在叛徒。叛徒可以任意行动以达以下目标:**欺骗某些将军采取进攻行动;促成一个不是所有将军都统一的决定,如当将军们不希望进攻时促成进攻行动;或者迷惑某些将军.是他们无法做出决定。如果叛徒达到了这些目的之一,则任何攻击行动的结果都是注定要失败的,只有完全一致的努力才能获得胜利。</p><h2 id="Paxos算法"><a href="#Paxos算法" class="headerlink" title="Paxos算法"></a>Paxos算法</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>​    Paxos算法:一种基于消息传递且具有高度容错特性的一致性算法。</p><p>​    Paxos算法解决的问题:就是如何快速正确的在一个分布式系统中对某个数据置达成一致,并且保证不能发生任何异常都不会破坏整个系统的一致性。</p><p>​    在一个Paxos系统中,首先所有节点划分为Proposer(提议者),Acceptor(接收者),和Learner(学习者)。(每个节点可以身兼数职)</p><p>​    一个完整的Paxos算分流程分为三个阶段</p><pre><code> 1. Prepare准备阶段  * proposer向多个Acceptor发除Propose请求Promise  * Acceptor针对收到的Propose请求进行Promise 2. Accept接受阶段 * Proposer收到多数Acceptor承诺的Promise后,向Aceeptor发出Propose请求 * Acceptor针对收到的Propose请求进行Accept处理 3. Learn学习阶段:Proposer将形成的决议发送给所有的Learners</code></pre><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>Prepare:Proposer生成全局唯一且递增的Proposal ID,向所有Acceptor发送Propose请求,这里无需携带提案内容,只携带Proposal ID即可。</li><li>Promise:Acceptor收到Propose请求后,做出“两个承诺,一个应答”<ol><li>不再接受Proposal ID小于等于(&lt;=)当前请求的Propose请求</li><li>不再接受Propossal ID小于(&lt;)当前请求的Accept请求</li><li>不违背以前做出的承诺下,回复已经Accept过的填中Proposal ID最大的哪个提案的Value和Proposal ID，没有则返回控制</li></ol></li><li>Propose:Proposer收到多数Acceptor的Promise应答后,从应答中选择Proposal ID最大的提案的Valule,作为本次要发起的提案。如果所有应答的提案Value均为控制,则可以自己随意决定提案Value。然后携带当前Proposal ID,向所有Acceptor发送Propose请求。</li><li>Accept:Acceptro收到Propose请求后,在不违背自己之前做出的承诺下,接受并持久化当前Proposal ID和提案Value。</li><li>Learn:Proposer收到多数Acceptor的Accept后,决议形成,将形成的决议发送给所有Learner</li></ol><h3 id="Paxos算法缺陷"><a href="#Paxos算法缺陷" class="headerlink" title="Paxos算法缺陷"></a>Paxos算法缺陷</h3><p>​    当系统中有一个以上的Proposer,多个Proposers相互争夺Acceptor,造成迟迟无法达成一致的情况。针对这种情况,一种改进的Paxos算法提出:从系统中选出一个节点作为Leader,只有Leader能够发起提案。这样,一次Paxos流程中只有一个Proposer,不会出现活锁的情况,此时只会出现例子中第一种情况。</p><h2 id="ZAB协议"><a href="#ZAB协议" class="headerlink" title="ZAB协议"></a>ZAB协议</h2><p>​    Zab借鉴了Paxos算法,是特别为Zookeeper设计的支持崩溃恢复的原子广播协议。基于该协议,Zookeeper设计为只有一台客户端(Leader)负责处理外部的写事务请求,然后Leader客户端安静数据同步到其他Follower节点。即Zookeeper只有一个Leader可以发起提案。</p><h3 id="Zab协议内容"><a href="#Zab协议内容" class="headerlink" title="Zab协议内容"></a>Zab协议内容</h3><p>​    Zab协议包括两种基本的模式:消息广播、崩溃恢复。</p><h3 id="Zab流程"><a href="#Zab流程" class="headerlink" title="Zab流程"></a>Zab流程</h3><ol><li>客户端发起一个写操作请求。</li><li>Leader服务器将客户端的请求转化为事务PRoposal提案,同时为每个Proposal分配一个全局ID,即zxid</li><li>Leader服务器为每个Follower服务器分配一个单独的队列,然后将需要广播的Proposal依次放到队列中去,并且根据FIFO策略进行消息发送。</li><li>Follower接收到Proposal后会首先将器以事务日志的方式写入本地磁盘中,写入成功后反馈要给Ack响应消息。</li><li>Leader接收到超过半数以上Follower的Ack响应消息后,即认为消息发送成功,可以发送commit消息</li><li>Leader向所有Follower广播commit消息,同时自身也会完成事务提交。Follower节后苏到commit消息后,会将上一条事务提交。</li><li>Zookeeper采用Zab协议的核心,就是只要有一台服务器提交Proposal,就要确保所有的服务器最终都能正确提交Proposal。</li></ol><blockquote><p>ZAB协议针对事务请求的处理过程类似于一个两阶段提交过程</p></blockquote><ol><li>广播事务阶段</li><li>广播提交操作</li></ol><blockquote><p>这两阶段提交模型如下,有可能因为Leader宕机带来数据不一致,比如</p></blockquote><ol><li>Leader发起一个事务Proposal1后就宕机,Follower都没有Proposal1</li><li>Leader收到半数ACK宕机,没来得及向Follower发送commit</li></ol><h3 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h3><p><code>一旦Leader服务器出现崩溃或者由于网络原因导致Leader服务器失去了与过半Follower的联系,那么就会进入崩溃恢复模式。</code></p><ol><li>假设两种服务器异常情况’<ol><li>假设一个事务在Leader提出之后,Leader挂了</li><li>一个事务在Leader上提交了,并且过半的Follower都响应Ack了,但是Leader在Commit消息发除之前挂了</li></ol></li><li>Zab协议崩溃恢复要求满足以下两个要求<ol><li>确保已经被Leader提交的提案Proposal,必须最终被所有的Follower服务器提交。(<strong>已经产生的提案,Follower必须执行</strong>)</li><li>确保丢弃已经被Leader提出的,但是没有被提交的Proposal。(<strong>丢弃胎死腹中的提案</strong>)</li></ol></li></ol><p>崩溃恢复主要包括两部分:<strong>Leader</strong>选举和<strong>数据恢复</strong></p><blockquote><p>Leader选举</p></blockquote><ol><li>新选举出来的Leader不能包含未提交的Proposal。即新Leader必须都是已经提交了Proposal额Follower服务器节点</li><li>新选举的Leader节点中含有最大的zxid,这样做的好处是可以避免Leader服务器检查proposal的提交和丢弃工作。</li></ol><blockquote><p>数据恢复</p></blockquote><ol><li><strong>完成Leader选举后</strong>,在正式开始工作之前(接收事务请求,然后提出新的Proposal),<strong>Leader服务器会首先确认事务日志中的所有Proposal是否已经被集群中过半的服务器Commit</strong></li><li>Leader服务器需要确保所有Follower服务能够接收到每一条事务的Proposal,并且能将所有已经提交的事务Proposal应用到内存数据中。等到Follower将所有尚未同步的事务Proposal都从Leader服务器上同步过,并且应用到内存数据中以后,Leader才会把该Follower加入到真正可用的Follower列表中</li></ol><h3 id="Zookeeper的CAP"><a href="#Zookeeper的CAP" class="headerlink" title="Zookeeper的CAP"></a>Zookeeper的CAP</h3><ol><li>ZooKeeper不能保证每次服务请求的可用性。(在极端环境下,ZooKeeper可能会丢弃一些请求,消费者程序需要重新请求才能获得结果)。所以说,ZooKeeper<strong>不能保证服务可用性</strong>。</li><li>进行Leader<strong>选举时集群都是不可用</strong>。</li></ol><h1 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h1><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/zookeeper/image-20210808155117678.png" alt="image-20210808155117678"></p><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/zookeeper/image-20210808161742268.png" alt="image-20210808161742268"></p><blockquote><p>后续源码未完待续</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> middleware </category>
          
          <category> microserve </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列-rabbitmq</title>
      <link href="2021/08/04/rabbitmq-learn/"/>
      <url>2021/08/04/rabbitmq-learn/</url>
      
        <content type="html"><![CDATA[<h1 id="MQ简介"><a href="#MQ简介" class="headerlink" title="MQ简介"></a>MQ简介</h1><h2 id="什么是MQ"><a href="#什么是MQ" class="headerlink" title="什么是MQ"></a>什么是MQ</h2><ul><li>MQ本质是个队列,FIFO先进先出,只不过队列中存放的内容是message而已,还是一种跨进程的通信机制,用于上下游传递消息。在互联网架构中,MQ是一种非常常见的”逻辑解耦+物理解耦”的消息通信服务。使用了MQ之后,消息发送上游只需要依赖MQ，不用依赖其他服务</li></ul><h2 id="为什么使用MQ"><a href="#为什么使用MQ" class="headerlink" title="为什么使用MQ"></a>为什么使用MQ</h2><ol><li><p>流量消峰</p><ul><li>对访问的人员进行排队,而达到消峰的目的,高峰期访问人数超过系统处理极限,需要mq对其进行queue,保护系统放置其宕机</li></ul></li><li><p>应用解耦</p><ul><li>没有mq订单系统直接调用三大系统,如果一个系统出现问题则会导致服务不可用</li><li>使用了mq则可以对其进行排队,用户可以继续使用服务,但是请求会被存储在队列里,待服务修复之后再处理</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210731131049672.png" alt="image-20210731131049672"></p></li><li><p>异步处理</p><ul><li>如果一项操作需要很长时间,A-&gt;B,A需要与B单独进行会话,做法不够优雅且A需要持续监听B的完成情况,浪费资源</li><li>此时引入消息总线机制mq接收到B服务完成消息转发给A,A就不用持续监听B的完成情况。</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210731131633148.png" alt="image-20210731131633148"></p></li></ol><h2 id="MQ的分类"><a href="#MQ的分类" class="headerlink" title="MQ的分类"></a>MQ的分类</h2><ul><li><p>ActiveMQ</p><ul><li>比较古老</li><li>优点:单机吞吐量万级,时效性ms级,可用性高,基于主从架构实现高可用性,消息可靠性高</li><li>缺点:官方社区对ActiveMQ 5.x维护越来越少,高吞吐量场景较少使用。</li></ul></li><li><p>Kafka</p><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210731132104762.png" alt="image-20210731132104762"></p></li><li><p>RocketMQ</p><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210731132346791.png" alt="image-20210731132346791"></p></li><li><p>RabbitMq</p><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210731132500572.png" alt="image-20210731132500572"></p></li></ul><h2 id="MQ的选择"><a href="#MQ的选择" class="headerlink" title="MQ的选择"></a>MQ的选择</h2><ul><li>kafka:大型公司建议选用,如果有日志采集功能首选kafka</li><li>RocketMQ:天生为<strong>金融互联网</strong>领域而生,RoketMQ再稳定性上可能更值得信赖</li><li>RabbitMQ:结合erlang语言本身的并发优势,性能好时效性能微妙级,社区活跃度也比较高,管理界面用起来十分方便,如果数据量没有那么大,中小型公司优先选择功能比较完备的RabbitMQ</li></ul><h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>RabbitMQ是一个消息中间件,它接受并转发消息。RabbitMQ接收,存储和转发消息数据</li></ul><h2 id="四大核心概念"><a href="#四大核心概念" class="headerlink" title="四大核心概念"></a>四大核心概念</h2><ol><li>生产者</li><li>交换机</li><li>队列</li><li>消费者</li></ol><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210731155648739.png" alt="image-20210731155648739"></p><h2 id="RabbitMQ核心部分"><a href="#RabbitMQ核心部分" class="headerlink" title="RabbitMQ核心部分"></a>RabbitMQ核心部分</h2><ol><li>Hello World</li><li>Work queues</li><li>Publish/Subscribe</li><li>Routing</li><li>Topics</li><li>Publisher Confirms</li></ol><h2 id="名词介绍"><a href="#名词介绍" class="headerlink" title="名词介绍"></a>名词介绍</h2><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210731155837945.png" alt="image-20210731155837945"><img src="https://oscimg.oschina.net/oscnet/up-4eed6638b3db895c1dd61c6b26332e63450.png" alt="up-4eed6638b3db895c1dd61c6b26332e63450.png"></p><ul><li>Broker: 接收和分发消息的应用,RabbitMQ Server就是Message Broker</li><li>Virtual host:储于多租户和安全因素设计的,把AMQP的基本组件划分到一个虚拟的分组中,类似于网络中的namespace概念。当多个不同的用户使用同一个rabbitMQ server提供的服务时,可以划分出多个vhost,每个用户在自己的vhost创建exchange/queue等,<strong>broker里面包含多个vhost,vhost包含多个Exchang</strong></li><li>Connection:publisher/consumer和broker之间的TCP连接</li><li>Channel:如果每一此访问RabbitMQ都建立一个Connection,在消息量大的时候建立TCP Connection的开销将是巨大的,效率也低。Connection极大减少了操作系统建立TCP connection的开销</li><li>Exchang:message 到达Broker的第一站,根据分发规则,匹配查询表中的routing key,分发消息到queue中去。常见的类型有:direct(point-to-point),topic(publish-subscribe) and fanout(multicast)</li><li>PUB-SUB通过Channel发送接收消息</li></ul><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><ul><li>需要epel环境</li></ul><blockquote><p>yum -y install epel-release</p></blockquote><ul><li>下载socat:erlang依赖包</li></ul><blockquote><p>yum -y install erlang socat</p></blockquote><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul><li>添加开机启动RabbitMQ服务</li></ul><blockquote><p>chkconfig rabbitmq-server on</p></blockquote><ul><li>启动服务</li></ul><blockquote><p>/sbin/service rabbitmq-server start</p></blockquote><ul><li>查看服务状态</li></ul><blockquote><p>/sbin/service rabbitmq-server status</p></blockquote><ul><li>停止服务</li></ul><blockquote><p>/sbin/service rabbitmq-server stop</p></blockquote><ul><li>开启web管理插件:端口15672   id:guest pwd:guest</li></ul><blockquote><p>rabbitmq-plugins enable rabbitmq_management</p></blockquote><ul><li><p>添加用户并设置权限</p><ul><li>创建账号</li></ul><blockquote><p>rabbitmqctl add_user [username] [pwd]</p></blockquote><ul><li>设置用户角色</li></ul><blockquote><p>rabbitmqctl set_user_tags admin administrator</p></blockquote><ul><li>设置用户权限:需要设置权限才能登陆mq web界面在vhost”/“</li></ul><blockquote><p>set_permissions [-p &lt;vhostpath&gt;] &lt;usr&gt; &lt;conf&gt; &lt;write&gt; &lt;read&gt; </p></blockquote><blockquote><p>rabbitmqctl set_permissions -p “/“ admin “.*“ “.*“ “.*“//用户admin具有/vhost这个virtual host中所有资源的配置、写、读权限</p></blockquote><ul><li>当前用户和角色</li></ul><blockquote><p>rabbitmqctl list_users</p></blockquote></li><li><p>端口</p><ul><li>5672 服务端口</li><li>15672 web监控端口</li></ul></li></ul><h2 id="创建JAVA开发环境"><a href="#创建JAVA开发环境" class="headerlink" title="创建JAVA开发环境"></a>创建JAVA开发环境</h2><h3 id="生产者-发消息给队列"><a href="#生产者-发消息给队列" class="headerlink" title="生产者:发消息给队列"></a>生产者:发消息给队列</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--rabbitmq--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210731214346680.png" alt="image-20210731214346680"></p><ul><li>name:队列名</li><li>durable:是否持久化到磁盘,默认在内存</li><li>exclusive:是否排外,false不排外</li><li>autoDelete:是否自动删除，当没有生产者或者消费者使用此队列，该队列会自动删除</li><li>arguments:其他参数</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210731220505019.png" alt="image-20210731220505019"></p><ul><li>s-&gt;exchange:发送到哪个交换机</li><li>s1-&gt;routingKey:路由的key是哪个,本次是队列的名称</li><li>BasicProperties:其他参数信息</li><li>body:发送的消息,需要二进制</li></ul><blockquote><p>非boot项目rabbitmq publish发送大体思路</p><blockquote><p>创建rabbitmq的factory并配置rabbit的访问信息</p><p>ConnectionFactory factory = new ConnectionFactory();</p></blockquote><blockquote><p>如果没有Connection创建Connction</p><p>Connection connection = factory.newConnection();</p></blockquote><blockquote><p>生产者创建或加入一个channel</p><p>Channel channel = connection.createChannel();</p></blockquote><blockquote><p>channel创建队列</p><p>channel.queueDeclare(QUEUE_NAME,true,false,false,null);</p></blockquote><blockquote><p>channelpublic需要通过交换机选择队列名public二进制消息</p><p>channel.basicPublish(“”,QUEUE_NAME,null,message.getBytes(StandardCharsets.UTF_8));</p></blockquote></blockquote><h3 id="消费者-消费者消费消息队列-接收消息"><a href="#消费者-消费者消费消息队列-接收消息" class="headerlink" title="消费者:消费者消费消息队列:接收消息"></a>消费者:消费者消费消息队列:接收消息</h3><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210801070644887-16277728059241.png" alt="image-20210801070644887"></p><ul><li>s:队列名</li><li>boolean:是否自动应答</li><li>DeliverCallback:消费成功回调函数</li><li>CancelCallback:取消消费回调函数</li></ul><blockquote><p>非boot项目mq接收消息</p><blockquote><p>创建连接工厂,设置相关属性</p></blockquote><blockquote><p>创建连接</p></blockquote><blockquote><p>创建channel</p></blockquote><blockquote><p>使用channel.basicComsumer消费</p></blockquote><blockquote><p>channel.basicConsume(QUEUE_NAME,true,(consumerTag,message) -&gt; {<br>     System.out.println(new String(message.getBody()));<br>},consumertag -&gt; {<br>     System.out.println(“消息被中断”);<br>});</p></blockquote></blockquote><h1 id="Work-Queue"><a href="#Work-Queue" class="headerlink" title="Work Queue"></a>Work Queue</h1><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210801071514042.png" alt="image-20210801071514042"></p><ul><li>工作线程(消费者):轮询分发线程</li></ul><h2 id="消息应答"><a href="#消息应答" class="headerlink" title="消息应答"></a>消息应答</h2><ul><li><p>概念</p><ul><li>如果某个worker工作时间长且只工作了一部分就宕机了。RabbitMQ一旦向消费者传递了一条消息,便立即将该消息标记为删除。</li><li>为了保证在发送过程中不丢失,rabbitmq引入消息应答机制:**消费者在接收到消息并且处理该消息之后,高速rabbitmq它已经 处理了,rabbitmq可以把该消息删除了</li></ul></li><li><p>自动应答:少使用</p><ul><li>消息发送后<strong>立即被认为已经传送成功</strong>,需要在高吞吐量和数据传输安全性方面权衡:<strong>必须使数据传输量在worker极限内</strong></li></ul></li><li><p>手动</p><blockquote><p>肯定确认,RabbitMQ已直到该消息并且成功的处理,可以丢弃该消息了</p><blockquote><p>Channel.basicACK()</p></blockquote><p>否定确认</p><blockquote><p>Channel.basicNack()</p></blockquote><p>否定确人,与Channel.basicNack相比少一个参数,不处理该消息直接拒绝,通知队列将其丢弃</p><blockquote><p>Channel.basicReject()</p></blockquote></blockquote></li></ul><h2 id="Reject比起Nack缺少的参数Multiple"><a href="#Reject比起Nack缺少的参数Multiple" class="headerlink" title="Reject比起Nack缺少的参数Multiple"></a>Reject比起Nack缺少的参数Multiple</h2><blockquote><p>channel.basicACK(deliveryTag,true)</p></blockquote><ul><li>multiple的true和false代表不同意思<ul><li>true代表应答channel上未应答的消息<ul><li>比如说channel上有传送tag的消息5,6,7,8 当前tag是8,那么此时5-8这些还未应答的消息都会被确认收到消息应答</li></ul></li><li>false代表不批量:建议<ul><li>5,6,7,8,当前tag8,只会应答8</li></ul></li></ul></li></ul><h2 id="消息自动重新入列"><a href="#消息自动重新入列" class="headerlink" title="消息自动重新入列"></a>消息自动重新入列</h2><ul><li>由于消费者由于某些原因失去连接,导致消息未发送ACK确认,MQ将了解到消息未完全处理,并将其重新排队</li></ul><h2 id="队列持久化"><a href="#队列持久化" class="headerlink" title="队列持久化"></a>队列持久化</h2><ul><li>未持久化的队列不能改为持久化队列,需要将其删除并标注持久化</li><li>持久化之后重启rabbitmq队列也依然存在</li><li>队列持久化需要在声明队列时进行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> durable = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">boolean</span> exclusive = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">boolean</span> autoDelete = <span class="keyword">false</span>;</span><br><span class="line">channel.queueDeclare(QUEUE_NAME, durable, exclusive, autoDelete, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><h2 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h2><ul><li><p>队列持久化并不能保证消息持久化</p></li><li><p>需要在发布时声明消息持久化</p></li><li><p>消息未持久化做法</p></li></ul><blockquote><p>channel.basicPublic(“”,QUEUE_NAME,null,message.getBytes())</p></blockquote><ul><li>消息持久化做法:在properties添加MessageProperties.PERSISTENT_TEXT_PLAIN属性</li></ul><blockquote><p>channel.basicPublic(“”,QUEUE_NAME,MessageProperties.PERSISTENT_TEXT_PLAIN,message.getBytes())</p></blockquote><h3 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h3><ul><li>将消息标记为持久化并不能完全保证不会丢失消息。尽管它告诉RabbitMQ将消息保存到磁盘,但是这里依然存在当消息刚准备存储,还未存储完时,消息还在缓存的一个间隔点。此时并没有真正写入磁盘。持久性保证并不强,但是对于简单任务队列而言已经绰绰有余了。</li></ul><h2 id="轮询分发与不公平分发"><a href="#轮询分发与不公平分发" class="headerlink" title="轮询分发与不公平分发"></a>轮询分发与不公平分发</h2><h3 id="轮询分发痛点"><a href="#轮询分发痛点" class="headerlink" title="轮询分发痛点"></a>轮询分发痛点</h3><ul><li>worker处理速度不均,但是分配平均,所以会导致处理速度块的worker有空闲时间,而处理速度慢的worker堆积消息(木桶效应)</li></ul><h3 id="公平分发-能者多劳"><a href="#公平分发-能者多劳" class="headerlink" title="公平分发:能者多劳"></a>公平分发:能者多劳</h3><ul><li>当前worker处理完业务之后才能获取下一则消息,能有效减少消息的堆积,<strong>每个consumer拥有一个channel用于堆积unacked的信息,在channel没满时会大致按照轮询分发将channel填满</strong></li><li><strong>公平需要在consume端设置</strong></li><li>设置不公平分发,<strong>需要设置手动应答</strong></li></ul><blockquote><p>int prefetchCount = 1</p><p>channel.basicQos(prefetchCount);</p></blockquote><ul><li>参数详解</li></ul><blockquote><p>void basicQos(int prefetchSize, int prefetchCount, boolean global) throws IOException;</p></blockquote><ul><li>含义详解<ul><li>param1：prefetchSize，最大unacked最大的信息<strong>字节数</strong>,八字节为单位，如果不受限制，则为0,一般不用<ul><li>默认值：0</li></ul></li><li>param2：prefetchCount，最大unacked的<strong>信息条数</strong>，如果没有限制，则为0<ul><li>调用此方法时，该值必填。默认值：0</li></ul></li><li>param3：global，是否将设置应用于整个channel，而不是单个消费者<ul><li>默认值：false，应用于本身（一个消费者）<ul><li>true：应用于整个channel</li></ul></li></ul></li></ul></li><li>个数详解<ul><li>当一个参数时是prefetchCount</li><li>当两个参数时时prefetchCount,global</li></ul></li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210801144933238.png" alt="image-20210801144933238"></p><h2 id="发布确认"><a href="#发布确认" class="headerlink" title="发布确认"></a>发布确认</h2><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210801145526063.png" alt="image-20210801145526063"></p><ul><li><p>为什么要进行发布确认</p><ul><li>为了弥补队列消息持久化的弊端<ul><li>弊端:当Rabbitmq正在持久化数据时,突然宕机,则数据会丢失,但是此时已经发送ack,数据的一致性得到影响</li></ul></li><li>发布的消息合适会被broker确认<ul><li>可路由消息,当所有队列都接受消息时才触发 BasicAcks 事件,</li><li>路由到持久化队列的持久性消息,这意味着持久化到磁盘后才会触发 BasicAcks 事件</li><li>对于消息的镜像队列,这意味着所有镜像都已接受该消息后才会触发 BasicAcks 事件</li></ul></li><li>解决：<ul><li>增加发布确认,当Rabbitmq的将数据保存在磁盘上时给producer回一条发布确认</li><li>如果没有收到发布确认就要一直发布</li></ul></li><li>tips<ul><li>消息应答是consumer和rabbitmq之间的确认，发布确认是producer和rabbitmq之间的确认</li></ul></li></ul></li><li><p>开启发布确认</p><ul><li>在producer的channel使用方法confirSelect()</li></ul><blockquote><p>channel.confirSelect()</p></blockquote></li><li><p>发布确认方式</p><ul><li><p>单个发布确认</p><ul><li>在pruducer确认到本次信息的发布确认前不会发送下一条信息</li><li>特点:良好的数据一致性,同步性</li><li>编程方法:在每一条消息发送完毕之后使用一次channel.waitForconfirms,对于1000次消息发布消耗646ms</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">  String message = i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">  channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="keyword">null</span>, message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">  <span class="comment">//发布确认</span></span><br><span class="line">  channel.waitForConfirms();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>批量发布确认</p><ul><li>在producer确认到批量信息发布确认前不会发送下一条消息</li><li>特点:同步性,快速</li><li>缺点:不知道哪一条消息发送失败</li><li>编程方法,在批量消息发送完之后使用一次channel.waifForconfirms,1000消息发布消耗92ms</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">  String message = i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">  channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="keyword">null</span>, message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">  <span class="keyword">if</span>((i+<span class="number">1</span>) % <span class="number">100</span> == <span class="number">0</span>) channel.waitForConfirms();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>异步发布确认</p><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210801154029145.png" alt="image-20210801154029145"></p><ul><li>异步确认虽然编程逻辑比以上两个要复杂,但是性价比最高,无论是可靠性还是效率都很高,他是利用回调函数来达到消息可靠性传递的,这个中间件也是通过函数回调来保证是否投递成功</li><li>异步发布确认的监听器 1000条消息 35ms</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">channel.addConfirmListener((deliveryTag,multiple)-&gt;&#123;</span><br><span class="line">      <span class="comment">//监听成功</span></span><br><span class="line">      <span class="comment">//将acked的消息删除</span></span><br><span class="line">      <span class="keyword">if</span>(multiple) &#123;</span><br><span class="line">        ConcurrentNavigableMap&lt;Long, String&gt; headMap = confirmQueue.headMap(deliveryTag, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//跳表特性,截取出来的map删除,原表也会删除</span></span><br><span class="line">        headMap.clear();</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        confirmQueue.remove(deliveryTag);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,(deliveryTag,multiple)-&gt;&#123;</span><br><span class="line">      <span class="comment">//监听失败</span></span><br><span class="line">      System.out.println(<span class="string">&quot;未确认的消息&quot;</span>+deliveryTag);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">      String message = i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">      channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="keyword">null</span>, message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">      <span class="comment">//每次发送消息将此消息记录在发送队列中</span></span><br><span class="line">      confirmQueue.put(channel.getNextPublishSeqNo(), message);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>同一个会话， consumerTag 是固定的 可以做此会话的名字， deliveryTag 每次接收消息+1，可以做此消息处理通道的名字。</p><p>因此 deliveryTag 可以用来回传告诉 rabbitmq 这个消息处理成功 清除此消息（basicAck方法）</p></li></ul></li></ul></li><li><p>如何处理异步未确认消息</p><ul><li>最好的解决方案就是把未确认的消息放到一个基于内存的能被发布线程访问的队列,比如ConcurrentLinkedQueue这个队列在confirm callbacks与发布线程之间进行消息的传递</li></ul></li><li><p>发布确认方式速度对比</p></li></ul><h1 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h1><h2 id="PUB-SUB模式概念"><a href="#PUB-SUB模式概念" class="headerlink" title="PUB-SUB模式概念"></a>PUB-SUB模式概念</h2><ul><li>发布/订阅不同于Work Queue(一个消息只能交付给一个 consumer),PUB-SUB模式通过交换机将可以让一个消息交付给多个consumer</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210801175456504.png" alt="image-20210801175456504"></p><h2 id="Exchanges"><a href="#Exchanges" class="headerlink" title="Exchanges"></a>Exchanges</h2><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/20180808095217191.png"></p><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul><li>RabbitMQ消息传递模型的核心思想是:生产者生产的消息从不会直接发送到队列。实际上,通常生产者甚至都不知道这些消息传递到了哪些队列中</li><li>相反,生产者只能将消息发送到交换机(exchange),交换机工作的内容非常简单,一方面它接收来自生产者的消息,另一方面将它们推入队列。交换机必须确切直到如何处理收到的消息。是应该把这些消息放到特定队列还是说把他们放到许多队列还是说丢弃。这就由交换机的类型决定。</li></ul><blockquote><p>RabbitMQ消息模型的<strong>核心思想（core idea）</strong>: 生产者会把消息发送给RabbitMQ的交换中心（Exchange），Exchange的一侧是生产者，另一侧则是一个或多个队列，由Exchange决定一条消息的生命周期–发送给某些队列，或者直接丢弃掉</p></blockquote><h3 id="Exchanges类型"><a href="#Exchanges类型" class="headerlink" title="Exchanges类型"></a>Exchanges类型</h3><ul><li>直接(direct)</li><li>主题(topic)</li><li>标题(headers):不常用</li><li>扇出(fanout):PUB-SUB</li><li>延迟(x-delayed-message):delay</li><li>无名类型(默认):通常用空串识别.AMQP-default</li></ul><blockquote><p>channel.basicPublish(“”,”hello”,null,message.getBytes())</p></blockquote><ul><li>第一个参数是交换机的名称,空字符串表示默认或无名称交换机;消息能路由发送到队列中其实是由routingKey(bindingkey)绑定key指定的,如果它存在的话</li></ul><h3 id="临时队列-不带有durable"><a href="#临时队列-不带有durable" class="headerlink" title="临时队列:不带有durable"></a>临时队列:不带有durable</h3><ul><li><p>具有特定名称的队列eg.hello &amp; ack_queue。队列的名称对我们来说至关重要,消费者需要指定去消费哪个队列的消息</p></li><li><p>每当我们连接到Rabbit时,都需要一个全新的空队列,为此可以创建一个具有随机名称的队列,或者能让服务器选择一个随机队列名称。其次一旦我们断开了消费者的连接,队列将被自动删除</p><ul><li>创建临时队列的方式如下</li></ul><blockquote><p>String queueName = channel.queueDeclare().getQueue();</p></blockquote><ul><li>创建出来长这样</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210801180756843.png" alt="image-20210801180756843"></p></li></ul><h3 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h3><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210801181416792.png" alt="image-20210801181416792"></p><ul><li>猜测:系统中默认的RoutingKey是queueName</li></ul><h2 id="Fanout"><a href="#Fanout" class="headerlink" title="Fanout"></a>Fanout</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul><li>Fanout这种类型非常简单。正如名称中猜到的那样,它是将接收到的所有消息广播到它知道的所有队列中。系统中默认有些exchange类型</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210801181630487.png" alt="image-20210801181630487"></p><ul><li>PUB-SUB模型</li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li>先声明消费者<ul><li>声明交换机</li><li>声明队列</li><li>队列与交换机绑定并指定routingKey</li><li>从队列中获取订阅消息</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANG_NAME = <span class="string">&quot;logs&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">  Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">  <span class="comment">//声明一个交换机</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * EXCHANG_NAME </span></span><br><span class="line"><span class="comment">   * TYPE -&gt; fanout</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  channel.exchangeDeclare(EXCHANG_NAME,<span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">  <span class="comment">//声明一个队列,临时队列</span></span><br><span class="line">  <span class="comment">/* 队列名称不知道</span></span><br><span class="line"><span class="comment">   * 当消费者断开与队列的连接的时候,队列自动删除</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  String queueName = channel.queueDeclare().getQueue();</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 绑定队列与交换机</span></span><br><span class="line"><span class="comment">   * queue -&gt; queueName</span></span><br><span class="line"><span class="comment">   * EXCHANG -&gt; EXCHANG_NAME</span></span><br><span class="line"><span class="comment">   * routingKey -&gt; &quot;&quot;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  channel.queueBind(queueName, EXCHANG_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line">  System.out.println(<span class="string">&quot;wating for receiving and print it on screen&quot;</span>);</span><br><span class="line"></span><br><span class="line">  channel.basicConsume(queueName,<span class="keyword">true</span>,(consumeTag,deliver) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;received message: &quot;</span>+<span class="keyword">new</span> String(deliver.getBody()));</span><br><span class="line">  &#125;,consumeTag -&gt; &#123;</span><br><span class="line">      </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>生产者</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交换机名称</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANG_NAME = <span class="string">&quot;logs&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">  Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">  <span class="comment">//channel.exchangeDeclare(EXCHANG_NAME, &quot;fanout&quot;);</span></span><br><span class="line"></span><br><span class="line">  Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (input.hasNext())&#123;</span><br><span class="line">    String message = input.next();</span><br><span class="line">    channel.basicPublish(EXCHANG_NAME, <span class="string">&quot;&quot;</span>, <span class="keyword">null</span>, message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">    System.out.println(<span class="string">&quot;producer published&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Direct"><a href="#Direct" class="headerlink" title="Direct"></a>Direct</h2><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210801214004823.png" alt="image-20210801214004823"></p><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210801214024917.png" alt="image-20210801214024917"></p><ul><li>一个交换机与一个queue之间可以绑定多个routingkey</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210801220314509.png" alt="image-20210801220314509"></p><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210801222748187.png" alt="image-20210801222748187"></p><h2 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><ul><li>Topic交换机采用*与#号匹配routingkey达到效果</li></ul><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><ul><li><p>发送到类型是topic交换机的消息的routing_key不能随意些,必须满足一定的要求,它必须是一个单词列表,以点号分隔开。比如”stock.usd.nyse”,”nyse.vmw”,”quick.orange.rabbit”.单词列表不超过255个子节</p></li><li><p>替换符</p><ul><li>*(星号)可以代替一个单词</li><li>#(井号)可以代替0-n个单词</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210802102245602.png" alt="image-20210802102245602"></p><ul><li>此处为绑定规则<ul><li>quick.orange.rabbit 被队列Q1Q2接收到</li><li>lazy.orange.elephant 被队列Q1Q2接收到</li><li>lazy.pink.rabbit 虽然满足两个绑定但只被队列Q2接收一次</li></ul></li><li>特殊<ul><li>当一个队列绑定键是#,那么这个队列将接受所有数据,有点像fanout了</li><li>如果队列绑定键当中没有#和*出现,那么该队列绑定类型就是direct了</li></ul></li></ul></li></ul><h1 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h1><h2 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h2><ul><li>死信:无法被消费的信息</li><li>一般来说,producer将消息投递到broker或者直接到queue里了,consumer从queue取出消息进行消费,但某些时候<strong>由于特定的原因导致queue中的某些消息无法被消费</strong>,这样的消息没有后续的处理,就变成了死信,有死信就有了死信队列</li><li>应用场景,为了保证订单业务的消息数据不丢失,需要使用RabbitMQ的私信队列机制,当消息消费发生异常,将i西澳西投入私信队列中.eg.用户在商城下但成功并点击去支付后在指定时间未支付时自动失效</li></ul><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><ul><li>消息TTL过期</li><li>队列达到最大长度(队列满了,无法再添加数据到mq中)</li><li>消息被拒绝(basicReject或basic.nack)并且requeue=false</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210802112553230.png" alt="image-20210802112553230"></p><h2 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h2><ul><li>将普通队列的死信添加到死信队列</li><li>使用队列声明的map</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210802114706599.png" alt="image-20210802114706599"></p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><ul><li><p>TTL</p><ul><li>可以在声明queue处设置TTL ms</li></ul><blockquote><p>arguments.put(“x-messaage-ttl”, 10000);</p></blockquote><ul><li>也可以在producer publish时声明TTL,properties为basicPublish时的参数,有DeliveryMode(1,2)1不持久,2持久</li></ul><blockquote><p>AMQP.BasicProperties properties =<br> new AMQP.BasicProperties().builder().expiration(“10000”).build();</p></blockquote><ul><li>TTL过期会到死信队列</li></ul></li><li><p>queue-max-length</p><ul><li>在声明队列时设置</li></ul><blockquote><p>arguments.put(“x-max-length”,6);</p></blockquote><ul><li>队列堆积时会到死信队列</li></ul></li><li><p>reject or nack</p><ul><li>关闭queue的自动应答</li></ul><blockquote><p>channel.basicConsume(“queueName”,false,callback,callback)</p></blockquote><ul><li>在回调函数里面设置拒绝消息(deliveryTag,requeue) <ul><li>deliveryTag,发布的tag,long类型</li><li>是否重新排队,此处为了使其进入死信,false</li></ul></li></ul><blockquote><p>channel.reject(message.getEnvelope().getDeliveryTag(), false)</p></blockquote></li><li><p>C1</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_EXCHANGE_NAME = <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_EXCHANGE_NAME = <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_QUEUE_NAME = <span class="string">&quot;normal_queue&quot;</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_QUEUE_NAME = <span class="string">&quot;dead_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">    <span class="comment">//声明channel</span></span><br><span class="line">    Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">    <span class="comment">//声明两个交换机</span></span><br><span class="line">    channel.exchangeDeclare(NORMAL_EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">    channel.exchangeDeclare(DEAD_EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">    <span class="comment">//声明两个队列 durable,exclusive,autoDelete</span></span><br><span class="line">    <span class="comment">//=====================================================================================</span></span><br><span class="line">    <span class="comment">//普通队列</span></span><br><span class="line">    Map&lt;String,Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//消息过期时间 ms producer发送时也可以设置TTL(此处使用比较多),比较灵活</span></span><br><span class="line">    <span class="comment">//arguments.put(&quot;x-messaage-ttl&quot;, 10000);</span></span><br><span class="line">    <span class="comment">//正常队列设置死信交换机</span></span><br><span class="line">    arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE_NAME);</span><br><span class="line">    <span class="comment">//设置死信队列的交换机转发的routingKey</span></span><br><span class="line">    arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">    <span class="comment">//设置normal队列最大长度.拒绝消息注释掉</span></span><br><span class="line">    <span class="comment">//arguments.put(&quot;x-max-length&quot;, 6);</span></span><br><span class="line">    <span class="comment">//durable,exclusive,autoDelete</span></span><br><span class="line">    channel.queueDeclare(NORMAL_QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, arguments);</span><br><span class="line">    <span class="comment">//====================================================================================</span></span><br><span class="line">    <span class="comment">//死信队列</span></span><br><span class="line">    channel.queueDeclare(DEAD_QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//绑定交换机</span></span><br><span class="line">    channel.queueBind(NORMAL_QUEUE_NAME, NORMAL_EXCHANGE_NAME, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    channel.queueBind(DEAD_QUEUE_NAME,DEAD_EXCHANGE_NAME,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;c1 waiting for message&quot;</span>);</span><br><span class="line">    <span class="comment">//C1消费普通队列</span></span><br><span class="line">    channel.basicConsume(NORMAL_QUEUE_NAME, <span class="keyword">false</span>, (consumeTag,message) -&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="string">&quot;5&quot;</span>.equals(<span class="keyword">new</span> String(message.getBody(), StandardCharsets.UTF_8)))&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;c1 rejected: &quot;</span>+<span class="keyword">new</span> String(message.getBody(), StandardCharsets.UTF_8));</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * deliveryTag</span></span><br><span class="line"><span class="comment">         * requeue</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicReject(message.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;c1: &quot;</span> + <span class="keyword">new</span> String(message.getBody(), StandardCharsets.UTF_8));</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * deliveryTag</span></span><br><span class="line"><span class="comment">         * multiple</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicAck(message.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      ThreadUtils.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;,message -&gt; &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;c1 fail&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>producer</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_EXCHANGE = <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">    Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">    <span class="comment">//死信消息,设置TTL(ms),建造者模式.最大长度不需要TTL</span></span><br><span class="line">    <span class="comment">//AMQP.BasicProperties properties =</span></span><br><span class="line">    <span class="comment">//  new AMQP.BasicProperties().builder().expiration(&quot;10000&quot;).build();</span></span><br><span class="line"></span><br><span class="line">    Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">while</span>(input.hasNext(<span class="string">&quot;y&quot;</span>) || input.hasNext(<span class="string">&quot;Y&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">        String message = i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        channel.basicPublish(NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>, <span class="keyword">null</span>, message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">&quot;message published&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;continue?y/N&quot;</span>);</span><br><span class="line">      input.next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>当前队列出现死信消息时需要将其传给死信队列,设置死信交换机,设置routingKey</li><li>消息的发布,死信消息的转发,凡是参数涉及交换机的都需要带上routingKey,而消息的consume是通过queueName</li><li>死信三种模式<ul><li>TTL</li><li>queue-max-length</li><li>reject | noack</li></ul></li></ul><h1 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h1><h2 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h2><ul><li>延时队列,队列内部是有序的,最重要的特性就体现在它的延时属性上,延时队列中的元素是希望在指定时间到了以后或之前取出和处理,简单来说,延时队列就是用来存放需要在指定时间被处理的元素的队列</li></ul><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>订单在十分钟之内未支付自动取消</li><li>新创建的店铺,如果在十天内都没有上传过商品,则自动发送消息提醒</li><li>用户注册成功后,如果三天内没有登陆则进行短信提醒</li><li>用户发起退款,如果三天内没有的到处理则通知相关运营人员</li><li>预定会议后,需要在预定的事件点前十分钟通知各个与会人员参加会议</li></ul><h1 id="springboot整合"><a href="#springboot整合" class="headerlink" title="springboot整合"></a>springboot整合</h1><ul><li>代码架构</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210802170927718.png" alt="image-20210802170927718"></p><ul><li><p>  基本流程</p></li><li><p>配置类配置队列,交换机,绑定关系</p><ul><li>队列类Queue:建造者模式</li><li>交换机类Exchange:直接返回</li><li>绑定关系Binding:建造者模式</li></ul></li><li><p>controller接收消息,使用RabbitTemplate发送</p></li><li><p>consumer消费消息,使用RabbitListener监听队列</p></li></ul><blockquote><p>配置类</p></blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TtlConfiguration</span> </span>&#123;</span><br><span class="line">  <span class="comment">//普通交换机的名称</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String X_EXCHANGE = <span class="string">&quot;X&quot;</span>;</span><br><span class="line">  <span class="comment">//死信交换机的名称</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String Y_DEAD_LETTER_EXCHANGE = <span class="string">&quot;Y&quot;</span>;</span><br><span class="line">  <span class="comment">//普通队列的名称</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_A = <span class="string">&quot;QA&quot;</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_B = <span class="string">&quot;QB&quot;</span>;</span><br><span class="line">  <span class="comment">//死信队列的名称</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_LETTER_QUEUE = <span class="string">&quot;QD&quot;</span>;</span><br><span class="line">  <span class="comment">//声明xExchange</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">xExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(X_EXCHANGE);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//声明yExchange</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">yExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//声明Qa</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Queue <span class="title">queueA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//可以使用map来添加参数</span></span><br><span class="line">    <span class="comment">//Map&lt;String,Object&gt; arguments = new HashMap&lt;&gt;()</span></span><br><span class="line">    <span class="comment">//可以返回建造者模式</span></span><br><span class="line">    <span class="keyword">return</span> QueueBuilder</span><br><span class="line">      .durable(QUEUE_A)</span><br><span class="line">      .ttl(<span class="number">10000</span>)  <span class="comment">//队列消息过期时间,expires是队列过期时间 10s</span></span><br><span class="line">      .deadLetterExchange(Y_DEAD_LETTER_EXCHANGE) <span class="comment">//死信交换机</span></span><br><span class="line">      .deadLetterRoutingKey(<span class="string">&quot;YD&quot;</span>)<span class="comment">//设置死信routingKey</span></span><br><span class="line">      .build();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//声明Qb</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Queue <span class="title">queueB</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder</span><br><span class="line">      .durable(QUEUE_B)</span><br><span class="line">      .ttl(<span class="number">40000</span>)  <span class="comment">//队列消息过期时间,expires是队列过期时间 10s</span></span><br><span class="line">      .deadLetterExchange(Y_DEAD_LETTER_EXCHANGE) <span class="comment">//死信交换机</span></span><br><span class="line">      .deadLetterRoutingKey(<span class="string">&quot;YD&quot;</span>)<span class="comment">//设置死信routingKey</span></span><br><span class="line">      .build();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//声明死信队列</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Queue <span class="title">queueD</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder</span><br><span class="line">      .durable(DEAD_LETTER_QUEUE)</span><br><span class="line">      .build();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//绑定</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Binding <span class="title">queueABindX</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(queueA()).to(xExchange()).with(<span class="string">&quot;XA&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Binding <span class="title">queueBBindX</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(queueB()).to(xExchange()).with(<span class="string">&quot;XB&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Binding <span class="title">queueDBindY</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(queueD()).to(yExchange()).with(<span class="string">&quot;YD&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>controller</p></blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TtlConfiguration</span> </span>&#123;</span><br><span class="line">  <span class="comment">//普通交换机的名称</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String X_EXCHANGE = <span class="string">&quot;X&quot;</span>;</span><br><span class="line">  <span class="comment">//死信交换机的名称</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String Y_DEAD_LETTER_EXCHANGE = <span class="string">&quot;Y&quot;</span>;</span><br><span class="line">  <span class="comment">//普通队列的名称</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_A = <span class="string">&quot;QA&quot;</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_B = <span class="string">&quot;QB&quot;</span>;</span><br><span class="line">  <span class="comment">//死信队列的名称</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_LETTER_QUEUE = <span class="string">&quot;QD&quot;</span>;</span><br><span class="line">  <span class="comment">//声明xExchange</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">xExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(X_EXCHANGE);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//声明yExchange</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">yExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//声明Qa</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Queue <span class="title">queueA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//可以使用map来添加参数</span></span><br><span class="line">    <span class="comment">//Map&lt;String,Object&gt; arguments = new HashMap&lt;&gt;()</span></span><br><span class="line">    <span class="comment">//可以返回建造者模式</span></span><br><span class="line">    <span class="keyword">return</span> QueueBuilder</span><br><span class="line">      .durable(QUEUE_A)</span><br><span class="line">      .ttl(<span class="number">10000</span>)  <span class="comment">//队列消息过期时间,expires是队列过期时间 10s</span></span><br><span class="line">      .deadLetterExchange(Y_DEAD_LETTER_EXCHANGE) <span class="comment">//死信交换机</span></span><br><span class="line">      .deadLetterRoutingKey(<span class="string">&quot;YD&quot;</span>)<span class="comment">//设置死信routingKey</span></span><br><span class="line">      .build();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//声明Qb</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Queue <span class="title">queueB</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder</span><br><span class="line">      .durable(QUEUE_B)</span><br><span class="line">      .ttl(<span class="number">40000</span>)  <span class="comment">//队列消息过期时间,expires是队列过期时间 10s</span></span><br><span class="line">      .deadLetterExchange(Y_DEAD_LETTER_EXCHANGE) <span class="comment">//死信交换机</span></span><br><span class="line">      .deadLetterRoutingKey(<span class="string">&quot;YD&quot;</span>)<span class="comment">//设置死信routingKey</span></span><br><span class="line">      .build();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//声明死信队列</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Queue <span class="title">queueD</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder</span><br><span class="line">      .durable(DEAD_LETTER_QUEUE)</span><br><span class="line">      .build();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//绑定</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Binding <span class="title">queueABindX</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(queueA()).to(xExchange()).with(<span class="string">&quot;XA&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Binding <span class="title">queueBBindX</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(queueB()).to(xExchange()).with(<span class="string">&quot;XB&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Binding <span class="title">queueDBindY</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(queueD()).to(yExchange()).with(<span class="string">&quot;YD&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>consumer</p></blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLetterQueueConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//接收消息</span></span><br><span class="line">  <span class="meta">@RabbitListener(queues = &quot;QD&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveD</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    String msg = <span class="keyword">new</span> String(message.getBody(), StandardCharsets.UTF_8 );</span><br><span class="line">    log.info(<span class="string">&quot;当前时间: &#123;&#125;,收到死信队列的消息:&#123;&#125;&quot;</span>,<span class="keyword">new</span> Date().toString(),msg);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="坑-1"><a href="#坑-1" class="headerlink" title="坑"></a>坑</h2><ul><li>在监听时使用的Channel是com.rabbitmq.client.Channel里的Channel接口而非com.rabbitmq.client.Channel.AMQP的Channel类</li></ul><h2 id="延迟队列优化"><a href="#延迟队列优化" class="headerlink" title="延迟队列优化"></a>延迟队列优化</h2><ul><li>增加一个queueC使其里面的消息没有ttl</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210802191413841.png" alt="image-20210802191413841"></p><h2 id="死信队列做延迟的缺点"><a href="#死信队列做延迟的缺点" class="headerlink" title="死信队列做延迟的缺点"></a>死信队列做延迟的缺点</h2><ul><li>如果在消息属性上设置TTL的方式,消息可能并不会按时”死亡”,因为RabbitMQ只会检查第一个消息是否过期,如果过期则丢到死信队列,如果第一个消息的延时时长很长,而第二个消息的延时时长很短.第二个消息并不会优先得到执行</li><li>简单来说,mq只会检测当前最前方的ttl后面的不会检测,因此后面的ttl会收到前面的影响,这与队列数据结构的特点密不可分</li></ul><h2 id="Rabbitmq插件实现延迟队列"><a href="#Rabbitmq插件实现延迟队列" class="headerlink" title="Rabbitmq插件实现延迟队列"></a>Rabbitmq插件实现延迟队列</h2><ul><li><p>安装</p><ul><li><a href="https://www.rabbitmq.com/community-plugins.html">https://www.rabbitmq.com/community-plugins.html</a></li><li>解压放置到RabbitMQ的插件目录.执行命令让插件生效,重启RabbitMQ</li></ul><blockquote><p>/usr/lib/rabbitmq/lib/rabbitmq_server-3.8.8/plugins</p></blockquote><blockquote><p>rabbitmq-plugins enable rabbitmq_delayed_message_exchange</p></blockquote></li><li><p>基于插件实现延迟</p></li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210802203223604.png" alt="image-20210802203223604"></p><ul><li><p><strong>这里将延迟赋予交换机而不赋予队列</strong>,因为队列的数据结构决定了其不适用于延迟</p></li><li><p>代码</p><blockquote><p>配置类,交换机的不同之处,返回customExchange</p><p>交换机类型 “x-delayed-message”</p><p>路由类型需要在后面Map arguments里面配置 “x-delayed-type”</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedQueueConfig</span> </span>&#123;</span><br><span class="line">  <span class="comment">//队列</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_QUEUE_NAME = <span class="string">&quot;delayed.queue&quot;</span>;</span><br><span class="line">  <span class="comment">//交换机</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_EXCHANGE_NAME = <span class="string">&quot;delayed.exchange&quot;</span>;</span><br><span class="line">  <span class="comment">//routingKey</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_ROUTING_KEY = <span class="string">&quot;delayed.routingKey&quot;</span>;</span><br><span class="line">  <span class="comment">//声明交换机</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> CustomExchange <span class="title">delayedExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 1.交换机名称</span></span><br><span class="line"><span class="comment">     * 2.交换机的类型</span></span><br><span class="line"><span class="comment">     * 3.是否需要持久化</span></span><br><span class="line"><span class="comment">     * 4.是否需要自动删除</span></span><br><span class="line"><span class="comment">     * 5.其他参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Map&lt;String,Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//相当于设置路由类型,此处重点</span></span><br><span class="line">    arguments.put(<span class="string">&quot;x-delayed-type&quot;</span>, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CustomExchange(DELAYED_EXCHANGE_NAME, <span class="string">&quot;x-delayed-message&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, arguments );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//声明队列</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Queue <span class="title">delayedQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder</span><br><span class="line">      .durable(DELAYED_QUEUE_NAME)</span><br><span class="line">      .build();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//声明Binding</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Binding <span class="title">delayedBinding</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(delayedQueue()).to(delayedExchange()).with(DELAYED_ROUTING_KEY).noargs();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>生产者代码</p><p>这里不再设置expiration而是设置Delay</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/sendDelayMsg/&#123;message&#125;/&#123;delayTime&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(<span class="meta">@PathVariable(&quot;message&quot;)</span> String message,<span class="meta">@PathVariable(&quot;delayTime&quot;)</span> Integer delayTime)</span></span>&#123;</span><br><span class="line">  log.info(<span class="string">&quot;当前时间:&#123;&#125;,发送一条时长为&#123;&#125;毫秒的TTL信息给延时队列QC:&#123;&#125;&quot;</span>,<span class="keyword">new</span> Date(),delayTime,message);</span><br><span class="line">  rabbitTemplate.convertAndSend(DelayedQueueConfig.DELAYED_EXCHANGE_NAME,</span><br><span class="line">    DelayedQueueConfig.DELAYED_ROUTING_KEY, message,</span><br><span class="line">    msg -&gt; &#123;</span><br><span class="line">      <span class="comment">//此处设置delay</span></span><br><span class="line">      msg.getMessageProperties().setDelay(delayTime);※※</span><br><span class="line">      <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>消费者代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueueConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RabbitListener(queues = DelayedQueueConfig.DELAYED_QUEUE_NAME)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveDelayedMessage</span><span class="params">(Message message, Channel channel)</span></span>&#123;</span><br><span class="line">    String msg = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">    log.info(<span class="string">&quot;当前时间: &#123;&#125;,收到延时队列的消息:&#123;&#125;&quot;</span>,<span class="keyword">new</span> Date(),msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul><li>延迟队列在需要延迟处理的场景下非常有用,使用RabbitMQ来实现延时队列可以很好的利用RabbitMQ的特性,如:消息可靠发送、消息可靠投递、死信队列来保障消息至少被消费一次以及违背正确处理的消息不会被丢弃。另外,通过RabbitMQ集群的特性,可以很好的解决单点故障问题,不会因为单个节点挂掉导致延时队列不可用或者消息丢失</li><li>当然,然是队列还有很多其它选择,比如利用Java的DelayQueue,利用Redis的zset,利用Quartz或者利用kafka的时间轮,这些方式各有各特点,看需要适用的场景</li></ul><h1 id="发布确认高级"><a href="#发布确认高级" class="headerlink" title="发布确认高级"></a>发布确认高级</h1><h2 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h2><ul><li>在生产环境中由于一些不明原因,导致rabbitmq重启,在RabbitMQ重启期间生产者消息投递失败,导致消息丢失,需要手动处理和恢复。于是,如何才能进行RabbitMQ的消息可靠投递呢,特别是在比较极端的情况下,RabbitMQ集群不可用的时候,无法投递的消息该如何处理呢?</li><li>问题:交换机发送消息给rabbitmq,其无法收到(exchange,queue),将消息放入缓存,到时机重新发</li><li>需要确认的地方<ol><li>交换机</li><li>队列</li></ol></li></ul><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><ul><li><p>交换机回退:在配置文件中需要添加</p><blockquote><p>spring.rabbitmq.publisher-confirm-type=correlated</p></blockquote><ul><li><p>NONE</p><p>禁用发布确认模式,默认</p></li><li><p>CORRELATED</p><p>发布消息成功到交换机后会触发回调方法</p></li><li><p>SIMPLE:同步确认消息</p><ol><li>和CORRELATED一样触发交换机回调</li><li>在发布消息成功后使用rabbitTemplate调用waitForconfirms或waitForConfirmsOrDie方法等待broker节点返回发送结果,根据返回结果来判定下一步逻辑,注:waitForConfirmsOrDie方法如果返回false,会关闭channel,则接下来无法发送消息到broker</li></ol></li></ul></li><li><p>消息回退(队列) </p><blockquote><p>spring.rabbitmq.publisher-returns: true</p></blockquote><ul><li>false:默认,不采用此模式</li><li>true:开启消息回退,队列回退消息会被回调接口记录</li></ul></li></ul><h2 id="发布确认springboot版本"><a href="#发布确认springboot版本" class="headerlink" title="发布确认springboot版本"></a>发布确认springboot版本</h2><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210802213400597.png" alt="image-20210802213400597"></p><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210802213407104.png" alt="image-20210802213407104"></p><h2 id="回调接口-监控交换机消息"><a href="#回调接口-监控交换机消息" class="headerlink" title="回调接口:监控交换机消息"></a>回调接口:监控交换机消息</h2><ul><li><p>特点:只会获得交换机的是否接收了此消息,队列没有接收不会管理</p></li><li><p>rabbitTemplate</p></li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210803113033121.png" alt="image-20210803113033121"></p><ul><li>参数<ul><li>CorrelationData:发送的内容,保存回调信息的ID以及相关信息<strong>需要publisher创建</strong><ul><li>CorrelationData的ID如果不设置会自动设置</li></ul></li><li>boolean:是否发送成功</li><li>String:发送失败原因,成功为null</li></ul></li><li>代码</li></ul><blockquote><p>回调接口 implements RabbitTemplate.ConfirmCallback</p><p>这里实现了ConfirmCallback接口,其实可以用函数式,参考后面的代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallBack</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ConfirmCallback</span> </span>&#123;</span><br><span class="line">  <span class="comment">//注入此实现类</span></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  RabbitTemplate rabbitTemplate;</span><br><span class="line">  <span class="comment">//在类加载完之后将此回调注入rabbitTemplate</span></span><br><span class="line">  <span class="meta">@PostConstruct</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rabbitTemplate.setConfirmCallback(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">    String s = correlationData == <span class="keyword">null</span> ? <span class="string">&quot;&quot;</span> : correlationData.getId();</span><br><span class="line">    <span class="keyword">if</span>(ack)&#123;</span><br><span class="line">      log.info(<span class="string">&quot;exchange successfully received correlationId is: &#123;&#125;&quot;</span>,s);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      log.error(<span class="string">&quot;exchange fail to receive correlationId is: &#123;&#125;\nthe reason is: &#123;&#125;&quot;</span>,s,cause);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>回调接口的函数式编码</p><p>通过单例的rabbitTemplate set了两个回调函数,通过箭头函数实现匿名内部类,此种编码方式比实现一个类简单,适用于简单逻辑,如果逻辑较复杂建议解耦</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//交换机消息回调</span></span><br><span class="line">    rabbitTemplate.setConfirmCallback(((correlationData, ack, cause) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#125;));</span><br><span class="line">    <span class="comment">//队列回退消息回调</span></span><br><span class="line">    rabbitTemplate.setReturnsCallback(returned -&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>生产者,Correlation参数需要添加</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发消息</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/sendMessage/&#123;message&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="meta">@PathVariable(&quot;message&quot;)</span> String message)</span></span>&#123;</span><br><span class="line">  <span class="comment">//定义correlation,交换机回退时需要添加此消息</span></span><br><span class="line">  CorrelationData correlation = <span class="keyword">new</span> CorrelationData(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    </span><br><span class="line">  rabbitTemplate.convertAndSend(ConfirmConfig.CONFIRM_EXCHANGE_NAME,</span><br><span class="line">    ConfirmConfig.CONFIRM_ROUTING_KEY,message,correlation);</span><br><span class="line">  log.info(<span class="string">&quot;发送消息内容为&#123;&#125;&quot;</span>,message);</span><br><span class="line">    </span><br><span class="line">  CorrelationData correlation1 = <span class="keyword">new</span> CorrelationData(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    </span><br><span class="line">  rabbitTemplate.convertAndSend(ConfirmConfig.CONFIRM_EXCHANGE_NAME,</span><br><span class="line">    ConfirmConfig.CONFIRM_ROUTING_KEY+<span class="string">&quot;gsdgsadgsd&quot;</span>,message,correlation1);</span><br><span class="line">  log.info(<span class="string">&quot;发送消息内容为&#123;&#125;&quot;</span>,message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回退消息-监控队列消息"><a href="#回退消息-监控队列消息" class="headerlink" title="回退消息:监控队列消息"></a>回退消息:监控队列消息</h2><ul><li><p>特点</p><ul><li>将消息返回给生产者</li></ul></li><li><p>Mandatory参数</p><ul><li><strong>在仅开启了生产者确认机制的情况下,交换机接收到消息后,会直接给消息生产者发送确认消息,如果发现该消息不可路由,那么消息会被直接丢弃,此时生产者是不知道消息被丢弃这个事件的</strong>。</li><li>如何让无法被路由的消息通知生产者?<strong>通过设置Mandatory参数可以在当消息传递过程中不可达目的地时将消息返回给生产者</strong></li><li>Mandatory参数:spring.rabbitmq.publisher-returns</li></ul></li><li><p>配置文件</p><blockquote><p>spring.rabbitmq.publisher-returns=true</p></blockquote></li><li><p>代码</p><blockquote><p>此方法存在于接口RabbitTemplate.ReturnsCallback</p><p>ReturnerMessage类似于pojo类,里面包含回退的信息,交换机,回退原因等等</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 队列回退消息处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(ReturnedMessage returned)</span> </span>&#123;</span><br><span class="line">  log.error(<span class="string">&quot;消息&#123;&#125;,被交换机&#123;&#125;退回,退回原因:&#123;&#125;,路由Key:&#123;&#125;&quot;</span>,</span><br><span class="line">    <span class="keyword">new</span> String(returned.getMessage().getBody()),</span><br><span class="line">    returned.getExchange(),</span><br><span class="line">    returned.getReplyText(),</span><br><span class="line">    returned.getRoutingKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="备份交换机-控制回退消息"><a href="#备份交换机-控制回退消息" class="headerlink" title="备份交换机:控制回退消息"></a>备份交换机:控制回退消息</h2><ul><li><p>简介</p><ul><li>备份交换机是在原交换机路由不通的情况下走的交换机,可以在发生状况之后走备份交换机</li><li>回退消息优先走备份交换机,而不是回退给生产者</li></ul></li><li><p>代码架构图</p></li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210803153140806.png" alt="image-20210803153140806"></p><ul><li><p>备份交换机</p><ul><li>备份</li><li>报警</li></ul></li><li><p>代码</p><blockquote><p>备份交换机就一个代码有改动,设置备份交换机</p><p>使用交换机的建造者模式.alternate</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DirectExchange <span class="title">confirmExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//构建确认交换机</span></span><br><span class="line">  <span class="keyword">return</span> ExchangeBuilder</span><br><span class="line">    .directExchange(CONFIRM_EXCHANGE_NAME)</span><br><span class="line">    .durable(<span class="keyword">true</span>)</span><br><span class="line">     <span class="comment">//设置备份交换机</span></span><br><span class="line">    .alternate(BACKUP_EXCHANGE_NAME)</span><br><span class="line">    .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="RabbitMQ其他知识点"><a href="#RabbitMQ其他知识点" class="headerlink" title="RabbitMQ其他知识点"></a>RabbitMQ其他知识点</h1><h2 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h2><ul><li>用户对同一操作发起的一次请求或者多次请求的结果是一致的,不会因为多次点击而产生了副作用。比如消费结果反馈时网络异常,钱已经扣除但是用户没收到就再次付款</li></ul><h3 id="消息重复消费"><a href="#消息重复消费" class="headerlink" title="消息重复消费"></a>消息重复消费</h3><ul><li>定义<ul><li>消费者在消费MQ中的消息时,MQ已把消息发给消费者,消费者在给MQ返回ack时网络中断,故MQ没有接收到确认消息,该条消息会重新发给其他消费者,或者在网络重连后再次发送给该消费者,单实际上该消费者已成功消费了该条消息,造成消费者消费了重复的消息</li></ul></li><li>解决思路<ul><li>MQ消费者的幂等性解决一般使用全局ID或者写个唯一标识比如时间戳或者UUID,每次消费时判断该消息是否被消费国</li></ul></li><li>消费端的幂等性保障<ul><li>在业务高峰期,上铲断可能会重复发生消息,这时消费端要实现幂等性。业界主流的幂等性有两种操作:<ol><li>UUID+指纹码机制,利用数据库逐渐去重</li><li>利用redis的原子性去实现</li></ol></li></ul></li><li>UUID+指纹码机制<ul><li>指纹码:一些规则或者时间戳加别的服务给到的唯一信息码,根据业务来规定,需要保证唯一性<ul><li>优势,实现简单就一个凭借,然后查询判断是否重复</li><li>劣势:高并发时,如果是单个数据库就有写入性能瓶颈,当然可以采用分库分表提升性能</li></ul></li></ul></li><li>Redis原子性:推荐<ul><li>利用redis执行setnx命令,天然具有幂等性,从而实现不重复消费</li></ul></li></ul><h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><ul><li><p>使用场景</p><ul><li>订单系统使用大优先级给大客户,小优先级给小客户</li></ul></li><li><p>官方允许优先级0-255,越大越优先,推荐0-10</p><ul><li>在使用的时候给消息添加优先级</li><li>消息会被排序,255排序次数过多,影响性能</li></ul></li><li><p>使用注意</p><ul><li>队列设置优先级队列</li><li>发送消息携带优先级</li></ul></li><li><p>队列参数:设置最大优先级</p><blockquote><p>x-max-priority</p></blockquote><p>springboot中使用建造者模式.maxPriority可以设置</p></li><li><p>代码实现</p><blockquote><p>构建出一个优先级队列 .maxPriority</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//优先级队列</span></span><br><span class="line"><span class="meta">@Bean</span> <span class="function">Queue <span class="title">priorityQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> QueueBuilder</span><br><span class="line">    .durable(PRIORITY_QUEUE_NAME)</span><br><span class="line">    .maxPriority(<span class="number">10</span>) <span class="comment">//设置最大的优先级</span></span><br><span class="line">    .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>producer发送时信息添加优先级</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发优先级消息</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/sendPriorityMessage&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendPriorityMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">    String message = i +<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;5&quot;</span>.equals(message))&#123;</span><br><span class="line">      <span class="comment">//发送消息,将优先级设置为5</span></span><br><span class="line">      rabbitTemplate.convertAndSend(ConfirmConfig.PRIORITY_EXCHANGE_NAME,</span><br><span class="line">        ConfirmConfig.PRIORITY_ROUTING_KEY,</span><br><span class="line">        message,</span><br><span class="line">        msg -&gt; &#123;</span><br><span class="line">          msg.getMessageProperties().setPriority(<span class="number">5</span>);</span><br><span class="line">          <span class="keyword">return</span> msg;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//发送消息,将优先级设置为1</span></span><br><span class="line">      rabbitTemplate.convertAndSend(ConfirmConfig.PRIORITY_EXCHANGE_NAME,</span><br><span class="line">        ConfirmConfig.PRIORITY_ROUTING_KEY,</span><br><span class="line">        message,</span><br><span class="line">        msg -&gt; &#123;</span><br><span class="line">          msg.getMessageProperties().setPriority(<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">return</span> msg;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="惰性队列"><a href="#惰性队列" class="headerlink" title="惰性队列"></a>惰性队列</h2><ul><li><p>队列消息保存</p><ul><li>磁盘</li><li>内存</li></ul></li><li><p>正常队列与惰性队列区别</p><ul><li>正常:消息保存在内存</li><li>惰性:消息保存在磁盘中</li></ul></li><li><p>为什么要使用惰性队列</p><ul><li>消费者下线,宕机或是储于维护而关闭等致使长时间不能消费消息造成堆积时,惰性队列就很有必要了</li><li>默认情况下,不适用惰性队列,因为速度慢</li></ul></li><li><p>两种模式</p><ul><li><p>default:默认模式</p></li><li><p>lazy:惰性队列的模式,声明队列时设置,springboot中使用建造者模式,参数</p><blockquote><p>map -&gt; (“x-queue-mode”,”lazy”)</p></blockquote><blockquote><p>QueueBuilder.durable(queueName).lazy().build;</p></blockquote></li></ul></li><li><p>内存开销对比</p><ul><li>发送一百万条消息,每条消息大概占1KB情况下,普通队列占用内存1.2GB,而惰性队列仅仅占用1.5MB,惰性队列内存只剩指针</li><li>惰性队列消费慢,占用内存少</li></ul></li></ul><h1 id="RabbitMQ集群"><a href="#RabbitMQ集群" class="headerlink" title="RabbitMQ集群"></a>RabbitMQ集群</h1><p>为了应对生产者大量发送消息,需要使用集群</p><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210803182340774.png" alt="image-20210803182340774"></p><h2 id="普通集群-副本集群-很少使用"><a href="#普通集群-副本集群-很少使用" class="headerlink" title="普通集群(副本集群):很少使用"></a>普通集群(副本集群):很少使用</h2><blockquote><p>RabbitMQ代理操作所需的所有数据/状态都将跨所有节点复制。这方面的例外是消息队列,默认情况下,消息队列位于一个节点上,尽管它们可以从所有节点看到和访问。要跨集群中的节点复制队列</p></blockquote><p><code>默认情况下:除了主节点的消息队列,所有的信息都能被备份,当主节点down掉之后,从节点无法取代主节点,因为队列数据都在主节点,仅能同步exchange,不能同步queue</code></p><ol><li>架构图</li></ol><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210803191030082.png" alt="image-20210803191030082"></p><p>​    核心解决问题:<code>当集群中某一时刻master节点宕机,Slave可以对Queue中结构进行备份但是其中的消息不能备份,但是不能使用,不能做到自动故障转移,因此只要主机down掉就会导致服务不可用</code></p><h2 id="镜像集群-高可用"><a href="#镜像集群-高可用" class="headerlink" title="镜像集群:高可用"></a>镜像集群:高可用</h2><p><code>镜像队列机制就是将队列在三个节点之间设置主从关系,消息会在三个节点之间进行自动同步,且如果其中一个节点不可用,并不会导致消息丢失或服务不可用的情况,提升MQ集群的整体高可用性</code></p><ol><li>集群架构图</li></ol><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210803192426404.png" alt="image-20210803192426404"></p><h2 id="clustering"><a href="#clustering" class="headerlink" title="clustering"></a>clustering</h2><h3 id="不同服务器上不使用docker搭建"><a href="#不同服务器上不使用docker搭建" class="headerlink" title="不同服务器上不使用docker搭建"></a>不同服务器上不使用docker搭建</h3><ul><li>在不同的服务器上搭建</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;hosts 将所有节点IP映射添上去(对应节点名) IP node1</span><br></pre></td></tr></table></figure><ul><li>在node1上执行远程操作命令同步各个节点的cookie文件,第一台给后面复制</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp /var/lib/rabbitmq/.erlang.cookie root@node2:/var/lib/rabbitmq/.erlang.cooki</span><br></pre></td></tr></table></figure><ul><li>在除node1各个节点执行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br><span class="line">(rabbitmqctl stop会将Erlang虚拟机关闭,rabbitmqctl stop_app制只关闭RabbitMQ服务)</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl join_cluster rabbit@node1(节点名)(下一个加入上一个1&lt;-2&lt;-3)</span><br><span class="line">rabbit start_app(只启动应用服务)</span><br></pre></td></tr></table></figure><ul><li>集群状态</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl cluster_status</span><br></pre></td></tr></table></figure><ul><li>需要重新设置用户</li></ul><blockquote><p>创建账号</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl add_user admin </span><br></pre></td></tr></table></figure><blockquote><p>设置用户角色</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_user_tags admin administrator</span><br></pre></td></tr></table></figure><blockquote><p>设置用户权限</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_permissions -p <span class="string">&quot;/&quot;</span> admin <span class="string">&quot;.*&quot;</span><span class="string">&quot;.*&quot;</span><span class="string">&quot;.*&quot;</span></span><br></pre></td></tr></table></figure><ul><li>解除集群节点(node2和node3机器分别执行)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl start_app</span><br><span class="line">rabbitmqctl cluster_status</span><br><span class="line">rabbitmqctl forget_cluster_node rabbit@node2(node1机器上执行)</span><br></pre></td></tr></table></figure><h3 id="使用docker搭建普通集群"><a href="#使用docker搭建普通集群" class="headerlink" title="使用docker搭建普通集群"></a>使用docker搭建普通集群</h3><p><code>注意:.erlang.cookie是一个隐藏文件,所以复制出来也是隐藏文件,使用ls -al查看隐藏文件</code></p><ol><li>pull image</li><li>run image </li></ol><blockquote><p>run的时候需要带上参数 -h | –hostname rabbitmq以此来识别彼此,3.9版本中RABBIT_ERLANG_COOKIE环境变量被废弃,改用其他方式</p><p>run的时候还需要带上–link rabbit01:rabbit01 建议相同主机名字在任何地方都一样</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -h rabbit01 -p 5673:5672 -p 15673:15672 --name rabbit01 rabbitmq:3.6.5-management</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -h rabbit02 -p 5674:5672 -p 15674:15672 --name rabbit02 -- link rabbit01:rabbit01 rabbitmq:3.6.5-management</span><br></pre></td></tr></table></figure><p><code>跨主机搭建时需要搭好本地dns映射,详情请见上文</code></p><ol start="3"><li>统一/var/lib/rabbitmq下的<strong>隐藏文件</strong>.erlang.cookie</li><li>重启所有服务</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker restart rabbit01</span><br><span class="line">docker restart rabbit02</span><br><span class="line">docker restart rabbit03</span><br></pre></td></tr></table></figure><ol start="3"><li>进入除主机以外的节点</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br><span class="line">(rabbitmqctl stop会将Erlang虚拟机关闭,rabbitmqctl stop_app制只关闭RabbitMQ服务)</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl join_cluster rabbit@node1(节点名)(下一个加入上一个1&lt;-2&lt;-3)</span><br><span class="line">rabbit start_app(只启动应用服务)</span><br></pre></td></tr></table></figure><ol start="6"><li>配置完成</li></ol><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210803214034198.png" alt="image-20210803214034198"></p><h3 id="在普通集群的基础上搭建高可用的镜像集群"><a href="#在普通集群的基础上搭建高可用的镜像集群" class="headerlink" title="在普通集群的基础上搭建高可用的镜像集群"></a>在普通集群的基础上搭建高可用的镜像集群</h3><ol start="7"><li>指定队列策略</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy [-p &lt;vhost&gt;] [--priority &lt;priority&gt;] [--apply-to &lt;apply-to&gt;] &lt;name&gt; &lt;pattern&gt;  &lt;definition&gt;</span><br></pre></td></tr></table></figure><blockquote><p>参数详解</p></blockquote><ul><li><p>-p Vhost:可选,针对指定vhost下的queue进行设置</p></li><li><p>Name: policy的名称,自定义</p></li><li><p>Pattern: queue的匹配模式(正则)</p><ul><li><code>^开头$结尾</code></li></ul></li><li><p>Definition: 镜像定义包含三部分</p><blockquote><p>ha-mode,ha-params,ha-sync-mode</p></blockquote><ul><li>ha-mode:指明镜像队列的模式,有效值为all/exactly/nodes<ul><li>all:集群中所有节点(slave)上进行镜像</li><li>exactly:指定个数的节点(slave)上进行镜像,节点个数由ha-params指定</li><li>nodes:在指定节点(slave)上进行镜像,节点名称通过ha-params指定</li></ul></li><li>ha-params:ha-mode模式需要用到的参数</li><li>ha-sync-mode:继进行队列中消息同步的方式,有效值为automatic和manual</li></ul></li><li><p>priority:可选参数,policy的优先级</p></li><li><p>查看当前策略</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl list_policies</span><br></pre></td></tr></table></figure></li><li><p>添加策略</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy -p / policy01 <span class="string">&#x27;^mirror&#x27;</span> <span class="string">&#x27;&quot;&#123;&quot;ha-mode“:”all“,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&quot;&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Haproxy实现负载均衡"><a href="#Haproxy实现负载均衡" class="headerlink" title="Haproxy实现负载均衡"></a>Haproxy实现负载均衡</h2><ul><li><p>为什么要实现负载均衡</p><ul><li>编程时绑定一个端口,需要使用反向代理实现负载均衡</li></ul></li><li><p>nginx,lvs,haproxy</p></li></ul><p>  <img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210803220334012.png" alt="image-20210803220334012"></p><h2 id="Federation-Exchange"><a href="#Federation-Exchange" class="headerlink" title="Federation Exchange"></a>Federation Exchange</h2><p><code>https://blog.csdn.net/qq_34939489/article/details/88786266</code></p><p><code>https://blog.csdn.net/qq_39669058/article/details/102802427</code></p><p><code>https://blog.csdn.net/XinhuaShuDiao/article/details/104400834/?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.control&amp;spm=1001.2101.3001.4242</code></p><ul><li><p>联邦交换机</p><ul><li>为什么使用:两台rabbitmq的地理位置相差甚远,需要同步数据</li><li>联邦是为了远程接收,跨域集群</li></ul></li><li><p>搭建步骤</p><ul><li>在<strong>每个节点</strong>上开启federation相关插件(自带)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_federation</span><br><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_federation_management</span><br></pre></td></tr></table></figure><ul><li>不需要重新启动</li></ul></li><li><p>原理</p><ol><li>先准备好下游节点的交换机</li><li>在downstream配置upstream</li><li>配置策略</li></ol></li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210803221318480.png" alt="image-20210803221318480"></p><p>​        </p><h2 id="Federation-Queue"><a href="#Federation-Queue" class="headerlink" title="Federation Queue"></a>Federation Queue</h2><ul><li><p>联邦队列</p><ul><li>控页在多个Broker节点(或者集群)之间为单个队列提供均衡负载功能。一个联邦队列可以连接一个或者多个上游队列(upstream queue),并从这些上游队列中获取消息以满足本地消费者消费信息的需求</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210803222352591.png" alt="image-20210803222352591"></p></li></ul><h2 id="Shovel"><a href="#Shovel" class="headerlink" title="Shovel"></a>Shovel</h2><p>​    Federation具备的数据转发功能类似,Shovel够可靠,持续地从一个Broker中的队列(作为源端,source)拉取数据并转发至另一个broker中的交换器(目的端,destination)。作为源端的队列和作为目的端的交换器可以同时位与同一个Broker,也可以位于不同的Broker上。Shovel可以翻译为”铲子”。Shovel行为就像优秀的客户端应用程序能够负责连接源和目的地、负责消息的读写及负责连接失败问题的处理</p><ul><li><p>原理</p><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210803223022820.png" alt="image-20210803223022820"></p></li><li><p>搭建步骤</p><ul><li>开启插件(需要的机器都开启)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_shovel</span><br><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_shovel_management</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> middleware </category>
          
          <category> mq </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rabbitmq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式应用部署与环境构建-docker</title>
      <link href="2021/07/31/docker/"/>
      <url>2021/07/31/docker/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><ul><li>什么是docker<ul><li>新一代容器技术</li><li>开源的应用容器引擎,基于Go语言并遵从Apache2.0协议开源。Docker可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中</li><li>docker提供了基于进程级别的隔离方案</li><li>C/S架构,使用docker需要用docker-cli连接docker-server</li></ul></li></ul><h1 id="Docker的安装"><a href="#Docker的安装" class="headerlink" title="Docker的安装"></a>Docker的安装</h1><ul><li><p>docker引擎支持主流操作系统</p><ol><li><p>docker在windows系统安装</p><p> <a href="https://desktop.docker.com/win/stable/amd64/Docker%20Desktop%20Installer.exe?utm_source=docker&amp;utm_medium=webreferral&amp;utm_campaign=dd-smartbutton&amp;utm_location=header">https://desktop.docker.com/win/stable/amd64/Docker%20Desktop%20Installer.exe?utm_source=docker&amp;utm_medium=webreferral&amp;utm_campaign=dd-smartbutton&amp;utm_location=header</a></p><ul><li>使用,开启Hyper-v(若版本为v1903及以上则无需开启)</li></ul></li><li><p>docker在Linux安装</p><ul><li><p>bash安装(通用所有平台)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//从官方获取脚本文件</span><br><span class="line">curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="line">//从阿里云下载</span><br><span class="line">sudo sh get-docker.sh --mirror Aliyun</span><br></pre></td></tr></table></figure></li></ul></li></ol></li><li><p>docker启动服务</p><ul><li>systemctl status docker(查看状态)</li><li>systemctl status start|stop|restart docker</li></ul></li><li><p>检测docker启动成功</p><ul><li>docker info</li></ul></li><li><p>配置docker开机自启动</p><ul><li>systemctl enable docker</li></ul></li><li><p>建立docker用户组并使用root用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo groupdadd docker</span><br><span class="line">sudo usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure></li><li><p>重启docker服务</p></li></ul><h1 id="Docker核心概念及架构"><a href="#Docker核心概念及架构" class="headerlink" title="Docker核心概念及架构"></a>Docker核心概念及架构</h1><h2 id="镜像-images"><a href="#镜像-images" class="headerlink" title="镜像 images"></a>镜像 images</h2><ul><li>定义:一个镜像代表着一个软件 如:redis镜像,mysql镜像,nginx镜像</li><li>特点:只读</li></ul><h2 id="容器-container"><a href="#容器-container" class="headerlink" title="容器 container"></a>容器 container</h2><ul><li>定义:基于某个镜像运行一次就是生成一个程序实例,一个程序实例称之为一个容器</li><li>特点:可读可写</li></ul><h2 id="仓库-repository"><a href="#仓库-repository" class="headerlink" title="仓库 repository"></a>仓库 repository</h2><ul><li><p>用来存储docker中所有镜像具体位置 </p></li><li><p>远程仓库:docker在全世界范围维护的一个唯一远程仓库</p><ul><li>仓库web界面</li><li>offcial官方镜像</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/docker-1.png" alt="image-20210728104815614"></p></li><li><p>本地仓库:当前自己及其中下载镜像存储位置</p></li><li><p>命令</p><ul><li>pull 拉取镜像</li><li>run 启动镜像为容器 -it 启动容器时直接进入bash</li></ul></li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/docker-2.png" alt="image-20210728105541778"></p><ul><li><p>docker下载镜像的加速设置</p><ol><li>安装完成docekr之后设置docker下载时加速服务器</li><li>注册阿里云账号</li><li>产品搜索容器服务-&gt;容器镜像服务</li></ol><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/docker-3.png" alt="image-20210728111146059"></p><ol start="4"><li>docker info命令查看</li></ol><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/docker-4.png" alt="image-20210728111413128"></p></li><li><p>docker入门案例</p><ul><li>docker rum hello-world</li><li>总结: <ul><li>docker run  [image],根据run后面镜像运行一个容器</li><li>在运行之前先在自己本地仓库中查找对应的镜像,找到直接使用,找不用去远程拉取image</li></ul></li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/docker-5.png" alt="image-20210728113024338"></p></li></ul><h1 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h1><h2 id="辅助命令"><a href="#辅助命令" class="headerlink" title="辅助命令"></a>辅助命令</h2><ul><li>查看docker引擎以及docker帮助命令<ul><li>docker info 展示docker信息(版本,状态,容器 等等)</li><li>docker version 输出版本,保活server和cli版本号</li><li>docker –help || docker查看docke所有帮助命令</li><li>docker执行命令格式 docker [options] command(具体命令)</li></ul></li></ul><h2 id="Images镜像命令"><a href="#Images镜像命令" class="headerlink" title="Images镜像命令"></a>Images镜像命令</h2><ul><li><p>查看本地仓库中存在哪些镜像</p><ul><li>docker images <ul><li>镜像有一个唯一的镜像ID,很长,只展示了部分</li><li>CREATED 是该镜像在中央仓库创建时间</li></ul></li></ul><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/docker-6.png" alt="image-20210728151812176"/><ul><li>docker images [imageName]:[tag]    列出imageName镜像</li><li>docker images -a :显示所有镜像</li><li>docker images -q:只显示镜像id</li></ul></li><li><p>在命令端搜索中央仓库中的镜像</p><ul><li>docker search [options] [image]</li></ul></li><li><p>下载新的镜像</p><ul><li>docker pull [imageName]:[tag] 根据版本号拉取 <ul><li>docker pull mysql:8.0</li></ul></li><li>docker pull [imageName]:@DIGEST(摘要)<ul><li>docker pull redis:DIGEST:sha…</li></ul></li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/docker-7.png" alt="image-20210728152416358"></p></li><li><p>删除镜像</p><ul><li>doccker <strong>image</strong> rm [imageName]:[tag] | [image id]<ul><li>简写 docker rmi [image]</li></ul></li><li>docker image rm -f 强制删除:删除镜像以及镜像的容器<ul><li> 简写 docker rmi -f [image]</li></ul></li><li>docker rmi -f $(docker images -q)<ul><li>删除所有的镜像</li><li>先执行$里面的命令</li></ul></li></ul></li><li><p>将打包tar镜像文件导入到自己的docker仓库</p><ul><li>docker load -i [fileName]:-i代表镜像</li></ul></li></ul><h2 id="Containner容器命令-相当于一个小的操作系统"><a href="#Containner容器命令-相当于一个小的操作系统" class="headerlink" title="Containner容器命令:相当于一个小的操作系统"></a>Containner容器命令:相当于一个小的操作系统</h2><ul><li><p>通过镜像运行一个容器</p><ul><li><p>docker run [imageName]:[tag] | [imageID]</p><ul><li>在docker内run,外界无法访问,需要映射</li></ul></li><li><p>docker run -p [宿主机端口]:[docker端口] [imageName]:[tag] | [imageID]</p><ul><li>宿主机端口与容器中端口进行映射</li><li>-p可以映射多个端口</li></ul></li><li><p>docker run -d -p [宿主机端口]:[docker端口] [imageName]:[tag] | [imageID]</p><ul><li>-d 后台运行</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210728161130178.png" alt="image-20210728161130178"></p></li><li><p>docker run -d -p [宿主机端口]:[docker端口] –name [name] 容器名称 [imageName]:[tag] | [imageID] </p><ul><li>启动容器 指定名称 后台运行 端口映射</li></ul></li></ul></li><li><p>查看当前正在运行的容器</p><ul><li>docker ps 查看正在运行的容器<ul><li>container id:容器id</li><li>image基于image</li><li>comman 容器内执行命令</li><li>created 创建时间</li><li>status 当前状态</li><li>ports 容器服务监听的端口</li><li>name 容器名字:如果run没有指定名字则会自己创建一个</li></ul></li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210728155817618.png" alt="image-20210728155817618"></p><ul><li>docker ps -a 查看所有容器 (运行 &amp; 非运行)</li><li>docker ps -q 查看正在运行的容器id</li></ul></li><li><p>停止 重启容器命令</p><ul><li>docker start [containerName] | [containnerId] 开启容器</li><li>docker restart [containerName] | [containnerId] 重启容器</li><li>docker stop [containerName] | [containnerId] 正常停止容器运行</li><li>docker kill [containerName] | [containnerId] 立即停止容器运行</li><li>docker 的容器id可以简写,只要不冲突</li></ul></li><li><p>删除容器</p><ul><li>docker rm [containerName] | [containnerId] 删除容器<ul><li>对比删除镜像 docker rmi [imageName]:[tang] | [imageID]</li></ul></li><li>docker rm -f [containerName] | [containnerId] 删除正在运行的容器<ul><li>对比删除镜像 docker rmi -f [imageName]:[tang] | [imageID]</li></ul></li><li>docker rm -f $(docker ps -aq) 删除所有容器</li></ul></li><li><p>查看容器内服务运行日志</p><ul><li>docker logs [containerName] | [containnerId] 查看容器日志</li><li>docker logs -f [containerName] | [containnerId] 跟踪容器日志</li><li>docker logs -t [containerName] | [containnerId] 加入时间戳</li><li>docker logs –tail n(显示日志的最后行数)</li></ul></li><li><p>查看容器内进程</p><ul><li>docker top [containerName] | [containnerId] 查看容器内的进程</li></ul></li><li><p>与容器内部进行交互:需要容器运行</p><ul><li>docker exec -it [containerName] | [containnerId] bash：进入容器内部,并与容器内部的终端进行交互<ul><li>bash里面只装了运行容器最小的依赖,复杂命令不可用</li><li>ls,cd,exit</li></ul></li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210728165432501.png" alt="image-20210728165432501"></p></li><li><p>宿主机与容器的文件交互:不需要容器运行</p><ul><li>容器 =&gt; 宿主机<ul><li>docker cp [containerName] | [containnerId]:容器内资源路径 宿主机路径<ul><li>可以复制文件,也可以复制目录</li></ul></li></ul></li><li>宿主机 =&gt; 容器<ul><li>docker cp 宿主机路径 [containerName] | [containnerId]:容器内资源路径</li></ul></li></ul></li><li><p>查看容器内部细节</p><ul><li>docker inspect [containerName] | [containnerId]</li></ul></li><li><p>数据卷 volumes</p><ul><li><p>实现宿主机系统与容器之间的文件共享</p></li><li><p>容器启动之前 | 启动的时候</p></li><li><p>docker run -d -p 8080:8080 –name tomcat01 -v 宿主机目录(绝对路径):容器内目录  [contrainer] </p><ul><li>此方式会将容器里面的原数据清空</li></ul></li><li><p>docker run -d -p 8080:8080 –name tomcat01 -v [随便一个数据卷名字]:容器内目录  [contrainer]</p><ul><li>docker会在不存在时自动床啊金此数据卷同时自动映射宿主机中的此目录同时会保留容器内目录的文件</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210728173423132.png" alt="image-20210728173423132"></p></li><li><p>数据卷用于持久化用户的数据至宿主机,如果只保存在docker里面容易丢失</p></li></ul></li><li><p>将容器打包成一个新的镜像</p><ul><li>docker commit -m “描述信息” -a “作者信息” [containerName] | [containnerId] 打包的镜像名称:标签</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210728211343882.png" alt="image-20210728211343882"></p><ul><li>打包过程的容器会暂时暂停</li></ul></li><li><p>将镜像备份出来</p><ul><li>docker save 镜像名称:Tag -o [savePath/filename] (.tar)</li><li>docker load -i filename:加载镜像文件</li></ul></li></ul><h1 id="镜像原理"><a href="#镜像原理" class="headerlink" title="镜像原理"></a>镜像原理</h1><h2 id="镜像是什么"><a href="#镜像是什么" class="headerlink" title="镜像是什么"></a>镜像是什么</h2><ul><li>镜像是一种轻量级,可执行的独立软件包,用来打包软件运行环境基于运行环境开发的软件,它包含运行某个软件所需的所有内容,包括代码、运行时所需的库、环境变量和配置文件</li></ul><h2 id="镜像为什么这么大"><a href="#镜像为什么这么大" class="headerlink" title="镜像为什么这么大?"></a>镜像为什么这么大?</h2><ul><li>原因:一个软件镜像不仅仅是原来软件包,包含软件包所需的操作系统依赖 软件自身依赖 以及自身软件包组成</li></ul><h2 id="为什么docker镜像采用分层镜像原理"><a href="#为什么docker镜像采用分层镜像原理" class="headerlink" title="为什么docker镜像采用分层镜像原理"></a>为什么docker镜像采用分层镜像原理</h2><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210728215537893.png" alt="image-20210728215537893"></p><ul><li>便于抽取公共镜像(基础镜像),而不需要每次都pull相同的镜像</li><li>docker在设计镜像时每一个镜像都是由n个镜像共同组成</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210728220028778.png" alt="image-20210728220028778"></p><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210728221405550.png" alt="image-20210728221405550"></p><h2 id="UnionFs-Union-File-System-联合文件系统"><a href="#UnionFs-Union-File-System-联合文件系统" class="headerlink" title="UnionFs Union File System 联合文件系统"></a>UnionFs Union File System 联合文件系统</h2><ul><li>UnionFs是一种分层,轻量级并且高性能的文件系统,它支持对文件系统的修改作为一次提交来一层层的叠加,同时可以将不同目录挂载到同一个虚拟文件系统下。Union文件系统时Docker镜像的基础。这种文件系统忒行:就是一次同时加载多个文件系统,但从外面看起来,只能看到一个文件系统,联合 加载会把各层文件系统叠加起来,这样最终的文件系统会包含所有底层的文件和目录</li><li>为什么采用UnionFS:提高复用性</li></ul><h2 id="Docker镜像原理"><a href="#Docker镜像原理" class="headerlink" title="Docker镜像原理"></a>Docker镜像原理</h2><ul><li>bootfs:bootloader和kernel,bootloader引导加载kernel</li><li>rootfs</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210728220931321.png" alt="image-20210728220931321"></p><h2 id="Docker分层原因"><a href="#Docker分层原因" class="headerlink" title="Docker分层原因"></a>Docker分层原因</h2><ul><li>好处<ul><li>采用分层机制实现基础层<strong>资源共享</strong>,从而减少docker仓库的整体体积</li></ul></li></ul><h1 id="Docker中容器与操作系统通信"><a href="#Docker中容器与操作系统通信" class="headerlink" title="Docker中容器与操作系统通信"></a>Docker中容器与操作系统通信</h1><h2 id="Docker为什么提供网络功能"><a href="#Docker为什么提供网络功能" class="headerlink" title="Docker为什么提供网络功能"></a>Docker为什么提供网络功能</h2><ul><li>Docker允许通过外部容器或容器互联的方式提供服务</li><li>为了使docker容器间能够通信</li></ul><h2 id="Docker容器与操作系统通信机制"><a href="#Docker容器与操作系统通信机制" class="headerlink" title="Docker容器与操作系统通信机制"></a>Docker容器与操作系统通信机制</h2><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210729112754846.png" alt="image-20210729112754846"></p><ul><li>veth-pair就是一堆虚拟设备接口,他们都是成对出现的,一段连着协议,一段彼此想来你</li><li>正因为有这个特性,evth-pair充当一个桥梁,OVS的链接,都是使用veth-pair技术</li></ul><h2 id="Docker网络使用"><a href="#Docker网络使用" class="headerlink" title="Docker网络使用"></a>Docker网络使用</h2><ul><li><p>一般在使用docker网桥(bridge)实现容器与容器通信时,都是站在一个应用角度进行容器通信</p></li><li><p>一个项目一个网桥,如果多个应用一个网桥会争抢网桥带宽</p></li><li><p>查看docker网桥配置</p><ul><li>docker network ls</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210729105117056.png" alt="image-20210729105117056"></p></li><li><p>创建自定义网桥</p><ul><li>docker network create [brigeName] ===&gt; docker create -d bridge [brigeName]<ul><li>-d用于说明使用什么配置方式</li><li>不使用-d默认使用brige方式</li></ul></li><li>docker run -d -p 8080:8080 –network [brigeName] –name [customerName] [imageName]:[tag]</li><li><strong>指定</strong>了网桥之后之后在另一个容器可以用另一个容器的容器名访问另一容器(需要在同一个网桥),默认brige无法使用映射<ul><li>ip地址与容器之间形成了映射(也需要家端口)</li></ul></li></ul></li><li><p>更改网桥之后的网段</p><ul><li><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210729105954252.png" alt="image-20210729105954252"></li></ul></li><li><p>未更改网桥之后的网关</p><ul><li><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210729110241243.png" alt="image-20210729110241243"></li></ul></li><li><p>删除网桥</p><ul><li>docker network rm [brigeName]</li></ul></li><li><p>查看网桥ip地址</p><ul><li>docker inspect</li></ul></li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210729111938128.png" alt="image-20210729111938128"></p><ul><li><p>将一个容器与加入到另一个网桥(一个容器多个ip)</p><ul><li>docker network connect NETWORK CONTAINER</li></ul></li><li><p>注意</p><ul><li>使用Docker run 指定 –network网桥时网桥必须存在</li></ul></li></ul><h1 id="数据卷详解"><a href="#数据卷详解" class="headerlink" title="数据卷详解"></a>数据卷详解</h1><h2 id="数据卷作用"><a href="#数据卷作用" class="headerlink" title="数据卷作用"></a>数据卷作用</h2><ul><li>用来实现容器与宿主机之间数据共享</li></ul><h2 id="数据卷特点"><a href="#数据卷特点" class="headerlink" title="数据卷特点"></a>数据卷特点</h2><ul><li><p>数据卷可以在容器之间共享和重用</p></li><li><p>对数据卷的修改会立即影响到容器</p></li><li><p>container和host之间对数据卷的修改会互相影响</p></li><li><p><strong>防止</strong>容器对数据卷的修改,在-v的时候:ro:read only</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docekr run -d -p 8090:8080 --name tomcat09 -v aa:&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps:ro tomcat:....</span><br></pre></td></tr></table></figure></li><li><p>对数据卷的更新修改,不会影响镜像</p></li><li><p>数据卷默认会一直存在,即使容器被删除</p></li></ul><h2 id="数据卷操作"><a href="#数据卷操作" class="headerlink" title="数据卷操作"></a>数据卷操作</h2><ul><li>自定义数据卷目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v 绝对路径:容器内路径</span><br></pre></td></tr></table></figure><ul><li>自动创建数据卷</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v 卷名(随便起):容器内路径</span><br></pre></td></tr></table></figure><h2 id="docker操作数据卷指令"><a href="#docker操作数据卷指令" class="headerlink" title="docker操作数据卷指令"></a>docker操作数据卷指令</h2><ul><li>查看数据卷 volume<ul><li>docker volume ls</li></ul></li><li>查看某个数据卷的细节<ul><li>docker volume inspect [volumeName]</li></ul></li><li>创建数据卷<ul><li>docker volume create [volumeName]</li></ul></li><li>删除数据卷<ul><li>删除单个<ul><li>docker volume rm</li></ul></li><li>删除所有<ul><li>docker volume prune</li></ul></li></ul></li></ul><h1 id="Docker核心架构"><a href="#Docker核心架构" class="headerlink" title="Docker核心架构"></a>Docker核心架构</h1><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210729122110753.png" alt="image-20210729122110753"></p><h1 id="部分软件安装"><a href="#部分软件安装" class="headerlink" title="部分软件安装"></a>部分软件安装</h1><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><ul><li>docker hub寻找镜像</li><li>找到具体版本</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210729122742122.png" alt="image-20210729122742122"></p><ul><li><p>使用镜像</p><ul><li><p>基本启动mysql服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name some-mysql -e MYSQL_ROOT_PASSWORD&#x3D;my-secret-pw -d mysql:tag</span><br></pre></td></tr></table></figure><ul><li>-e 是携带环境变量    </li><li>MYSQL_ROOT_PASSWORD=xxxx代表给root指定密码</li></ul></li><li><p>启动一个mysql使用数据卷将数据持久化到宿主机系统,指定名字</p><ul><li>通过dockerhub<strong>描述</strong>的值mysql存储数据文件目录放置在哪</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name some-mysql -v &#x2F;my&#x2F;own&#x2F;datadir:&#x2F;var&#x2F;lib&#x2F;mysql -e MYSQL_ROOT_PASSWORD&#x3D;my-secret-pw -d mysql:tag</span><br></pre></td></tr></table></figure><ul><li>通过dockerhub描述的值mysql配置文件目录放置在哪</li></ul></li><li><p>启动一个mysql使用数据卷将数据持久化到宿主机系统,以修改之后配置文件启动,指定名字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3306:3306 -v mysqldata:&#x2F;var&#x2F;lib&#x2F;mysql -e MYSQL_ROOT_PASSWORD&#x3D;[passwod] -v mysqlconf:&#x2F;etc&#x2F;mysql mysql:8.0.20</span><br></pre></td></tr></table></figure><ul><li>新版本使用conf.d修改配置文件</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210729153206755.png" alt="image-20210729153206755"></p></li></ul></li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210729153132848.png" alt="image-20210729153132848"></p><h2 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h2><ul><li><p>下载tomcat</p></li><li><p>启动tomcat</p><ul><li>部署web应用在容器中目录为 /usr/local/tomcat/webapps 配置文件 /usr/local/tomcat/conf</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8080:8080 -v apps:&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps --name tomcat01 tomcat:9.0.50-jdk11-adoptopenjdk-hotspot</span><br></pre></td></tr></table></figure><ul><li>修改配置文件,并将应用目录通过数据卷挂载到宿主机系统:修改配置文件之后需要另起炉灶<ul><li>如果重启,虽然容器内部能够修改端口,但是映射不会改变</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8081:8080 -v apps:&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps -v tomcatconfig:&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;conf --name tomcat02 tomcat:9.0.50-jdk11-adoptopenjdk-hotspot</span><br></pre></td></tr></table></figure></li></ul><h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><ul><li><p>下载redis镜像</p></li><li><p>启动redis</p><ul><li>普通启动</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 6379:6379 redis:[tag]</span><br></pre></td></tr></table></figure><ul><li>开启redis持久化<ul><li>dump持久化没有被开启</li><li>appendonly 存储在 volume /data目录 (开启持久化之后,持久化生成的aof文件) <strong>appendonly只能加在末尾</strong></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 6379:6379 -v redisdata:&#x2F;data --name docker_redis redis --appendonly yes</span><br></pre></td></tr></table></figure><ul><li>修改redis配置文件,以配置文件方式启动 先配置数据卷 再配置redis.conf</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v &#x2F;myredis&#x2F;conf:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis --name myredis redis redis-server &#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf</span><br></pre></td></tr></table></figure></li></ul><h2 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h2><h1 id="Dockerfile-镜像构建文件"><a href="#Dockerfile-镜像构建文件" class="headerlink" title="Dockerfile 镜像构建文件"></a>Dockerfile 镜像构建文件</h1><h2 id="什么是DockerFile"><a href="#什么是DockerFile" class="headerlink" title="什么是DockerFile"></a>什么是DockerFile</h2><ul><li>用来帮助我们自己构建一个自定义镜像,因此dockerfile也称为镜像构建文件 描述文件</li></ul><h2 id="为什么要存在Dokerfile"><a href="#为什么要存在Dokerfile" class="headerlink" title="为什么要存在Dokerfile"></a>为什么要存在Dokerfile</h2><ul><li>问题:再dockerhub中官方提供很多镜像阴茎能满足我们的所有服务了,为什么还需要自定义镜像?<ul><li>核心作用:日后用户可以将自己的应用打包成镜像,这样就可以让应用进行容器运行</li></ul></li></ul><h2 id="Dockerfile构建镜像原理"><a href="#Dockerfile构建镜像原理" class="headerlink" title="Dockerfile构建镜像原理"></a>Dockerfile构建镜像原理</h2><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210729195015756.png" alt="image-20210729195015756"></p><h2 id="Dockerfile使用"><a href="#Dockerfile使用" class="headerlink" title="Dockerfile使用"></a>Dockerfile使用</h2><ul><li><p>Dockerfile所在目录是一个context上下文目录,build时会将该上下文目录的所有文件打包</p><ul><li>打包命令 docker build -t [name]:[tag] dockerfileName</li></ul></li><li><p>常用命令</p></li></ul><table><thead><tr><th>保留字</th><th>作用</th></tr></thead><tbody><tr><td>FROM</td><td>当前镜像是基于哪个镜像(<strong>第一个指令必须是FROM必写,包含kernel</strong>)</td></tr><tr><td>MAINTAINER</td><td>镜像维护者的姓名和邮箱地址</td></tr><tr><td>RUN</td><td><strong>构建</strong>镜像时需要运行的指令</td></tr><tr><td>EXPOSE</td><td>当前容器对外暴露出的端口号</td></tr><tr><td>WORKDIR</td><td>指定在创建容器后,终端默认登陆进来的工作目录,一个落脚点</td></tr><tr><td>ENV</td><td>用来在构建镜像过程中设置环境变量</td></tr><tr><td>ADD</td><td>将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar包</td></tr><tr><td>COPY</td><td>类似于ADD,拷贝文件和目录到镜像中,将从构建上下文目录中&lt;原路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路径&gt;位置</td></tr><tr><td>VOLUME</td><td>不指定明确挂载会默认匿名挂载容器数据卷,用于数据保存和持久化工作</td></tr><tr><td>CMD</td><td>指定一个容器<strong>启动</strong>时要运行的命令,Dockerfile中可以有<strong>多个CMD指令,但只有最后一个生效</strong>,CMD会被docker run之后的参数替换</td></tr><tr><td>ENTRYPOINT</td><td>指定一个容器<strong>启动</strong>时要运行的命令,ENTRYPOINT目的和CMD一样,都是在指定容器启动程序及其参数,设置固定命令</td></tr></tbody></table><h2 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h2><ul><li><p>FROM</p><ul><li>FROM <image></li><li>FROM <image>:<tag></li><li>FROm <image>:@Dist</li></ul></li><li><p>MAINTAINER:官方不推荐使用</p></li><li><p>RUN</p><ul><li>构建FROM镜像时使用的指令</li><li>容器无法使用网络</li></ul><p><a href="https://blog.csdn.net/yelllowcong/article/details/78295600">https://blog.csdn.net/yelllowcong/article/details/78295600</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUN yum install -y vim ||</span><br><span class="line">&#x2F;&#x2F;json字符串写法</span><br><span class="line">RUN [&#39;yum&#39;,&#39;install&#39;,&#39;-y&#39;,&#39;vime&#39;]</span><br></pre></td></tr></table></figure><ul><li>临时命令,只会在镜像容器化时启动</li></ul></li><li><p>EXPOSE指令</p><ul><li>容器对外暴露端口,如果不暴露端口不能加-p宿主机映射</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210729212756532.png" alt="image-20210729212756532"></p></li><li><p>WORKDIR</p><ul><li>用来为Dockerfile中的任何RUN、CMD、ENTRYPOINT和ADD指令设置工作目录.如果WORKDIR不存在,即使它没有在任何后续Dockerfile指令中使用它也将被创建</li><li>指定进入容器的目录或者命令执行的目录,如果没有会被<strong>自动创建</strong></li><li>可以指定多个WORKDIR,如果多个WORKDIR且有相对路径,则该相对路径是相对于上个路径</li><li>WORKDIR可以使用双引号包含路径,不能使用json风格</li></ul></li><li><p>ADD</p><ul><li>作用与COPY差不多,但是ADD可以解析压缩包和URL</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD URL containerPath</span><br></pre></td></tr></table></figure><ul><li>可以改名 ADD filename.jar app.jar</li></ul></li><li><p>COPY</p><ul><li>如果有文件需要在打包时添加,<strong>COPY只能使用绝对路径</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy file containerPath</span><br></pre></td></tr></table></figure><ul><li>支持json字符串</li></ul></li><li><p>VOLUME:创建镜像挂载点,此挂载点无法指定主机上对应的目录</p><ul><li><p>启动容器自动挂载</p></li><li><p>使用之后可以取代-v操作</p></li><li><p>docker run命令的-v标识创建的挂载点只能对创建的容器有效。</p></li><li><p>通过dockerfile的 VOLUME 指令可以在镜像中创建挂载点，这样只要通过该镜像创建的容器都有了挂载点。</p><p>还有一个区别是，通过 VOLUME 指令创建的挂载点，无法指定主机上对应的目录，是自动生成的。</p></li></ul></li><li><p>ENY</p><ul><li>构造镜像环境变量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV &lt;key&gt; &lt;value&gt;</span><br><span class="line">ENV &lt;key&gt;&#x3D;&lt;value&gt;</span><br></pre></td></tr></table></figure><ul><li>可以定义自己的环境变量,比如公用的地址,引用时加上$引用符</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM ....</span><br><span class="line">ENV BASE_DIR &#x2F;data&#x2F;bb</span><br><span class="line">WORKDIR $BASE_DIR</span><br></pre></td></tr></table></figure></li><li><p>CMD</p><ul><li>CMD只有最后一个生效</li><li>CMD配置的指令会被用户覆盖</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ....</span><br><span class="line">CMD ls &#x2F;dir</span><br><span class="line">&#x2F;&#x2F;run覆盖掉cmd里的命令</span><br><span class="line">RUN image echo &quot;i love cmd&quot;</span><br></pre></td></tr></table></figure></li><li><p>ENTRYPOINT</p><ul><li>ENTRYPOINT也可以覆盖</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run image --entrypoint&#x3D;echo &quot;i love entrypoint&quot;</span><br></pre></td></tr></table></figure><ul><li>用于固定写死的东西</li></ul></li><li><p>CMD与ENTRYPOINT配合使用为镜像custpmer化</p><ul><li><p>如果在Dockerfile中CMD与ENTRYPOINT都存在，则CMD中的指令将会被作为ENTRYPOINT中的参数，即这时候CMD里的指令会失去它的作用，只是作为一个参数（可以理解为就是字符串）了，而且这个时候docker run后的参数指令依然会覆盖CMD，但是也会失去他本身的作用，仅仅是作为参数（字符串）提供给ENTRYPOINT中的命令</p></li><li><p>简单来说</p><ul><li>CMD与ENTRYPOINT同时出现CMD会作为ENTRYPOINT的参数</li><li>最好使用json模式覆盖,shell可能无法覆盖</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ....</span><br><span class="line">#ENTRYPOINT ls &#x2F;dir</span><br><span class="line">#CMD &#x2F;bb</span><br><span class="line">ENTRYPOINT [&quot;ls&quot;,&quot;dir&quot;]</span><br><span class="line">CMD [&quot;dir&quot;]</span><br></pre></td></tr></table></figure><ul><li>CMD里面即使用户自定义ENTRYPOINT也会显示,如果想要ENTRYPOINT不显示,则将其参数设置为空<strong>ENTRYPOINT只写命令,CMD用于传参</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM ...</span><br><span class="line">ENTRYPOINT [&quot;ls&quot;]</span><br><span class="line">CMD [&quot;dir&quot;]</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="IDEA中的DOCKERFILE插件"><a href="#IDEA中的DOCKERFILE插件" class="headerlink" title="IDEA中的DOCKERFILE插件"></a>IDEA中的DOCKERFILE插件</h2><ul><li>plugins安装docker插件即可使用</li><li>安装插件之后edit Dockerfile文件会有提示</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210730111700721.png" alt="image-20210730111700721"></p><h2 id="IDEA远程连接SFTP"><a href="#IDEA远程连接SFTP" class="headerlink" title="IDEA远程连接SFTP"></a>IDEA远程连接SFTP</h2><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210730111933079.png" alt="image-20210730111933079"></p><h1 id="Docker-compose使用"><a href="#Docker-compose使用" class="headerlink" title="Docker compose使用"></a>Docker compose使用</h1><h2 id="什么是compose"><a href="#什么是compose" class="headerlink" title="什么是compose"></a>什么是compose</h2><ul><li>Compose是Docker官方的开源项目,负责实现对Docker<strong>容器集群</strong>的快速编排,代码目前在github上开源</li><li>Compose定位是定义和运行多个Docker容器的应用,同时可以对多个容器进行编排Compose无法进行资源调度,需要交给k8s(kubernetes)<ul><li>使用Dockerfile模板文件,可以很方便定义一个单独的应用容器，然而在日常工作中,经常会碰到需要多个容器相互配合来完成某项任务的情况,比如web项目需要jar包.mysql,redis,mq,es等等</li><li>Compose恰好满足了这样的需求,它允许用户通过一个单独的docker-compose.yml来定义一组相关联的应用容器为一个Project</li></ul></li></ul><h2 id="compose-核心概念"><a href="#compose-核心概念" class="headerlink" title="compose 核心概念"></a>compose 核心概念</h2><ul><li>服务(service):一个应用的容器,实际上可以包括若干运行相同镜像的容器实例(集群,负载均衡),服务可以存在多个</li><li>项目(project):一组关联的应用容器组成的一个完整业务单元,在’docker-compose.yml’文件中定义,一个docker-compose文件就是一个项目,包含多个服务</li></ul><h2 id="compose下载"><a href="#compose下载" class="headerlink" title="compose下载"></a>compose下载</h2><ul><li><p>compose不在docker引擎里面,需要下载</p></li><li><p>下载docker compose</p><ul><li>下载到 /usr/local/bin里面因为该目录自动配置环境变量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;1.29.2&#x2F;docker-compose-&#96;uname -s&#96;-&#96;uname -m&#96; &gt; &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br></pre></td></tr></table></figure><ul><li>若从github下载,则需改名为docker-compose</li><li>检测 docker-compose -v</li></ul></li></ul><h2 id="compose基本使用"><a href="#compose基本使用" class="headerlink" title="compose基本使用"></a>compose基本使用</h2><ul><li><p>两个重要概念</p><ul><li>项目(Project):有多个服务共同组成一个完整业务单元,定义docker-compose.yml文件中</li><li>服务(service):一个服务对应一个应用容器,在一个项目中可以存在多个服务</li></ul></li><li><p>第一个docker-compose程序</p><ul><li>创建一个docker-compose.yml文件</li><li>在配置文件中定义一个项目存在哪些服务</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210730152040165.png" alt="image-20210730152040165"></p><ul><li>运行docker-compose up 启动这个项目的所有服务,必须保证运行命令的目录存在docker.yml<ul><li>在当前文件夹下运行docker-compose up命令,不需要带path,如果用后台使用-d option</li><li>docker-compose up默认前台启动</li></ul></li></ul></li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210730152911778.png" alt="image-20210730152911778"></p><h2 id="compose命令模板"><a href="#compose命令模板" class="headerlink" title="compose命令模板"></a>compose命令模板</h2><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210730170330859.png" alt="image-20210730170330859"></p><h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><ul><li><p>docker-compose的版本,具体版本与docker engine的对照关系查看下面的链接</p><p>​    <a href="https://blog.csdn.net/whatday/article/details/108865782">https://blog.csdn.net/whatday/article/details/108865782</a></p></li><li><p>3.x合适</p></li></ul><h3 id="services-服务"><a href="#services-服务" class="headerlink" title="services:服务"></a>services:服务</h3><ul><li><p>service-name:加了复数的为数组类型</p><ul><li><p>container_name: boot01 #替换–name</p></li><li><p>image # image</p></li><li><p>build:build可以直接运行Dockerfile而不需要添加镜像,使用build替换image,便于分布式部署,不用事先在本地创建镜像</p><ul><li>context:指定上下文目录,Dockerfile所在目录</li><li>dockerfile:指定Dockerfile文件名字</li><li><strong>可以重复使用一个build,但是每次会创建一个新的镜像</strong></li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/image-20210730190053202.png" alt="image-20210730190053202"></p></li><li><p>ports:映射的端口,最好使用字符串形式 “8080:8080”.yml在 xx:xx时会自动转为60进制 #-p</p></li><li><p>volumes:指定映射,如果为自动映射需要在下面注册 #-v</p></li><li><p>networks:指定网络,需要事先创建或者在下面进行注册 #–network</p></li><li><p>environment:指定环境</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">environment:</span><br><span class="line">  - MYSQL_ROOT_PASSWORD&#x3D;password ||   -带&#x3D;,没-:</span><br><span class="line">  MYSQL_ROOT_PASSWORD: password</span><br></pre></td></tr></table></figure><ul><li>command: 覆盖掉内部命令比如redis</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis:</span><br><span class="line">  container_name: &quot;redis&quot;</span><br><span class="line">  image: redis:latest</span><br><span class="line">  ports:</span><br><span class="line">    - &quot;3306:3306&quot;</span><br><span class="line">  volumes:</span><br><span class="line">    - redisdata:&#x2F;data</span><br><span class="line">  command: &quot;redis-server --appendonly yes&quot;&#x2F;&#x2F;因为redis dockerfile 的 CMD是redis-server,所以可以覆盖</span><br></pre></td></tr></table></figure><ul><li>env_file:从文件中获取环境变量,可以为单独的文件路径或列表,允许我们将配置文件抽离出去,,替代environment,在文件里用key=value写法,支持相对路径,<strong>文件必须以.env结尾</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MYSQL_ROOTPASSWORD&#x3D;password</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql:</span><br><span class="line">  container_name: mymysql</span><br><span class="line">  image: mysql:8.0.20</span><br><span class="line">  env_file: </span><br><span class="line">    - .&#x2F;mymysql.env </span><br></pre></td></tr></table></figure><ul><li>depends_on:代表这个容器必须依赖哪些服务启动之后才能启动,填写services中的<strong>服务名</strong>,<strong>注:并不会等depends_on里的服务完全启动才会启动</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">boot01:</span><br><span class="line">  containner_name: boot01</span><br><span class="line">  image: boot:03</span><br><span class="line">  depends_on:</span><br><span class="line">    - redis</span><br><span class="line">    - mysql</span><br><span class="line">    - rabbitmqqqqq</span><br><span class="line">    - elasticsearchhhhhh</span><br><span class="line">reids: xxx</span><br><span class="line">mysql: xxx</span><br><span class="line">rabbitmqqqqq: xxx</span><br><span class="line">elasticsearchhhhhh: xxx</span><br></pre></td></tr></table></figure><ul><li>healthcheck:心跳检测,通过命令检查容器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">boot01:</span><br><span class="line">  containner_name: boot01</span><br><span class="line">  image: boot:03</span><br><span class="line">  healthcheck:</span><br><span class="line">  test: [&quot;CMD&quot;,&quot;curl&quot;,&quot;-f&quot;,&quot;http:&#x2F;&#x2F;localhost&quot;]</span><br><span class="line">  interval: 1m30s</span><br><span class="line">  timeout: 10s</span><br><span class="line">  retries: 3</span><br></pre></td></tr></table></figure><ul><li>sysctls:配置容器内核参数,elasticsearch</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sysctls:</span><br><span class="line">  net.core.somaxconne: 1024</span><br><span class="line">  net.ipv4.tcp_syncookies: 0</span><br><span class="line">sysctls:</span><br><span class="line">  - net.core.somaxconne&#x3D;1024</span><br><span class="line">  - net.ipv4.tcp_syncookies&#x3D;0</span><br></pre></td></tr></table></figure><ul><li>ulimits:指定容器的ulimits限制值,最大进程数 elasticsearch<ul><li>指定最大进程数为65535,指定文件句柄数位20000(软限制,应用可以随时修改,不能超过硬限制)和40000(系统硬限制,只能root用户提高)</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ulimits:</span><br><span class="line">  nproc: 65535</span><br><span class="line">  nofile:</span><br><span class="line">    soft: 20000</span><br><span class="line">    hard: 40000</span><br></pre></td></tr></table></figure></li></ul><h3 id="volumes-注册数据卷-声明上面服务所使用的自动创建的卷名"><a href="#volumes-注册数据卷-声明上面服务所使用的自动创建的卷名" class="headerlink" title="volumes:注册数据卷 声明上面服务所使用的自动创建的卷名"></a>volumes:注册数据卷 声明上面服务所使用的自动创建的卷名</h3><ul><li>volume-name: <strong>使用的卷名,compose会自动在其前面添加上当前项目的名字</strong>,<ul><li>external:   是否使用指定卷名,需要自己创建</li><li>name: 指定自动创建的名字(每试过,应该可以)</li></ul></li></ul><h3 id="networks-注册网桥"><a href="#networks-注册网桥" class="headerlink" title="networks:注册网桥"></a>networks:注册网桥</h3><ul><li>network-name: <strong>compose会自动在其前面添加上当前项目的名字</strong><ul><li>external</li><li>name:试过,可以</li></ul></li></ul><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><ul><li>虽然networks,volumes会在创建时添加项目名_volume-name,但是在compose里面不在前添加项目名依然生效</li></ul><h2 id="compose中指令-inline"><a href="#compose中指令-inline" class="headerlink" title="compose中指令 inline"></a>compose中指令 inline</h2><h3 id="inline指令与模板指令区别"><a href="#inline指令与模板指令区别" class="headerlink" title="inline指令与模板指令区别"></a>inline指令与模板指令区别</h3><ul><li>inline指令是docker-compose指令的options<ul><li>用来对整个docker-compose.yml对应的<strong>项目</strong>操作,书写docker-compose命令之后命令docker-compose up(指令)</li></ul></li><li>模板指令是docker-compose.yml文件里面的配置</li></ul><h3 id="inline指令-docker-compose"><a href="#inline指令-docker-compose" class="headerlink" title="inline指令:docker-compose"></a>inline指令:docker-compose</h3><ul><li><p>docker-compose [-f=<arg>][COMMAND] –help</p></li><li><p>up 启动compose:启动compose必写</p></li><li><p>[serverName]:指定只启动哪个服务</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up serve02</span><br></pre></td></tr></table></figure><ul><li><p>命令选择</p><ul><li>-f, –file,FILE指定使用Compose模板文件,默认位docker-compose.yml,可以多次指定</li><li>-p,–project-name Name,指定项目名称,默认将使用所在目录名作为项目名</li><li>–x-networking:使用Docker的可拔插网络后端特性</li><li>–x-network-drive DRIVER:指定网络后端的驱动,默认位bridge</li><li>–verbose 输出更多调试信息,要和up配合使用</li><li>–v, –version 打印版本并退出</li></ul></li><li><p>inline指令命令</p><ul><li><p> up: docker-compose up [options] [SERVICE…]</p></li><li><p>该命令尝试自动完成包括构建镜像,(重新)创建服务,启动服务,并关联服务相关容器的一系列操作</p></li><li><p>链接的服务(depends_on)都会被自动启动,除非已经处于运行状态</p></li><li><p>大部分时候都可以直接通过该命令来启动一个项目</p></li><li><p>默认情况,docker-compose up启动的容器都在前台,控制台将会同时打印出所有容器的输出信息,可以很方便调试</p></li><li><p>当通过Ctrl-C停止命令你个时,所有容器将会停止</p></li><li><p>如果<strong>使用docker-compose up -d,将会在后台启动并运行所有容器</strong>,推荐生产环境使用</p></li><li><p>默认情况,如果服务容器已经存在,<strong>docker-compose up 将会尝试停止容器,然后重新创建(保持使用 volumes-from挂载的卷)</strong>,以保证新启动的服务匹配docker-compose.yml文件的最新内容</p></li><li><p>down</p><ul><li> 此命令你个将会停止up命令锁启动的容器,并移除网络,不会移除外部网桥以及所有数据卷</li></ul></li><li><p>exec</p><ul><li>使用docker-compose进入指定容器</li><li>需要通过服务名进入</li></ul></li><li><p>ps</p><ul><li>列出项目中目前的所有容器</li><li>选项<ul><li>-q只打印容器id</li></ul></li></ul></li><li><p>logs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose logs [options] [SERVICE]</span><br></pre></td></tr></table></figure><ul><li>查看日志</li></ul></li><li><p>restart</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose restart [options] [SERVICE]</span><br></pre></td></tr></table></figure><ul><li> 重启项目中的服务</li><li>可以重启单个服务或者全部服务</li><li>选项<ul><li>-t:–timeout 指定超时</li></ul></li></ul></li><li><p>rm</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose rm [options] [SERVICE]</span><br></pre></td></tr></table></figure><ul><li>删除所有(停止状态的服务容器)</li><li>选项<ul><li>-f,–force 强制直接删除</li><li>-v 删除容器挂载的数据卷 <strong>谨慎使用</strong></li></ul></li></ul></li><li><p>stop|start</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose stop|start [options] [SERVICE]</span><br></pre></td></tr></table></figure><ul><li>停止,启动服务</li><li>stop不会关闭网络</li></ul></li><li><p>top</p><ul><li>查看各个服务容器内运行的进程</li></ul></li><li><p>pause</p><ul><li>暂停服务,可以指定SERVICE</li></ul></li><li><p>unpause</p><ul><li>docker-compose unpause [SERVICE]</li></ul></li></ul></li></ul><h1 id="portainer-docker-可视化工具"><a href="#portainer-docker-可视化工具" class="headerlink" title="portainer docker 可视化工具"></a>portainer docker 可视化工具</h1><ul><li>docker pull xportainer/portainer,使用其监控docker引擎 /var/run/docker.sock</li><li>与docker socket通信时8000端口开放,与外部通信9000端口开放</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8000:8000 -p 9000:9000 --name&#x3D;portainer --restart&#x3D;always -v &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock -v portainer_data:&#x2F;data portainer&#x2F;portainer</span><br></pre></td></tr></table></figure><ul><li>runportainer之后直接去浏览器9000端口</li><li>使用docker-compose.yml文件配置portainer</li></ul>]]></content>
      
      
      <categories>
          
          <category> operations </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式缓存解决方案-redis</title>
      <link href="2021/07/28/redis-learn/"/>
      <url>2021/07/28/redis-learn/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么使用nosql（not-only-sql"><a href="#为什么使用nosql（not-only-sql" class="headerlink" title="为什么使用nosql（not only sql)"></a>为什么使用nosql（not only sql)</h1><ul><li>网站访问量不大的时候,用单个数据库库完全可以轻松应付</li><li>数据存储的瓶颈<ul><li>数据量的总大小,一个机器放不下时</li><li>数据的索引(B+ Tree)一个机器内存放不下时</li><li>访问量(读写混合)一个实例不能承受</li></ul></li></ul><h1 id="noSQL数据库库的四大分类"><a href="#noSQL数据库库的四大分类" class="headerlink" title="noSQL数据库库的四大分类"></a>noSQL数据库库的四大分类</h1><ul><li><p>KV</p><ul><li>新浪:BerkeleyDb+redis</li><li>美团:redis+tair</li><li>阿里、百度:memcache+redis</li></ul></li><li><p>文档型数据库(bson比较多)</p><ul><li>couchDB</li><li>mongoDb<ul><li>基于分布式文件存储的数据库,由C++语言编写。</li></ul></li></ul></li><li><p>列存储数据库</p><ul><li>Cassandra,Hbase</li><li>分布式文件系统</li></ul></li><li><p>图关系数据库</p><ul><li>放置社交网络、广告推荐系统</li><li>社交网络,推荐系统等。专注于构建关系图谱</li><li>Neo4J,InfoGrid</li></ul></li></ul><h1 id="在分布式数据库中CAP原理CAP-BASE-牺牲一致保证高可用与容错"><a href="#在分布式数据库中CAP原理CAP-BASE-牺牲一致保证高可用与容错" class="headerlink" title="在分布式数据库中CAP原理CAP+BASE:牺牲一致保证高可用与容错"></a>在分布式数据库中CAP原理CAP+BASE:牺牲一致保证高可用与容错</h1><ul><li>传统的ACID</li><li>CAP<ul><li>Consistency(强一致性)</li><li>Availability(可用性)</li><li>Partition tolerance(分区容错性)</li></ul></li><li>CAP的3进2<ul><li>一个分布式系统不可能同时很好满足CAP三个需求</li><li>最多只能同时比较好满足两个<ul><li>CA:单点集群,满足一致性,可用性的系统,通常在可扩展性上不太强大<strong>传统Oracle数据库</strong></li><li>CP:满足一致性,分区容忍性的系统,通常性能不是特别高<strong>redis,mongoDB</strong></li><li>AP:满足可用性,分区容忍性的系统,通常可能对一致性要求低一点<strong>大多数网站的选择</strong></li></ul></li></ul></li><li>经典CAP图<ul><li>P必须满足</li><li>必须在C与A直接权衡</li></ul></li><li>BASE<ul><li>Basically Available:基本可用</li><li>Soft state:软状态</li><li>Eventually consistent:最终一致</li></ul></li><li>分布式+集群简介</li></ul><h1 id="Redis简介-单线程"><a href="#Redis简介-单线程" class="headerlink" title="Redis简介:单线程"></a>Redis简介:单线程</h1><ul><li>特点<ul><li>Redis支持数据的持久化,可以将内存中的数据保存在磁盘中,重启的时候可以再次加载进行使用</li><li>Redis不仅仅支持简单的key-value类型的数据,同时还提供list,set,zset,hash等数据结构的存储</li><li>Redis支持数据的备份,即master-slave模式的数据备份</li></ul></li><li>下载至linux</li></ul><h1 id="Redis杂项"><a href="#Redis杂项" class="headerlink" title="Redis杂项"></a>Redis杂项</h1><ul><li>单进程</li><li>默认16个数据库,类似数组下表从零开始,初始默认使用零号库</li><li>select命令切换数据库</li><li>Dbsize查看当前数据库的key的数量</li><li>keys查看当前库的关键字</li><li>FLUSHDB:删除当前库</li><li>FLUSHALL:删除所有库</li><li>redis索引都是从0开始</li><li>为什么默认端口是6379</li></ul><h1 id="Redis多路I-O复用"><a href="#Redis多路I-O复用" class="headerlink" title="Redis多路I/O复用"></a>Redis多路I/O复用</h1><ul><li>概念<ul><li>多路复用是指使用一个线程来检查多个Socket的就绪状态,比如调用select和poll函数,传入多个文件描述符,如果有一个Socket就绪,则返回,否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行,也可以启动线程执行(比如使用线程池)</li><li>串行 vs 多线程+锁(memcached) vs 单线程+多路IO复用<ul><li>select<ul><li>select轮询,最多1024</li></ul></li><li>poll<ul><li>不限制轮询</li></ul></li><li>epoll<ul><li>epoll为每个socket设置标识符</li></ul></li></ul></li></ul></li></ul><h1 id="Redis五大数据类型"><a href="#Redis五大数据类型" class="headerlink" title="Redis五大数据类型"></a>Redis五大数据类型</h1><ul><li>分类<ul><li>String(字符串)<ul><li>String是redis最基本的类型,一个key对应一个value</li><li>String类型是二进制安全的,redis的string可以包含任何数据</li><li>一个redis中字符串的value最多可以是512M.</li><li>接近于LinkedList</li></ul></li><li>Hash(哈希,类似java里的Map)</li><li>List(列表)</li><li>Set(集合)<ul><li>string类型的无需集合,它是通过HashTable实现的</li></ul></li><li>Zset(sorted set;有序集合)<ul><li>每个元素都会关联一个double类型的分数</li><li>redis正是痛殴该国分数来为集合中的成员进行从小到大的排序,zset的成员是唯一的,但分数（score)可以重复</li></ul></li></ul></li><li>Redis键(key)<ul><li>keys * 查看当前库的所有key</li><li>EXISTS (keyName)</li><li>move (keyName) (dbIndex):指定</li><li>expire key (time):为给定的key设置过期时间</li><li>ttl (key name):查看key的生命周期,没有的key ttl为-2</li><li>DEL key:删除key</li><li>type:查看当前key的数据类型</li></ul></li><li>Redis字符串(String)<ul><li>常用</li><li>单值单value</li><li>命令<ul><li>get/set:设置添加字符串</li><li>strlen:字符串长度</li><li>incr/decr/incrby/decrby:数字才能加减</li><li>getrange/setrange:获取指定区间范围的值(下标)</li><li>setex(set with expire)键秒值/setnx(set if not exist)</li></ul></li></ul></li><li>Redis列表(List)<ul><li>lpush/rpush/lrange</li><li>lpop/rpop</li><li>lindex:按照索下标获得元素(从上到下)</li><li>llen:list长度</li><li>lrem key 删除N个value : count:删除几个 value:相等的值</li><li>ltrim key ,截取指定范围的值后再赋值给key(不生成新的listl)</li><li>rpoplpush  源列表 目的列表 </li><li>lset key index value 为list某个下标赋值</li><li>linsert key before/after 值1(pivot) 值2</li></ul></li><li>Redis集合(Set)<ul><li>sadd/smembers/sismember</li><li>scard:获取集合里面元素个数</li><li>srem key value 删除集合中的元素</li><li>srandmember key 某个随机整数(随机出几个数)</li><li>spop key 随机出栈</li><li>smove key1 key2 :将key1里的某个值赋给key2</li><li>数学集合类<ul><li>差:sdiff set01 set02 :set01 - set02</li><li>交:sinter</li><li>并:sunion</li></ul></li></ul></li><li><strong>Redis哈希(Hash)</strong><ul><li>常用</li><li>kv模式不变,v是一个键值对<ul><li>hset/hget/hmset/hmget/hgetall/hdel</li><li>hlen</li><li>hexists key 在key里面的某个值的key</li><li>hkeys/hvals:获取单独的keys和values</li><li>hincrby/hincrbyfloat</li><li>hsetnx</li></ul></li></ul></li><li>Redis有序集合Zset(sorted set)<ul><li>介绍<ul><li>在set基础上加一个score值</li><li>之前set是k1 v1 v2 v3</li><li>现在zset是k1 score1 v1 score2 v2</li></ul></li><li>命令<ul><li>zadd,zrange with scores</li><li>zrangebyscore key 开始score 结束score<ul><li>(不包含</li><li>limit可以在结果集上再次截取,startIndex offset</li></ul></li><li>zrem key 某score下对应的value值:删除元素</li><li>zcard/zcount key score区间/zrank key values值/zscore key value<ul><li>count统计score区间的元素</li><li>zrank,获取value的下标值</li><li>zscore key value,获取value的对应score</li></ul></li><li>zrevrank key values值,作用是逆序获得下标值</li><li>zrevrange 逆序打印</li><li>zrevrangebyscore </li></ul></li></ul></li></ul><h1 id="Redis配置文件"><a href="#Redis配置文件" class="headerlink" title="Redis配置文件"></a>Redis配置文件</h1><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/redis/image-20210725162414279.png" alt="image-20210725162414279"></p><h2 id="它在哪"><a href="#它在哪" class="headerlink" title="它在哪"></a>它在哪</h2><ul><li>将redis配置文件单独拷贝出来</li></ul><h2 id="Units单位"><a href="#Units单位" class="headerlink" title="Units单位"></a>Units单位</h2><ul><li>只支持bytes,不区分大小写</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/redis/image-20210725162526980.png" alt="image-20210725162526980"></p><h2 id="INCLUDES包含"><a href="#INCLUDES包含" class="headerlink" title="INCLUDES包含"></a>INCLUDES包含</h2><ul><li>分模块配置</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/redis/image-20210725162537004.png" alt="image-20210725162537004"></p><h2 id="NETWORK"><a href="#NETWORK" class="headerlink" title="NETWORK"></a>NETWORK</h2><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/redis/image-20210725163615194.png" alt="image-20210725163615194"></p><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/redis/image-20210725163814963.png" alt="image-20210725163814963"></p><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/redis/image-20210725163923596.png" alt="image-20210725163923596"></p><ul><li>bind:绑定本机器网卡ip,本机器的哪些ip可以访问redis</li></ul><h2 id="GENERAl通用"><a href="#GENERAl通用" class="headerlink" title="GENERAl通用"></a>GENERAl通用</h2><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/redis/image-20210725164540620.png" alt="image-20210725164540620"></p><h2 id="SECURITY"><a href="#SECURITY" class="headerlink" title="SECURITY"></a>SECURITY</h2><ul><li><p>密码设置</p><ul><li>默认没有设置</li><li>自己设置密码</li></ul></li><li><p>maxclients:最大连接数</p><ul><li>默认没有设置</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/redis/image-20210725165010291.png" alt="image-20210725165010291"></p></li></ul><h1 id="db基本操作"><a href="#db基本操作" class="headerlink" title="db基本操作"></a>db基本操作</h1><ul><li>切换数据库<ul><li>select index</li></ul></li><li>其他操作<ul><li>ping</li><li>echo message</li><li>quit</li></ul></li><li>数据移动:必须保证目标库没有重名key<ul><li>move key dbIndex</li></ul></li><li>数据清除<ul><li>dbsize</li><li>flushdb</li><li>flushall</li></ul></li></ul><h1 id="发布和订阅"><a href="#发布和订阅" class="headerlink" title="发布和订阅"></a>发布和订阅</h1><ul><li><p>publish&amp;subscribe</p></li><li><p>redis客户端可以订阅任意数量的频道</p></li></ul><h1 id="redis新的数据类型"><a href="#redis新的数据类型" class="headerlink" title="redis新的数据类型"></a>redis新的数据类型</h1><ul><li>Bitmaps:用于计算1的个数<ul><li>bitmaps本身不是一种数据类型,实际上就是字符串</li><li>bitmas单独提供了一套命令</li><li>命令<ul><li>setbit</li><li>getbit</li><li>bitcount(统计字符从start子节到end子节比特值为1的数量)</li><li>bitop(可以进行复杂的与并交等操作):and,or,not,xor(异或)<ul><li>bittop and [resName] key1 key2</li></ul></li></ul></li></ul></li><li>HyperLogLog:解决基数个数问题<ul><li>用于计算基数(不重复)的个数,不用于返回具体值</li><li>命令<ul><li>pfadd,支持一次键入多个值</li><li>pfcount,得到program的count值</li><li>pfmerge 将一个或多个hll合并加入到另一个中去</li></ul></li></ul></li><li>Geospatial:经纬度地理位置<ul><li>用于计算经纬度</li><li>两极无法直接添加,一般会下载城市数据,直接通过Java程序一次性导入</li><li>有效的精度是从-180度到180度,有效的维度从-85.05112878到85.05112878度</li><li>命令<ul><li>geoadd<ul><li>geoadd china:city 121.47 31.23 shsanghai</li></ul></li><li>geopos<ul><li>geopos china:city shsanghai</li></ul></li><li>geodist<ul><li>geodist china:city shanghai chongqing km</li><li>单位:默认米<ul><li>m</li><li>km</li><li>mi英里</li><li>ft英尺</li></ul></li></ul></li></ul></li></ul></li></ul><h1 id="springboot整合redis"><a href="#springboot整合redis" class="headerlink" title="springboot整合redis"></a>springboot整合redis</h1><h2 id="导入redis包"><a href="#导入redis包" class="headerlink" title="导入redis包"></a>导入redis包</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-redis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="配置与自定义配置类"><a href="#配置与自定义配置类" class="headerlink" title="配置与自定义配置类"></a>配置与自定义配置类</h2><ul><li><p>springboot里操纵redis默认使用lettuce,使用NIO规范比jedis的BIO操作多线程时更安全</p></li><li><p>为什么要使用配置类?</p><ul><li>如果不使用配置类,redis存储中文时会使用jdk默认转义</li><li>redis存储对象需要将其序列化</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String,Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">    <span class="comment">//使用String,Object类型</span></span><br><span class="line">    RedisTemplate&lt;String,Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">    template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">    <span class="comment">//序列化配置</span></span><br><span class="line">    <span class="comment">//json序列化</span></span><br><span class="line">    Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">    ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">    om.activateDefaultTyping(om.getPolymorphicTypeValidator());</span><br><span class="line">    jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">    <span class="comment">//String的序列化</span></span><br><span class="line">    StringRedisSerializer stringRedisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">    <span class="comment">//key采用String的序列化方式</span></span><br><span class="line">    template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">    <span class="comment">//hash的key也采用String的序列化方式</span></span><br><span class="line">    template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">    <span class="comment">//value序列化方式采用jackson</span></span><br><span class="line">    template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">    <span class="comment">//hash的value序列化方式采用jackson</span></span><br><span class="line">    template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">    template.afterPropertiesSet();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用RedisTemplate进行操作"><a href="#使用RedisTemplate进行操作" class="headerlink" title="使用RedisTemplate进行操作"></a>使用RedisTemplate进行操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedisLettuceApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> RedisTemplate&lt;String,String&gt; redisTemplate;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    RedisConnection redisConnection = redisTemplate.getConnectionFactory().getConnection();</span><br><span class="line"></span><br><span class="line">    redisConnection.flushAll();</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; keys = redisTemplate.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">      System.out.println(key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="持久化操作"><a href="#持久化操作" class="headerlink" title="持久化操作"></a>持久化操作</h1><h2 id="什么是持久化"><a href="#什么是持久化" class="headerlink" title="什么是持久化"></a>什么是持久化</h2><ul><li>利用永久性存储将易失性数据保存</li></ul><h2 id="持久化过程保存什么"><a href="#持久化过程保存什么" class="headerlink" title="持久化过程保存什么"></a>持久化过程保存什么</h2><ul><li><strong>数据(快照)</strong><ul><li>将当前数据状态进行保存,快照形式,存储数据结果,存储格式简单,关注点在数据(RDB)</li></ul></li><li>过程(日志)<ul><li>将数据的操作过程进行保存,日志形式,存储操作过程,存储格式复杂,关注点在数据的操作过程(AOF)</li></ul></li></ul><h2 id="RDB-Redis-DataBase"><a href="#RDB-Redis-DataBase" class="headerlink" title="RDB(Redis DataBase)"></a>RDB(Redis DataBase)</h2><ul><li><p>RDB启动方式</p><ul><li>命令执行</li><li>命令<ul><li>save<ul><li>save时只管保存,其他不管,全部阻塞</li><li>不会fork出子进程</li></ul></li><li>bgsave<ul><li>使用之后不会立即执行</li><li>bgsave.redis会在后台异步进行快照操作,快照同时还可以响应客户端请求,可以通过lastsave命令获取最后一次成功执行快照的时间</li><li>会fork出子进程,redis内部所有save<strong>都是bgsave</strong></li></ul></li><li>执行flushall命令,也会产生dump.db文件,但是dump.db文件时空的</li></ul></li></ul></li><li><p>Fork:Redis会单独创建(fork)一个子进程来进行持久化,会先将数据写入到一个临时文件中,待持久化过程都结束了,再用这个临时文件替换上次持久化好的文件。整个过程,主进程是不进行任何IO操作的,这就确保了极高的性能,如果需要进行大规模数据的恢复,且对于数据回复的完整性不是特别敏感,那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。</p><ul><li>fork作用是复制一个与当前进程一样的进程,新进程的所有数据数值都和原进程一致,但是是一个全新的进程,并作为原进程的子进程</li></ul></li><li><p>dump.rdb文件何时生效(RDB启动方式)</p><ul><li>redis重启时</li><li>flush等提交命令会自动备份</li><li>将备份文件移动到redis安装目录并启动服务即可</li><li>CONFIG GET dir 获取目录</li></ul></li><li><p>配置文件详解:SNAPSHOTTING</p><ul><li>Save<ul><li>默认<ul><li>1分钟1w次</li><li>5分钟10次</li><li>15分钟1次</li></ul></li></ul></li><li>Stop-writes-on-bgsave-error:后台存储如果出现错误,是否停止保存<ul><li>如果配置成no表示不在乎数据不一致或者有其他手段发现和控制</li></ul></li><li>rdbcompression:对于存储到磁盘中的快照,可以设置是否进行压缩存储,如果是redis采用LZF算法进行压缩,如果不想消耗CPU来进行压缩,可以设置位关闭此功能</li><li>rdbchecksum:再存储快照后,还可以让redis使用CRC64算法来进行数据校验,但是这样做会增加大约10%的性能消耗</li><li>dir:存储数据的位置</li></ul></li><li><p>优势</p><ul><li>适合大规模数据回复</li><li>对数据完整性和一致性要求不高</li></ul></li><li><p>劣势</p><ul><li>Fork:再一定间隔时间做一次备份,所以如果redis意外down掉,就会丢失最后一次快照后的所有修改</li><li>Fork的时候,内存中的数据被克隆了一份,大致2被的膨胀性能需要考虑</li></ul></li><li><p>如何停止</p><ul><li>动态所有停止RDB保存规则的方法,redis-cli config set save “”</li></ul></li><li><p>服务器运行过程中重启</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debug reload</span><br></pre></td></tr></table></figure></li><li><p>关闭服务器时指定保存数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown save</span><br></pre></td></tr></table></figure></li></ul><h2 id="AOF-Append-Only-File"><a href="#AOF-Append-Only-File" class="headerlink" title="AOF(Append Only File)"></a>AOF(Append Only File)</h2><ul><li><p>简介</p><ul><li>AOF以日志形式来记录每个写操作,将Redis执行过的所有写指令记录下来(读操作不记录),只许追加文件但不可以改写文件,redis启动之初会读取该文件重新构建数据,换言之,redis重启的化就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作、</li></ul></li><li><p>AOF小技巧</p><ul><li>redis启动首先读取aof再读取rdb</li><li>当aof损坏,redis无法启动</li><li>如果aof损坏,使用redis-check-aof –fix [fileName]修复</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-check-aof --fix appendonly-6379.aof</span><br></pre></td></tr></table></figure><ul><li><p>rewrite</p><ul><li><p>是什么:AOF采用文件追加方式,文件会越来越大,为避免出现这种情况,新增重写机制,当AOF文件的大小超过设定的阈值时,Redis就会启动AOF文件的内容压缩,只保留可以恢复数据的最小指令集,可以使用命令<strong>bgrewriteaof</strong></p></li><li><p>重写原理:AOF文件持续增长而过大时,会fork出一条新进程来将文件重写(也是先写临时文件最后再rename),遍历新进程的内存中数据,每条记录有一条的Set语句。重写aof文件的操作,并没有读取旧的aof文件,而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件,这点和快照有点类似</p></li><li><p>触发机制:Redis会记录上次重写时的AOF大小,默认配置时当AOF文件大小时<strong>上次rewrite</strong>后大小的一倍且文件大于64M触发</p></li><li><p>重写规则</p><ul><li>过时数据不重写</li><li>对结果集没有影响的写不充写</li><li>多个相同操作合并</li></ul></li><li><p>自动重写出发比对参数(运行指令info Persistence获取具体信息)</p><ul><li>aof_current_size</li><li>aof_base_size</li></ul></li></ul></li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/redis/image-20210726162334705.png" alt="image-20210726162334705"></p></li><li><p>配置文件APPEND ONLY MODE</p><ul><li>appendonly:默认no</li><li>appendfilenme:aof文件名</li><li>Appendfsync<ul><li>Always:同步持久化,每次发生数据变更会被立即记录到磁盘,性能较差但数据完整性比较好</li><li><strong>Everysec</strong>:出厂默认推荐,异步操作,每秒记录,如果一秒内当即,有数据丢失</li><li>no:不持久化</li></ul></li><li>No-appendfsync-on-rewrite:重写时是否可以运用Appendfsync,用默认no即可,保证数据安全性</li><li>Auto-aof-rewrite-min-size:设置重写的基准值<ul><li>默认64mb</li></ul></li><li>Auto-aof-rewrite-percentage:设置重写的基准值<ul><li>默认当大小为上次两倍时100%开启rewrite</li></ul></li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/redis/image-20210726162334705.png" alt="image-20210726162334705"></p><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/redis/image-20210726170104115.png" alt="image-20210726170104115"></p></li><li><p>优势</p><ul><li>可以选择同步形式<ul><li>always:每修改同步,同步操作,性能差,数据完整性高</li><li>everysec:每秒同步,异步操作,如果一秒内宕机,有数据丢失</li><li>no:不同步</li></ul></li></ul></li><li><p>劣势</p><ul><li>相同数据集的数据而言aof文件要远大于rdb文件,恢复速度慢于rdb</li><li>aof运行效率要慢于rdb,每秒同步策略效率较好,不同步效率和rdb相同</li></ul></li></ul><h2 id="总结-Which-One"><a href="#总结-Which-One" class="headerlink" title="总结(Which One)"></a>总结(Which One)</h2><ul><li><p>官网建议</p><ul><li><p>RDB持久化方式能够在指定的时间间隔内对数据进行快照存储</p></li><li><p>AOF持久化方式记录每次对服务器写的操作,当服务器重启时会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾,Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大</p></li><li><p>只做缓存:如果只希望数据在服务器运行的时候存在,可以不适用任何持久化</p></li><li><p>同时开启两种持久化方式</p><ul><li>在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据</li><li>RDB的数据不实时,同时使用两者时服务器重启也只会找AOF文件。RDB更适合用于备份数据库(AOF在不断变化不好备份),快速重启,而且不会有AOF可能潜在的bug，留着以防万一</li></ul></li><li><p>性能建议</p><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/redis/image-20210726163628664.png" alt="image-20210726163628664"></p><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/redis/image-20210726170159177.png" alt="image-20210726170159177"></p><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/redis/image-20210726170223534.png" alt="image-20210726170223534"></p></li></ul></li></ul><h2 id="持久化应用场景"><a href="#持久化应用场景" class="headerlink" title="持久化应用场景"></a>持久化应用场景</h2><ul><li>redis用于控制数据库表主键id,为数据库表主键提供生成策略,保障数据库表的主键唯一性(x)</li><li>redis应用于各种结构型和非结构性高热数据访问加速(x)</li><li>redis应用于购物车数据存储设计(x)</li><li><strong>redis应用于抢购,限购、限量发送优惠卷、激活码等业务的数据存储设计(√)</strong></li><li><strong>redis应用于具有操作先后顺序的数据控制</strong></li><li><strong>redis应用于最新消息展示</strong></li><li>redis应用于同类信息的关联搜索,二度关联搜索,深度关联搜索(x)</li><li>redis应用于基于黑名单与白名单设定的服务控制<ul><li>永久性数据库</li><li>暂时性redis</li></ul></li><li><strong>redis用于计数器组合排序功能对应的排名</strong></li><li>redis应用于即时任务/消息队列执行管理(x)</li><li>redising用于按次结算的服务控制</li></ul><h1 id="事务-transaction-对事务部分支持"><a href="#事务-transaction-对事务部分支持" class="headerlink" title="事务 (transaction):对事务部分支持"></a>事务 (transaction):对事务部分支持</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><ul><li>可以一次执行多个命令,本质是一组命令的集合。一个事务中的所有命令都会序列化,按顺序地串行化执行而不会被其他命令插入,不许加塞</li></ul><h2 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h2><ul><li>一个队列中,一次性、顺序性、排他性地执行一系列命令</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li>常用命令<ul><li>MULTI:标记一个事务块地开始</li><li>EXEC:执行所有事务块内地命令</li><li>DISCARD:取消事务,放弃执行事务块内的所有命令</li><li>UNWATCH:取消WATCH命令对所有key的监视</li><li>WATCH key [key…]:监视一个或多个key，如果在事务执行之前这些key被其他命令所改动,那么事务将被打断</li></ul></li><li>case1:正常执行<ul><li>MULTI</li><li>EXEC</li></ul></li><li>case2:放弃事务<ul><li>MULTI</li><li>DISCARD</li></ul></li><li>case3:全体连坐:命令出错<ul><li>当事务中有一条命令出错,所有命令都不会执行</li></ul></li><li>case4:冤头债主:执行出错<ul><li>谁错谁不做</li></ul></li><li>case5:watch监控<ul><li>悲观锁/乐观锁/CAS(Check And Set)<ul><li>悲观锁,一定会有人改,表锁,性能差</li><li><strong>乐观锁</strong>,不一定会有人改,乐观锁在最后添加一个version,每次操作时持有当前version,如果其他人修改过version改变,则其他人会报异常,提交版本必须大于记录当前版本才能执行更新</li></ul></li><li>初始化信用卡可用余额和欠额</li><li>无加塞篡改,先监控再开启multi,保证两笔金额变动再同一个事务内</li><li>有加塞篡改,事务提交失败</li><li>unwatch:接触所有的监控</li><li>一旦执行了exec,之前加的监控锁都会被取消</li><li>小结</li></ul></li><li>3阶段<ul><li>开启:以MULTI开启一个事务</li><li>入队:将多个命令入队到事务中,接到这些命令并不会立即执行,而是放到等待执行的事务队列里面</li><li>执行:由EXEC命令出发事务</li></ul></li><li>3特性<ul><li>单独的隔离操作</li><li>没有隔离级别的概念</li><li>不保证原子性</li></ul></li></ul><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><ul><li><p>超买问题,当商品只剩最后一个时,我们如何才能不让此商品被多买呢?</p><ul><li>添加分布式锁</li><li>setnx lock-keyName value</li><li>使用setnx,为指定的key添加锁,value随便设</li><li>使用结束后只能用del消除该lock-key取消分布式锁</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set num 10</span><br><span class="line">&#x2F;&#x2F;如果lock-num不存在,添加锁</span><br><span class="line">setnx lock-num 1</span><br><span class="line">&#x2F;&#x2F;操作数据</span><br><span class="line">incrby num -1</span><br><span class="line">&#x2F;&#x2F;删除锁</span><br><span class="line">del lock-num</span><br></pre></td></tr></table></figure></li><li><p>死锁解决</p><ul><li><p>依赖分布式锁的机制,某个用户操作时对应客户端宕机,且此时已经获取到锁,如何解决?</p></li><li><p>实际上就是外部设置的一个规则,如果当前用户set了lock-key则视为已经锁,但其实Set依旧可以更改,只是一个约定,需要编程遵守</p></li><li><p>业务分析</p><ul><li>由于锁操作由用户控制加锁解锁,必定会存在加锁后未解锁的风险</li><li>需要解锁操作不能仅依赖用户控制,系统级别要给出对应的保底处理方案</li></ul></li><li><p>解决方案</p><ul><li>使用expire为锁key添加事件限定,到时不释放,放弃锁</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expire lock-key second</span><br><span class="line">pexpire lock-key milliseconds</span><br></pre></td></tr></table></figure><ul><li>由于操作通常都是毫秒或者微秒,因此该锁定时间不宜设置过大。具体时间需要业务测试后确认<ul><li>例如:持有锁的操作最长执行时间127ms,最短执行时间7ms</li><li>测试百万次最长执行对应命令的最大耗时,测试百万次网络平均耗时</li><li>锁时间推荐:最大耗时<em>120%+平均网络延迟</em>110%</li><li>如果业务最大耗时&lt;&lt;网络平均延迟,通常为2个数量级,取其中单个耗时较长的即可</li></ul></li></ul></li></ul></li></ul><h1 id="消息订阅和发布-pub-sub"><a href="#消息订阅和发布-pub-sub" class="headerlink" title="消息订阅和发布(pub-sub)"></a>消息订阅和发布(pub-sub)</h1><ul><li>是什么<ul><li>是进程间的一种消息通信模式：发送者(pub)发送消息,订阅者(sub)接收消息</li><li>订阅/发布消息图</li></ul></li><li>命令<ul><li>subscribe 可以订阅多个频道</li><li>publish 发送消息</li><li>可以使用通配符订阅 Psubscribe new*</li></ul></li></ul><h1 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h1><ul><li><p>概念</p><ul><li>Redis是一种内存级数据库,所有数据均存放在内存中,内存中的数据可以通过TTL指令获取其状态<ul><li>XX:具有时效性的数据</li><li>-1:永久有效的数据</li><li>-2:已经过期的数据或被删除的数据或未定义的数据</li></ul></li></ul></li><li><p>数据删除策略</p><ul><li>定时删除<ul><li>数据TTL一到立即删除</li><li>特点:对内存占用少,对cpu占用大</li></ul></li><li>惰性删除<ul><li>数据TTL一到不删除,等待下次访问时删除</li><li>特点:对内存占用大,对cpu占用小</li></ul></li><li>定期删除<ul><li>过程<ul><li>Redis启动服务器初始化时,读取配置server.hz的值,默认为10</li><li>每秒钟执行server.hz次serverCron()-&gt;命令对所有expire库轮询</li><li>serverCron()执行databasesCron()</li><li>databasesCron()执行activeExpireCycle()</li></ul></li></ul><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/redis/image-20210727091252094.png" alt="image-20210727091252094"><ul><li>概述:每秒钟对所有expire库轮询,expire库存储的是该下标对应库的key的过期时间</li><li>轮询时对随机W(可配置)个键进行检测,如果key过期删除,key不过期保留</li><li>删除key足够多则再次删除该库中的key,如果不够多则下一个库</li><li>删除时current_db记录activeExpireCycle()进入哪个expires[*]执行</li><li>如果activeExpireCycle()执行时间到期,下次从current_db继续向下执行</li></ul></li></ul></li><li><p>逐出算法</p><ul><li><p>新数据进入检测</p><ul><li>当新数据进入redis时,如果内存不足怎么办?<ul><li>redis使用内存存储数据,在执行每一个命令前,会调用freeMemoryIfNeeded检测()内存是否充足。如果内存不满足新加入数据的最低存储要求,redis要临时删除一些数据为当前指令清理存储空间。清理数据的策略称为逐出算法。</li><li>逐出数据的过程不是100%能够清理出足够的可使用的内存空间,如果不成功则反复执行。当对所有数据尝试完毕后,如果不能达到内存清理的要求,将出现错误信息</li></ul></li></ul></li><li><p>配置</p><ul><li><p>maxmemory:最大可使用内存,默认全用</p></li><li><p>maxmemory-samples:每次随机选取待删除数据的个数</p></li><li><p>maxmemory-policy:删除策略</p><ul><li>检测易失数据(可能会过期的数据集server.db[i].expires)<ol><li>volatile-lru:挑选<strong>最近</strong>最少使用的数据淘汰(最长时间没有使用)</li><li>volatile-lfu:挑选最近使用<strong>次数</strong>最少的数据淘汰(规定使用时间使用次数最少)</li><li>volatile-ttl:挑选将要过期的数据淘汰</li><li>volatile-random:任意选择</li></ol></li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/redis/image-20210727092909042.png" alt="image-20210727092909042"></p><ul><li>检测全库数据(所有数据集server.db[i].dict)<ol><li>allkeys-lru</li><li>allkeys-lfu</li><li>allkeys-random</li></ol></li><li>放弃数据驱逐<ol><li>no-envication:禁止驱逐数据(redis4.0中的默认策略),会引发OOM</li></ol></li></ul></li><li><p>数据逐出策略配置依据</p><ul><li>使用INFO命令输出监控信息,查询缓存hit和miss的次数,根据业务需求调优Redis配置</li></ul></li></ul></li></ul></li></ul><h1 id="主从复制-master-slave"><a href="#主从复制-master-slave" class="headerlink" title="主从复制(master/slave)"></a>主从复制(master/slave)</h1><p>replication:重复</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>主机数据更新后更具配置和策略,自动同步到备机的master/slave机制,Master以写为主,Slave以读为主</li><li>主从复制是全量复制非增量复制(从机备份主机所有数据)</li><li>一个master可以拥有多个slave,一个slave只能对应一个master<ul><li>master<ul><li>写数据</li><li>执行写操作,将出现变化的数据自动同步到slave</li><li>读数据(可忽略)</li></ul></li><li>slave<ul><li>读数据</li><li>写数据(禁止)</li></ul></li></ul></li></ul><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><ul><li>读写分离</li><li>容灾恢复<ul><li>当master出现问题时,由slave提供服务,实现快速的故障恢复</li></ul></li><li>负载均衡<ul><li>基于主从结构,配合读写分离,由slave分担mastet负载,并根据需求的变化,改变slave的数量,通过多个从节点芬兰数据读取负载,大大提高Redis服务器并发量与数据吞吐量</li></ul></li><li>高可用基石<ul><li>基于主从复制,构建哨兵模式与集群,实现redsi的高可用方案</li></ul></li></ul><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><ul><li>info replication查看当前虚拟机的replication状态</li><li>slaveof masterIP port</li></ul><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><ol><li><p>配从(库)不配主(库)</p><ol><li>配置从库不配置主库</li></ol></li><li><p>从库配置:slaveof 主库IP 主库端口</p><ol><li>slaver每次与master断开之后,都需要重新连接,除非你配置进redis.conf文件</li><li>Info replication</li></ol></li><li><p>修改配置文件细节操作</p></li><li><p>常用3招</p><ol><li>一主二仆<ol><li>Init</li><li>一个master两个Slaver</li><li>日志查看</li><li>主从问题</li></ol></li><li>薪火相传<ol><li>简介<ol><li>上一个Slave可用是下一个slave的Master,Slave同样可以接收其他Slaves的连接和同步请求,那么该slave作为了来那条汇总下一个的master,额可以有效减轻master的写压力</li><li>中途变更转向,会<strong>清除</strong>之前的数据,重新建立拷贝最新的</li><li>slaveof new_master_IP new_master_port</li></ol></li><li>tips:<ol><li>中间redis-server依旧是slave</li><li>数据会链式传递</li></ol></li></ol></li><li>反客为主<ol><li>简介<ol><li>使当前数据库停止与其他数据库的同步,转成主数据库</li></ol></li><li>命令<ol><li>slaveof no one</li><li>其他从机挂上 </li></ol></li></ol></li></ol></li><li><p>tips</p><ul><li>从机不可写</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/redis/image-20210727114943417.png" alt="image-20210727114943417"></p><ul><li>关于主机down掉<ul><li>主机挂掉之后,从机保持从机位置,并不会上位</li><li>主机回来之后,如果主机IP端口不变则主从体系不会变</li></ul></li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/redis/image-20210727115243933.png" alt="image-20210727115243933"></p><ul><li>关于从机down掉<ul><li>从机down掉,此从机与主机连接断掉,需要重新配置</li></ul></li></ul></li></ol><h2 id="Redis是否高可用"><a href="#Redis是否高可用" class="headerlink" title="Redis是否高可用"></a>Redis是否高可用</h2><ul><li>单机redis的风险与问题<ol><li>机器故障<ul><li>现象:硬盘故障、系统崩溃</li><li>本质:数据丢失,很可能对业务造成灾难性打击</li><li>结论:基本上会放弃使用redis</li></ul></li><li>容量瓶颈<ul><li>现象:内存不足,从16G升级到64G,从64G升级到128G,无限升级内存</li><li>本质:穷,硬件条件跟不上</li><li>结论:放弃使用redis</li></ul></li><li>结论:<ul><li>为了避免单点redis服务器故障,准备堕胎服务器,互相连通。将多个副本保存在不同的服务器上,连接在一起,并保证数据使同步额。即使有其中一台服务器宕机,其他服务器依然可以继续提供服务,实现Redis的高可用,同时实现数据冗余备份</li></ul></li></ol></li></ul><h2 id="主从复制工作流程"><a href="#主从复制工作流程" class="headerlink" title="主从复制工作流程"></a>主从复制工作流程</h2><ul><li><p>主从复制过程大致可以分为3个阶段</p><ul><li>建立连接阶段(准备阶段)<ul><li>建立slave到master的连接,使master能够识别slave,并保存slave端口号</li></ul></li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/redis/image-20210727150455992.png" alt="image-20210727150455992"></p><ul><li>数据同步阶段</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/redis/image-20210727153427733.png" alt="image-20210727153427733"></p><ul><li>命令传播阶段 </li></ul></li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/redis/image-20210727150240221.png" alt="image-20210727150240221"></p><ul><li><p>命令</p><ul><li><p>连接方式</p><ol><li>客户端发送命令 slaveof [masterip] [masterport]</li><li>启动服务器参数 redis-server –slaveof [masterip] [masterport]</li><li>服务器配置 slaveof [masterip] [masterport]</li><li>slave系统信息<ul><li>master_link_down_sinces_seconds</li><li>masterhost</li><li>masterport</li></ul></li><li>master系统信息<ul><li>slave_listening_port</li></ul></li><li>断开连接<ul><li>slaveof no one</li></ul></li><li>授权访问<ul><li>master配置文件设置密码<ul><li>requirepass [password]</li></ul></li><li>master客户端发送命令设置密码<ul><li>config set requirepass [password]</li><li>config get requirepass</li></ul></li><li>slave客户端发送命令设置密码<ul><li>auth [password]</li></ul></li><li>slave配置文件设置密码<ul><li>masterauth [password]</li></ul></li><li>启动客户端设置密码<ul><li>redis-cli -a [password]</li></ul></li></ul></li></ol></li><li><p>数据同步阶段工作流程</p><ul><li><p>在slave初次连接master后,复制master中的所有数据到slave</p></li><li><p>将slave的数据库状态更新成master当前的数据库状态</p></li><li><p>先全量再增量,全量通过rdb发送,增量通过master通过复制缓冲区发送,master存储slave当前数据同步的位置</p></li><li><p>数据同步阶段master说明</p><ol><li>如果master数据量巨大,数据同步阶段应避开流量高峰期,避免造成master阻塞,影响业务正常执行</li><li>复制缓冲区大小设定不合理,会导致数据溢出,如进行全量复制周期太长,进行部分复制时发现数据已经存在丢失的情况,必须进行第二次全量复制,致使slave陷入死循环状态</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repl-backlog-size 1mb</span><br></pre></td></tr></table></figure><ol start="3"><li>master单机内存占用主机内存的比例不应过大,建议使用50%-70%内存,留下30%-50%内存用于执行bgsave命令和创建复制缓冲区</li></ol></li><li><p>数据同步阶段slave说明</p><ol><li>为避免slave进行全量复制、部分复制时服务器响应阻塞或数据不同步,建议关闭此期间的对外服务</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slave-serve-stale-data yes|no</span><br></pre></td></tr></table></figure><ol start="2"><li>数据同步阶段,master发送给salve信息可以理解master时slave的一个客户端,主动向salve发送命令</li><li>多个slave同时对master请求数据同步,master发送的RDB问价你增多,回对带宽造成巨大冲击,如果master带宽不足,因此数据同步需要根据业务需求,适量错峰</li><li>slave过多,建议调整拓补结构,由一主多从结构变为树状结构,中间的节点既是master,也是slave。注意使用梳妆结构时,由于层级深度,导致深度越高的salve与最顶层master间数据同步延迟较大,数据一致性变差,应谨慎选择</li></ol></li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/redis/image-20210727161038598.png" alt="image-20210727161038598"></p></li><li><p>命令传播阶段</p><ul><li><p>当master数据状态被修改后,导致主从服务器数据库状态不一致,此时需要让主从数据同步到一致的状态,同步的动作称为命令传播</p></li><li><p>master将接收到的数据变更命令发送给slave,slave接收命令后执行命令</p></li><li><p>命令传播阶段的部分复制</p><ul><li>命令传播阶段出现了断网现象<ul><li>网络闪断闪连 忽略</li><li>短时间网络中断 部分复制</li><li>长时间网络中断 全量复制</li></ul></li><li>部分复制的三个核心要素<ul><li>服务器的运行id(run id)<ul><li>概念:是每一台服务器每次运行的身份识别码,一台服务器多次运行可以生成多个运行id</li><li>组成:运行id由40为字符组成,是一个随机十六进制字符3c9061cc3da001bd7085154842e42d7ea5e151fb</li><li>作用:运行id被用于再服务器间进行传输,识别身份,如果想两次操作均对同一台服务器进行,必须每次操作携带对应的运行id,用于对方识别</li><li>实现方式:运行id再每台服务器启动时自动生成,master再首次连接slave时,会将自己的运行id发送给slave,slave保存此ID,从过info server命令,可以查看节点的runid</li></ul></li><li>主服务器的复制积压缓冲区</li><li>主从服务器的复制偏移量</li></ul></li></ul></li><li><p>复制缓冲区与偏移量</p><ul><li><p>复制缓冲区</p><ul><li>概念:是一个FIFO的队列,用于存储服务器执行过的命令,每次传播命令,master都会将传播的铭霖记录下来,并存储在复制缓冲区<ul><li>复制缓冲区默认数据存储空间大小是1M,由于存储空间大小是固定的,当入队元素的数量大于队列长度时,最先入队的元素会被弹出</li></ul></li><li>由来:每台服务器启动时,如果开启由AOF或被连接称为master节点,即创建复制缓冲区</li><li>作用:用于保存master收到的所有指令(影响数据变更的指令,set,select)</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/redis/image-20210727160107553.png" alt="image-20210727160107553"></p><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/redis/image-20210727160433257.png" alt="image-20210727160433257"></p></li></ul></li></ul></li></ul></li></ul><h3 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h3><ul><li><p>进入铭霖传播阶段时,master与slaver间需要进行信息交换,使用心跳机制进行维护,实现双方连接保持在线</p></li><li><p>master心跳</p><ul><li>指令:PING</li><li>周期:由repl-ping-slave-period决定,默认10秒</li><li>作用:判断slave是否在线</li><li>查询INFO replication 获取slave最后一次连接时间间隔,lag项维持在0或1视为正常</li></ul></li><li><p>slave心跳任务</p><ul><li>指令: REPLCONF ACK {offset}</li><li>周期: 1秒</li><li>作用:<ol><li>汇报slave自己的复制偏移量,获取最新的数据变更指令</li><li>判断master是否在线</li></ol></li></ul></li><li><p>心跳阶段注意事项</p><ul><li>当slave多数掉线,或延迟过高时,master为保障数据稳定性,将拒绝所有信息同步操作</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min-slaves-to-write 2</span><br><span class="line">min-slaves-max-lag 8</span><br></pre></td></tr></table></figure><ul><li>slave数量少于两个,或者所有slave的延迟都大于等于19秒时,强制关闭master写功能,停止数据同步</li><li>slave数量由slave发送REPLCONF ACK命令做确认</li><li>slave延迟由 slave发送REPLCONF ACK命令做确认</li></ul></li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/redis/image-20210727162034558.png" alt="image-20210727162034558"></p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li><p>频繁的全量复制(1)</p><ul><li>问题:master断开,runid更改,slave频繁全量复制</li><li>解决:将runid与offset保存入rdb中</li></ul></li><li><p>频繁全量复制(2)</p><ul><li><p>问题:网络环境不佳,出现网络中断,slave不提供服务</p></li><li><p>问题原因:复制缓冲区过小,断网后slave的offset越界,触发全量复制</p></li><li><p>最终结果:slave反复进行全量复制</p></li><li><p>解决方案:修改复制缓冲大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repl-backlog-size</span><br></pre></td></tr></table></figure></li><li><p>设置建议</p><ul><li>测算从master到slave的重来你平均时长second</li><li>获取master平均每秒产生写命令数据总量write_size_per_second</li><li>最优复制缓冲区空间= 2 * second * write_size_per_second</li></ul></li></ul></li><li><p>频繁的网络中断(1)</p><ul><li><p>问题现象</p><ul><li>master的CPU占用过高或slave频繁断开连接</li></ul></li><li><p>问题原因</p><ul><li>slave每1秒发送REPLCONF ACK命令到master</li><li>当slave接收到了慢查询(keys*,hgetall等),会大量占用CPU性能</li><li>master每1秒调用复制定时函数replicationCron(),比对slave发现长时间没有进行响应</li></ul></li><li><p>最终结果</p><ul><li>master各种资源(输出缓冲区、带宽、连接等)被严重占用</li></ul></li><li><p>解决方案</p><ul><li><p>通过设置合理的超时时间,确认是否释放slave</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repl-timeout 默认60s</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>频繁的网络中断(2)</p><ul><li><p>问题现象</p><ul><li>slave与master连接断开</li></ul></li><li><p>问题原因</p><ul><li>master发送ping指令频度较低</li><li>master设置超时时间较短</li><li>ping指令在网络中存在丢包</li></ul></li><li><p>解决方案</p><ul><li>提高ping指令发送的频度</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repl-ping-slave-period</span><br></pre></td></tr></table></figure><ul><li>超时时间repl-time的时间至少是ping指令频度的5到10被否则slave很容易判定超时</li></ul></li></ul></li><li><p>数据不一致</p><ul><li><p>问题现象</p><ul><li>多个slave获取相同数据不同步</li></ul></li><li><p>问题原因</p><ul><li>网络信息不同步,数据发送有延迟</li></ul></li><li><p>解决方案</p><ul><li>优化主从间的网络环境,通常放置同一个机房部署,如使用阿里云等云服务器时要注意此现象</li><li>监控主节从节点延迟(通过offset)判断,如果slave延迟过大,暂时屏蔽程序对slave的数据访问</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slave-serve-stale-data</span><br></pre></td></tr></table></figure><ul><li>开启后仅响应info、slaveof等少数命令(慎用,除非对数据一致性要求很高)</li></ul></li></ul></li></ul><h2 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h2><ul><li>简介  <ul><li>Slave启动成功连接到master后会发送一个sync命令</li><li>Master接到命令后启动后台的存盘进程,同时收集所有接收到的用于修改数据集命令,在后台进程执行完毕之后,master将传送整个数据文件到slave,以完成一个完全同步</li><li>全量复制:slave服务在接收到数据库文件数据后,将其存盘并加载到内存中。</li><li>增量复制:Master继续将新的所有收集到的修改命令依次传给Slave,完成同步</li><li>但是只要重新连接到master,一次完全同步(全量复制)将被自动执行</li></ul></li><li>理解<ul><li>master收到sync命令会启动存盘,收集所有接收到的修改数据命令,之后传输给slave</li><li>如果没有Sync命令,master接收到新的修改命令会直接将其传输给slave</li></ul></li></ul><h2 id="哨兵模式-sentinel"><a href="#哨兵模式-sentinel" class="headerlink" title="哨兵模式(sentinel)"></a>哨兵模式(sentinel)</h2><ul><li><p>简介</p><ul><li>自动反客为主:能够后台监控主机是否故障,如果故障了根据投票数自动将从库转换为主库</li></ul></li><li><p>作用</p><ul><li>监控<ul><li>不断的检查master和slave是否正常运行</li><li>master存活检测、master与slave运行情况检测</li></ul></li><li>通知(提醒)<ul><li>当被监控的服务器出现问题时,向其他(哨兵,客户端)发送通知</li></ul></li><li>自动故障转移<ul><li>断开master与slave连接,选取一个slave作为master,将其他slave连接到新的master,并告知客户端新的服务器地址</li></ul></li><li><strong>注意</strong>:哨兵也是一台redis服务器,只是不提供数据服务,通常哨兵配置数量为<strong>单数</strong></li></ul></li><li><p>配置哨兵</p><ul><li><p>配置一拖二的主从结构</p></li><li><p>配置三个哨兵(配置相同,端口不同)</p><ul><li>参看sentinel.conf</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">smonitor [yourName] [masterip] [masterport] n(检测到此服务器宕机的个数)</span><br><span class="line">down-after-milliseconds [yourName](与monitor的yourName相同) 30000 表示30秒没有响应则为宕机</span><br><span class="line">parallel-syncs [yourName] n(您希望同时进行数据同步的redis服务器的个数)</span><br><span class="line">failover-timeout [yourName] 180000(您希望多少秒内没有同步完成视为同步失败)</span><br></pre></td></tr></table></figure></li><li><p>启动哨兵</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel sentinel-端口号.conf</span><br></pre></td></tr></table></figure></li><li><p>使用</p><ul><li>配置文件sentinel.conf(<strong>名字绝对不能错</strong>)</li><li>在配置文件里面写入 <strong>sentinel monitor 被监控数据库名字(自己起名字) IP port 1(检测到此服务器宕机的个数)</strong></li><li>启动哨兵</li><li><strong>redis-sentinel /myredis/sentinel.conf</strong></li></ul></li><li><p>如果之前的master回来会不会冲突?</p><ul><li>不会冲突,回来之后成为slaver</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/redis/image-20210727142134202.png" alt="image-20210727142134202"></p></li><li><p>一组sentinel能同时监控多个Master</p></li></ul><h2 id="哨兵工作原理"><a href="#哨兵工作原理" class="headerlink" title="哨兵工作原理"></a>哨兵工作原理</h2><h3 id="阶段一-监控阶段"><a href="#阶段一-监控阶段" class="headerlink" title="阶段一:监控阶段"></a>阶段一:监控阶段</h3><ul><li><p>用于同步各个节点的状态信息</p><ul><li>获取各个sentinel的状态(是否在线)</li><li>获取master的状态<ul><li>master属性<ul><li>runid</li><li>role:master</li></ul></li><li>各个slave的详细信息</li></ul></li><li>获取所有slave的状态(根据master中的salve信息)<ul><li>runid</li><li>role:slave</li><li>master_host、master_port</li><li>offset</li><li>…</li></ul></li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/redis/image-20210727175934976.png" alt="image-20210727175934976"></p></li></ul><h3 id="阶段二-通知阶段"><a href="#阶段二-通知阶段" class="headerlink" title="阶段二:通知阶段"></a>阶段二:通知阶段</h3><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/redis/image-20210727180320240.png" alt="image-20210727180320240"></p><h3 id="阶段三-故障转移阶段"><a href="#阶段三-故障转移阶段" class="headerlink" title="阶段三:故障转移阶段"></a>阶段三:故障转移阶段</h3><ul><li><p>一个哨兵发现之后会在内部进行通信,其余哨兵收到信号会去围观</p></li><li><p>一个哨兵发现是主观下线</p><ul><li>flags:SRI_S_DOWN</li></ul></li><li><p>半数以上变为客观下线</p><ul><li>flags:SRI_O_DOWN</li></ul></li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/redis/image-20210727180641985.png" alt="image-20210727180641985"></p><ul><li>确认客观下线之后哨兵们会进行投票决定谁去处理后事</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/redis/image-20210727181009901.png" alt="image-20210727181009901"></p><ul><li><p>处理后事</p><ul><li><p>从服务器列表中挑选备选的master</p><ul><li>在线的</li><li>响应块的</li><li>与原master断开时间近的</li><li>优先级原则<ul><li>优先级</li><li>offset</li><li>runid</li></ul></li></ul></li><li><p>挑选好新master后</p><ul><li>向新master发送slaveof no one</li><li>向其他slave发送slaveof新masterIP端口</li></ul></li></ul></li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/redis/image-20210727181304816.png" alt="image-20210727181304816"></p><h2 id="复制的缺点"><a href="#复制的缺点" class="headerlink" title="复制的缺点"></a>复制的缺点</h2><ul><li>复制延时<ul><li>由于所有的写操作都是先在Master上操作,然后同步更新到Slaver上,所有Master同步到Slaver机器有一定的延迟,当系统很繁忙的时候,延迟问题会更加严重,Slaver机器数量的增加也会使这个问题更加严重</li></ul></li></ul><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><h3 id="现状问题"><a href="#现状问题" class="headerlink" title="现状问题"></a>现状问题</h3><ul><li>业务发展过程中遇到的峰值瓶颈<ul><li>redis提供的服务OPS可以达到10w/s,当前业务OPS已经达到20w/s</li><li>内存单机容量达到256G,当前业务需求内存容量1T</li><li>使用集群的方式可以快速解决上述问题</li></ul></li><li>一个集群至少要有三个主节点</li><li>分配原则尽量保证每个主数据库运行在不同的IP地址,每个从库和主库不在一个IP地址上</li></ul><h2 id="集群作用"><a href="#集群作用" class="headerlink" title="集群作用"></a>集群作用</h2><ul><li>分散单台服务器的访问压力,实现负载均衡</li><li>分散单台服务器的存储压力,实现可扩展性</li><li>降低单台服务器宕机带来的业务灾难</li></ul><h2 id="Redis集群内部设计"><a href="#Redis集群内部设计" class="headerlink" title="Redis集群内部设计"></a>Redis集群内部设计</h2><h3 id="数据存储设计"><a href="#数据存储设计" class="headerlink" title="数据存储设计"></a>数据存储设计</h3><ul><li>通过算法设计,计算出key应该保存的位置</li><li>将所有的存储空间计划切割成16384份,每台主机保存一部分,每分代表的是一个存储空间,不是一个key的保存空间</li><li>将key按照计算出的结果放到对应的存储空间</li><li>内部使用slot,一个机器持有一定的slot,增强了可扩展性</li></ul><h3 id="集群内部通讯设计"><a href="#集群内部通讯设计" class="headerlink" title="集群内部通讯设计"></a>集群内部通讯设计</h3><p>​    <img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/redis/image-20210727195833064.png" alt="image-20210727195833064"></p><ul><li>当外部来请求时,会使用迭代查询查询插槽表</li><li>集群中的slot会被记录在node日志文件里</li></ul><h2 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h2><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/redis/image-20210727200530572.png" alt="image-20210727200530572"></p><h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><ul><li>5.0以上使用redis-cli搭建集群</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;bin&#x2F;redis-cli  --cluster create 10.211.55.26:7001 10.211.55.26:7002 10.211.55.26:7003 10.211.55.26:7004 10.211.55.26:7005 10.211.55.26:7006 --cluster-replicas 1</span><br></pre></td></tr></table></figure><ul><li>1:采用最简单的方式配置集群,一台主机,一台从机</li><li>不能使用本地回环地址,要附上真实ip</li><li>需要在src目录下使用redis-cli执行</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/redis/image-20210727204706765.png" alt="image-20210727204706765"></p><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/redis/image-20210727205350049.png" alt="image-20210727205350049"></p><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/redis/image-20210727205648655.png" alt="image-20210727205648655"></p><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/redis/image-20210727205801345.png" alt="image-20210727205801345"></p><h2 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h2><ul><li>放数据,取数据<ul><li>连接客户端时使用redis-cli -c,使用set的时候会被重定向</li></ul></li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/redis/image-20210727210404187.png" alt="image-20210727210404187"></p><h2 id="主从下线与主从切换"><a href="#主从下线与主从切换" class="headerlink" title="主从下线与主从切换"></a>主从下线与主从切换</h2><ul><li>如果master掉下,则slave会变为master,master上线后变为slave</li></ul><h2 id="cluster配置"><a href="#cluster配置" class="headerlink" title="cluster配置"></a>cluster配置</h2><ul><li>cluster-enabled:设置加入cluster,成为其中的节点</li><li>cluster-confige-file:cluster配置文件名,该文件属于自动生成</li><li>cluster-node-timeout:节点服务响应超时时间,用于判定该节点是否下线或切换为从节点:线上30秒</li><li>cluster-migration-barrier:master连接的slave最小数量</li></ul><h2 id="SpringBoot操作cluster"><a href="#SpringBoot操作cluster" class="headerlink" title="SpringBoot操作cluster"></a>SpringBoot操作cluster</h2><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/redis/image-20210728095002963.png" alt="image-20210728095002963"><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/redis/image-20210728095046023.png" alt="image-20210728095046023"></p><h1 id="企业级解决方案"><a href="#企业级解决方案" class="headerlink" title="企业级解决方案"></a>企业级解决方案</h1><h2 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h2><ul><li>宕机<ul><li>服务器启动后快速宕机<ul><li>问题排查<ol><li>请求数据较高</li><li>主从之间吞吐量较大,数据同步操作频度高</li></ol></li><li>解决<ul><li>前置准备工作<ol><li>日常例行统计数据访问记录,统计访问频度较高的热点数据</li><li>利用LRU数据删除策略,构建数据留存队列<ul><li>例如:storm与kafka配合</li></ul></li></ol></li><li>准备工作<ol><li>将统计结果中的数据分类,根据级别,redis优先加载级别较高的热点数据</li><li>利用分布式多服务器同时进行数据读取,提速数据加载过程</li></ol></li><li>实施<ol><li>使用脚本程序固定出发数据预热过程</li><li>如果条件允许,使用了CDN(内容分发网络),效果会更好</li></ol></li></ul></li></ul></li><li>总结<ul><li>缓存预热就是系统启动前,提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候,先查询数据库,然后再将数据缓存的问题!用户直接查询事先被预热的缓存数据。</li></ul></li></ul></li></ul><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="数据库服务器崩溃-1"><a href="#数据库服务器崩溃-1" class="headerlink" title="数据库服务器崩溃(1)"></a>数据库服务器崩溃(1)</h3><ul><li>场景<ol><li>系统平稳运行过程中,忽然数据库连接量激增</li><li>应用服务器无法即使处理请求</li><li>大量408,500错误也买能出现</li><li>客户反复刷新页面获取数据</li><li>数据库崩溃</li><li>应用服务器崩溃</li><li>重启应用服务器无效</li><li>Redis服务器崩溃</li><li>Redis集群崩溃</li><li>重启数据库后再次被瞬间流量放倒</li></ol></li><li>问题排查<ol><li>在一个<strong>较短</strong>的时间内,缓存中<strong>较多</strong>的key集中过期</li><li>此周期内请求访问过期的数据,redis未命中,redis向数据库获取数据</li><li>数据库同时接收到大量请求无法及时处理</li><li>Redis大量请求被积压,开始出现超时现象</li><li>数据库流量激增,数据库崩溃</li><li>重启后仍然面对缓存中无数据可用</li><li>Redis服务器资源被严重占用.Redis服务器崩溃</li><li>Redis集群呈现崩塌,集群瓦解</li><li>应用服务器无法及时得到数据响应请求,来自客户端的请求数量越来越多,应用服务器崩溃</li><li>应用服务器,redis,数据库全部重启,效果不理想</li></ol></li><li>问题分析<ul><li>短时间</li><li>大量key集中过期</li></ul></li><li>解决方案(道)<ol><li>更多的页面静态化处理</li><li>构建多级缓存架构<ul><li>Nginx缓存+redis缓存+ehcache缓存</li></ul></li><li>检测Mysql严重好事业务进行优化<ul><li>对数据库的瓶颈排查:例如超时查询、耗时较高事务等</li></ul></li><li><strong>灾难预警机制</strong><ul><li>监控redis服务器性能指标<ul><li>cpu占用、cpu使用率</li><li>内存容量</li><li>查询平均响应时间</li><li>线程数</li></ul></li></ul></li><li>限流、降级<ul><li>短时间范围内牺牲一些客户体验,限制一部分请求访问,降低应用服务器压力,待业务低俗运转后再逐步放开访问</li></ul></li></ol></li><li>解决方案(术)<ol><li>LRU与LFU切换</li><li>数据有效期策略调整<ul><li>根据业务有效期进行分类错峰,A类90分钟,B类80分钟,C类70分钟</li><li>过期时间使用固定时间+随机值的形式,稀释集中到期的key的数量</li></ul></li><li>超热数据使用永久key</li><li>定期维护(自动+人工)<ul><li>对即将过期数据做访问量分析,确认是否演示,配合访问量统计,做热点数据的延时</li></ul></li><li>加锁<ul><li>慎用!</li></ul></li></ol></li><li>总结<ul><li>缓存雪崩就是瞬间过期数据量太大,导致对数据库服务器造成压力,如能够有效避免过期时间集中,可以有效解决雪崩现象的出现(越40%),配合其他策略一起使用,并监控服务器的运行数据,根据运行记录做快速调整</li></ul></li></ul><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><ul><li>问题排查<ul><li>Redis中某个key过期,该key访问量巨大</li><li>多个数据请求从服务器直接压到Redis后,均为名种</li><li>Redis再短时间内发起了大量对数据库中统一数据的访问</li></ul></li><li>问题分析<ul><li>单个key高热数据</li><li>key过期</li></ul></li><li>解决方案(术)<ol><li>预先设定<ul><li>以电商为例,每个电商根据店铺等级,指定若干款主打产品,再购物街期间,加大此类信息key的过期市场</li><li>注意:购物街不仅仅指当天,以及后续若干天,访问分支呈现逐渐降低的趋势</li></ul></li><li>现场调整<ul><li>监控访问量,对自然流量激增的数据演唱过期时间或设置为永久key</li></ul></li><li>后台刷新数据<ul><li>启动定时任务,高峰期来临之前,刷新数据有效期,确保不丢失</li></ul></li><li>二级缓存<ul><li>设置不同的失效时间,保障不会被哦同时淘汰就行</li></ul></li><li>加锁<ul><li>分布式锁,放置被击穿,但是要注意也是性能瓶颈,慎重!</li></ul></li></ol></li><li>总结<ul><li>单个高热数据过期的瞬间,数据访问量较大,未命中redis后,发起了大量对统一数据的数据库访问,导致对数据库服务器造成压力。应对策略应该再业务数据分析与预防方面进行,配合运行监控测试与即使调整策略,毕竟单个key的过期监控难度较高,配合雪崩处理策略即可</li></ul></li></ul><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><ul><li>数据库服务器崩溃(3)<ol><li>系统平稳运行中</li><li>应用服务器流量随时间增量较大</li><li>Redis服务器命中率随时间逐步降低</li><li>Redis内存平稳,内存无压力</li><li>Redis服务器CPU占用激增</li><li>数据库服务器压力激增</li><li>数据库崩溃</li></ol></li><li>问题排查<ol><li>Redis中大面积出现未命中</li><li>出现非正常URL访问</li></ol></li><li>问题分析<ol><li>获取的数据在数据库中也不存在,数据库查询未得到对应数据</li><li>Redis获取到null数据未进行持久化,直接返回</li><li>下次此类数据到达重复上述过程</li><li>出现黑客攻击服务器</li></ol></li><li>解决方案(术)<ol><li>缓存null<ul><li>对查询结果为null的数据进行缓存(长期使用,定期清理),设定短时限,例如30-60秒,最高5分钟</li></ul></li><li>白名单策略<ul><li>提前预热各种分类数据id对应的bitmaps,id作为bitmaps的offset,相当于设置了数据白名单。当加载正常数据时,放行,加载异常数据时直接拦截(效率偏低)</li><li>使用布隆过滤器(有关布隆过滤器的名种问题对当前状况可以忽略)</li></ul></li><li>实施监控<ul><li>实施监控redis命中率(业务正常范围时,通常会有一个波动值)与null数据的占比<ul><li>非活动试端波动:通常加测3-5倍,超过5倍纳入重点排查对象</li><li>活动试端波动,通常检测10-50倍,超过50倍纳入重点排查对象</li></ul></li><li>根据倍数不同,启动不同的排查流程。然后使用黑名单进行防控(运营)</li></ul></li><li>key加密<ul><li>问题出现后,临时启动防灾业务key,对key进行业务层传输加密服务,设定校验程序,过来的key校验</li><li>例如每天随机分配60个加密串,挑选2到3个,混淆到页面数据id中,发现访问key不满足规则,驳回数据访问</li></ul></li></ol></li><li>总结<ul><li>缓存穿透访问了不存在的数据,跳过了合法数据的redis数据缓存阶段,每次访问数据库,导致对数据库服务器造成压力。通常此类数据的出现量是一个较低额值,当出现此类情况以毒攻毒,并及时<strong>报警</strong>。应对策略应该在临预案防范方面多做文章。</li><li>无论黑名单还是白名单,都是对整体系统的压力,警报接触后尽快移除</li></ul></li></ul><h2 id="性能指标监控"><a href="#性能指标监控" class="headerlink" title="性能指标监控"></a>性能指标监控</h2><h3 id="性能指标-Performance"><a href="#性能指标-Performance" class="headerlink" title="性能指标:Performance"></a>性能指标:Performance</h3><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>instantaneous_ops-per-sec</td><td>平均每秒处理请求总数</td></tr><tr><td>hit rate(calculated)</td><td>缓存命中率(计算得出)</td></tr><tr><td>Latency</td><td>Redis响应一个请求的时间</td></tr></tbody></table><h3 id="内存指标-Memory"><a href="#内存指标-Memory" class="headerlink" title="内存指标:Memory"></a>内存指标:Memory</h3><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>used_memory</td><td>已使用内存</td></tr><tr><td>mem_fragmentation_ratio</td><td>内存碎片率</td></tr><tr><td>evicted_keys</td><td>由于最大内存限制被溢出的key数量</td></tr><tr><td>blocked_clients</td><td>由于BLPOP,BRPOP or BRPOPLPUSH二被阻塞的客户端</td></tr></tbody></table><h3 id="基本活动指标-Basic-activity"><a href="#基本活动指标-Basic-activity" class="headerlink" title="基本活动指标:Basic activity"></a>基本活动指标:Basic activity</h3><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>Connected_clients</td><td>客户端连接数</td></tr><tr><td>Connected_slaves</td><td>Slave数量</td></tr><tr><td>master_last_io_seconds_ago</td><td>最近一次主从交互之后的秒数</td></tr><tr><td>keyspace</td><td>数据库中key值总数</td></tr></tbody></table><h3 id="持久性指标-Persistence"><a href="#持久性指标-Persistence" class="headerlink" title="持久性指标:Persistence"></a>持久性指标:Persistence</h3><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>rdb_last_save_time</td><td>最后一次持久化保存到磁盘的时间戳</td></tr><tr><td>rdb_changes_since_last_save</td><td>自最后一次持久化依赖数据库的更改数</td></tr></tbody></table><h3 id="错误提示-Error"><a href="#错误提示-Error" class="headerlink" title="错误提示:Error"></a>错误提示:Error</h3><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>rejected_connections</td><td>由于达到maxclient限制而被拒绝的连接数</td></tr><tr><td>keyspace_misses</td><td>key值查找失败(没有命中)次数</td></tr><tr><td>master_link_down_since_seconds</td><td>主从断开的持续时间(以秒为单位)</td></tr></tbody></table><h2 id="监控方式"><a href="#监控方式" class="headerlink" title="监控方式"></a>监控方式</h2><ul><li><p>工具</p><ul><li>Cloud Insight Redis</li><li>Prometheus</li><li>Redis-stat</li><li>Redis-faina</li><li>RedisLive</li><li>zabbix</li></ul></li><li><p>命令</p><ul><li><p>benchmark</p><ul><li>命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark [-h] [-p] [-c] [-n&lt;requests&gt;] [-k]]</span><br></pre></td></tr></table></figure><ul><li>范例1</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark</span><br></pre></td></tr></table></figure><ul><li>50 个连接,10000次请求对应的性能</li><li>范例2</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark -c 100 -n 5000</span><br></pre></td></tr></table></figure><ul><li>100个连接,5000次请求对应的性能</li></ul></li><li><p>redis cli</p><ul><li><p>monitor</p></li><li><p>slowlog</p><ul><li>命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slowlog [operator]</span><br></pre></td></tr></table></figure><ul><li>get:获取慢查询日志</li><li>len:获取慢查询日志条数</li><li>reset:重置慢查询日志</li><li>相关配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slowlog-log-slower-than 1000 #设置慢查询的时间下限 单位:微妙</span><br><span class="line">slowlog-max-len 100 #设置慢查询命令对应的日志显示长度,单位:命令数</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> middleware </category>
          
          <category> nosql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> middleware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端三大框架之一vue</title>
      <link href="2021/07/20/vue-learn/"/>
      <url>2021/07/20/vue-learn/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue-js安装"><a href="#Vue-js安装" class="headerlink" title="Vue.js安装"></a>Vue.js安装</h1><ol><li>直接CDN引入</li><li>下载和引入</li><li>NPM安装<code>通过webpack和vue-cli使用</code></li></ol><h1 id="VUE-start"><a href="#VUE-start" class="headerlink" title="VUE start"></a>VUE start</h1><h2 id="第一个Vue程序"><a href="#第一个Vue程序" class="headerlink" title="第一个Vue程序"></a>第一个Vue程序</h2><ul><li><p>创建一个Vue对象</p></li><li><p>创建Vue对象的时候,传入了一些options:{}</p><ul><li>{}中包含了el属性:该属性决定了这个Vue对象挂载到哪一个元素上</li><li>{}中包含了data属性:该属性中通常会存储一些数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;&#123;&#123;message&#125;&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;..&#x2F;..&#x2F;js&#x2F;vue.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  &#x2F;&#x2F; let(es6定义变量)&#x2F;const(es6定义常量)</span><br><span class="line">  &#x2F;&#x2F;声明式编程</span><br><span class="line">  const app &#x3D; new Vue(&#123;</span><br><span class="line">    el: &#39;#app&#39;, &#x2F;&#x2F;用于挂载要管理的元素</span><br><span class="line">    data:&#123;</span><br><span class="line">      &#x2F;&#x2F;定义数据</span><br><span class="line">      message:&#39;你好,twen&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>创建vue对象需要引用,这样浏览器的控制台才能识别js对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  const app &#x3D; new Vue(&#123;</span><br><span class="line">    el: &#39;#app&#39;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      message: &#39;twen&#39;,</span><br><span class="line">      movies: [&#39;小黑猫&#39;,&#39;星际穿越&#39;,&#39;回家的诱惑&#39;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li><li><p>语法糖:简写 @click:v-on=</p><h2 id="options"><a href="#options" class="headerlink" title="options"></a>options</h2></li><li><p>el</p><ul><li>类型:string|HTMLElement</li><li>作用:决定Vue实例会管理哪一个Dom</li></ul></li><li><p>data</p><ul><li>类型:Object|Function(组件中data必须是一个函数)</li><li>Vue 实例对应的数据对象</li></ul></li><li><p>methods</p><ul><li>key : function </li></ul></li><li><p>函数与方法的区别:</p><ul><li>函数定义在对象外</li><li>方法定义在对象内<h1 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2></li></ul></li><li><p>Model View ViewModel</p><h1 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h1><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/lifecycle.png"></p><h1 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h1></li><li><p>一般情况下用于数据处理,返回变化后的属性</p><ul><li>如:lastName + firstName 计算后变为fullName</li><li>计算属性本质上是一个属性,调用时以属性调用</li><li><strong>计算属性具有缓存而methods没有缓存</strong></li><li>es6 forin返回下标,forof返回对象</li></ul></li><li><p>计算属性具有getter与setter,一般不用setter</p></li><li><p>computed与methods对比</p><ul><li>computed具有缓存<ul><li>如果没有改变缓存,comupted不会被频繁调用</li></ul></li><li>methods没有缓存<ul><li>不管怎样methods都会被调用<h1 id="es6语法"><a href="#es6语法" class="headerlink" title="es6语法"></a>es6语法</h1></li></ul></li></ul></li><li><p>let/var</p><ul><li><p>var</p><ul><li><p>var的设计可以堪称JavaScript语言设计上的错误,但是这种错误多半不能修复和移除,一位需要向后兼容</p><ul><li>大概十年前，Brendan Eich就决定修复这个问题,于是他添加了一个新的关键字:let</li><li>let相当于更完美的var</li></ul></li><li><p>块级作用域</p><ul><li>js中使用var来生命要给变量时,变量的作用域主要是和函数的定义有关</li></ul></li></ul></li></ul></li></ul><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h1 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h1><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul><li><p>如果函数需要参数但是没有传入,则参数位undefined</p></li><li><p>如果v-on调用函数时没有添加小括号,则会默认传入event对象</p></li><li><p><strong>调用方法时,如何手动的获取到浏览器参数的event对象,$event</strong></p><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2></li><li><p>事件冒泡:事件会向上传递直到window</p></li><li><p>@click.stop:阻止事件冒泡</p></li><li><p>@click.prevent:阻止默认事件,例如(submit的提交)</p></li><li><p>@keycode|alias:监听某个键盘的点击</p></li><li><p>@click.native:监听组件根元素的的原生事件</p></li><li><p>@click.once:只能按一次</p><h1 id="v-if-v-else-v-else-if"><a href="#v-if-v-else-v-else-if" class="headerlink" title="v-if,v-else,v-else-if"></a>v-if,v-else,v-else-if</h1></li><li><p>如果条件很多,使用compute返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &lt;span v-if&#x3D;&quot;status &#x3D;&#x3D; 0&quot;&gt;&lt;label for&#x3D;&quot;username&quot;&gt;用户账号&lt;&#x2F;label&gt;&lt;input id&#x3D;&quot;username&quot; placeholder&#x3D;&quot;请输入账号&quot;&gt; &lt;&#x2F;span&gt;</span><br><span class="line">  &lt;span v-else&#x3D;&quot;status &#x3D;&#x3D; 1&quot;&gt;&lt;label for&#x3D;&quot;email&quot;&gt;用户邮箱&lt;&#x2F;label&gt;&lt;input id&#x3D;&quot;email&quot; type&#x3D;&quot;email&quot; placeholder&#x3D;&quot;请输入邮箱&quot;&gt; &lt;&#x2F;span&gt;</span><br><span class="line">  &lt;br&gt;</span><br><span class="line">  &lt;button @click&#x3D;&quot;changeLoginMode&quot;&gt;切换登陆&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;..&#x2F;..&#x2F;js&#x2F;vue.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app &#x3D; new Vue(&#123;</span><br><span class="line">    el: &#39;#app&#39;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      status: 0,</span><br><span class="line">      modes: 2</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">      changeLoginMode()&#123;</span><br><span class="line">        this.status &#x3D; (this.status + 1) % this.modes;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><h1 id="v-show与v-if区别"><a href="#v-show与v-if区别" class="headerlink" title="v-show与v-if区别"></a>v-show与v-if区别</h1></li><li><p>v-show与v-if都能表示条件判断</p></li><li><p>v-if条件为false时,包含v-if指令的元素不会存在在dom中</p></li><li><p>v-show条件为false时,v-show为元素增加了display行内样式</p><h2 id="v-show与v-if选择"><a href="#v-show与v-if选择" class="headerlink" title="v-show与v-if选择"></a>v-show与v-if选择</h2></li><li><p>当需要在显示与隐藏之间切片很频繁时,使用v-show</p></li><li><p>当只有一次切换时,使用v-if减少dom渲染</p></li><li><p>遍历数组</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item,index) in collection&quot;</span>&gt;</span>&#123;&#123;index+1+&#x27;,&#x27;+item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../../js/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      collection:[</span><br><span class="line"><span class="javascript">        <span class="string">&#x27;linkedList&#x27;</span>,<span class="string">&#x27;arrayList&#x27;</span>,<span class="string">&#x27;Hashset&#x27;</span>,<span class="string">&#x27;vector&#x27;</span>,<span class="string">&#x27;Hashmap&#x27;</span>,<span class="string">&#x27;treeMap&#x27;</span></span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h1></li><li><p>格式(value,key,index)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(value,key) in info&quot;</span>&gt;</span>&#123;&#123;key+&#x27;,&#x27;+value&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>官方推荐v-for时添加key</p></li><li><p>将key与value绑定</p><ul><li>绑定之后会优先查看key与value是否发生变化</li><li>如果没有变化,复用</li><li>如果有变化,不会复用</li><li>语法 v-bind:key=”item” :key=”item”</li><li>key的作用是为了提高dom性能</li></ul></li><li><p>vue哪些数组的方法是响应式的</p><ol><li>push(数组最后添加元素):可一次push多个元素:利用可变长参数 T[]:泛型</li></ol><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210625102323445.png" alt="image-20210625102323445"></p><ol start="2"><li><p>pop(删除数组的最后一个元素)</p></li><li><p>shitf(删除数组的第一个元素)</p></li><li><p>unshift(在数组最前面添加元素):可一次添加多个元素:可变长参数</p></li></ol><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210625102310655.png" alt="image-20210625102310655"></p><ol start="5"><li>splice(插入,删除,替换):<ol><li>start:开始位置</li><li>deleteCount?(删除元素表示从当前位置删除几个,不传表示删除所有元素,替换元素,插入元素),后面用splica(1,3,’m’,’n’,’l’,’x’)</li></ol></li></ol><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210625102536896.png" alt="image-20210625102536896"></p><ol start="6"><li>sort(排序)</li><li>reverse(反转)</li></ol></li><li><p>通过索引修改数组中的元素非响应式</p><ul><li>如果需要修修改数组的元素,使用splice</li><li>使用set(要修改的对象,索引值,)</li></ul></li><li><p>保留小数:object.tofixed</p></li></ul><h1 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h1><ul><li>使用管道符</li><li>过滤器自动传入参数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">filters:&#123;</span><br><span class="line">  <span class="function"><span class="title">showPrice</span>(<span class="params">price</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;￥&quot;</span>+price.toFixed(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Javascript高阶函数"><a href="#Javascript高阶函数" class="headerlink" title="Javascript高阶函数"></a>Javascript高阶函数</h1><ul><li><p>编程范式:</p><ul><li>命令式编程/声明式编程</li><li>面向对象编程(第一公民:对象)/函数式编程(第一公民:函数):链式编程</li></ul></li><li><p>filter:过滤,将满足函数要求的数添加到数组中</p><ul><li>函数返回boolean true加入新数组,false略去</li></ul></li><li><p>map:映射,将得到的值进行用户的操作返回数组</p><ul><li>函数返回array</li></ul></li><li><p>reduce:求和,拥有一个初始值</p><ul><li>reduce(function(prevalue,now){},initial)<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> total = nums.filter(<span class="function"><span class="params">n</span> =&gt;</span> n &lt; <span class="number">100</span>).map(<span class="function"><span class="params">n</span> =&gt;</span> n*<span class="number">2</span>).reduce(<span class="function">(<span class="params">pre,n</span>) =&gt;</span> pre + n)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>有对象的箭头函数最好初始化为0</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.books.reduce(<span class="function">(<span class="params">pre,book</span>)=&gt;</span>pre + book.price*book.quantity,<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h1 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h1></li><li><p>lazy:懒加载,blur时才会刷新数据</p></li><li><p>number:指定数据类型为number,vue中数据大多为string</p></li><li><p>trim:去除两边的space</p></li></ul><h1 id="Mustache语法"><a href="#Mustache语法" class="headerlink" title="Mustache语法"></a>Mustache语法</h1><ul><li>将data中的文本数据插入到HTML中<ul><li>通过Mustache语法(双大括号)</li><li>Mustache:胡子,胡须</li></ul></li><li>具有表达式<ul><li>+拼接</li></ul></li><li>Mustache语法中可以添加方法getFullName()<h2 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h2></li><li>v-once<ul><li>添加了v-once之后数据不会具有动态响应</li></ul></li><li>v-html<ul><li>mustache语法仅支持字符串,如果带有标签则不会进行html化</li><li>需要用v-html=”url”让标签生效</li></ul></li><li>v-text:不够灵活,会覆盖掉标签内的text<ul><li>取代mustache语法,让html标签失效</li></ul></li><li>v-pre:取消解析mustache语法</li><li>v-cloak:基本不会使用<ul><li>在vue解析之前,div中有一个属性v-cloak</li><li>在vue解析之后,div中没有属性v-cloak<h2 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h2></li></ul></li><li>前面学习的指令主要作用是将值插入到我们的模板的内容当中</li><li>但是,除了内容需要动态来决定外，某些属性我们也希望动态来绑定<ul><li>比如动态绑定a元素的href属性</li><li>比如动态绑定img元素的src属性</li></ul></li><li>这个时候我们需要使用v-bind指令<ul><li>mustache属性不会被解析只会被当作字符串</li><li>指令:动态绑定属性</li><li>缩写: ：</li><li>预期: any(with argument) | Object (without argument)</li><li>参数: attrOrProp(optional)</li></ul></li><li>对象语法<ul><li>:class=”{active:isActive,non:isNon}</li></ul></li><li>使用方法传递:与v-on不同,v-bind方法必须加上()  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 :class&#x3D;&quot;getClass()&quot;&gt;hello&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getClass:function ()&#123;</span><br><span class="line">  return &#123;active:this.isActive,non:this.isNon&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态绑定style"><a href="#动态绑定style" class="headerlink" title="动态绑定style"></a>动态绑定style</h3></li><li>对象语法<ul><li>对象语法{key,value(value引号)}</li></ul></li><li>数组语法<ul><li>数组语法{key}</li><li>vue对象中<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data&#123;</span><br><span class="line">key : value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="什么是组件化"><a href="#什么是组件化" class="headerlink" title="什么是组件化"></a>什么是组件化</h1><ul><li><p>将页面功能拆分称为组件</p></li><li><p>组件集成为页面</p><h2 id="ES6新语法"><a href="#ES6新语法" class="headerlink" title="ES6新语法"></a>ES6新语法</h2></li><li><p>可以使用<code>定义字符串,</code>可以自动换行</p><h2 id="Vue组件化思想"><a href="#Vue组件化思想" class="headerlink" title="Vue组件化思想"></a>Vue组件化思想</h2></li><li><p>组件化是VUE.js中的重要思想</p><ul><li>它提供了一种抽象,让我们可以开发出一个个独立可复用的小组件来构造我们的应用</li><li>任何的引用都会被抽象成一颗组件树</li></ul></li><li><p>组件的使用分成三个步骤</p><ul><li>创建组件构造器<ul><li>Vue.extend()方法创建组件构造器</li></ul></li><li>注册组件<ul><li>Vue.component()方法(全局组件)</li></ul></li><li>使用组件<ul><li>在Vue实例中的作用范围内使用组件</li><li><strong>组件必须放在被vue托管的内容下</strong></li></ul></li></ul></li><li><p>全局组件和局部组件</p><ul><li>全局组件:可以在多个vue的实例下使用<ul><li>全局注册Vue.component(‘name’,component)</li></ul></li><li>局部组件:<ul><li>怎么注册的组件才是局部组件?</li><li>组件内部注册<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  components:&#123;</span><br><span class="line">    <span class="comment">//cpn,使用组件时的标签名</span></span><br><span class="line">    cpn:cpnC</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>父组件和子组件的区分</p><ul><li>组件注册在哪,哪就可以使用组件,不存在多继承关系<h2 id="组件注册语法糖"><a href="#组件注册语法糖" class="headerlink" title="组件注册语法糖"></a>组件注册语法糖</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">data: &#123;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line">components:&#123;</span><br><span class="line">  cpm2:&#123;</span><br><span class="line">    template:</span><br><span class="line">      <span class="string">`&lt;div&gt;test&lt;/div&gt;`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="模板的分离写法"><a href="#模板的分离写法" class="headerlink" title="模板的分离写法"></a>模板的分离写法</h2></li></ul></li><li><p>使用template标签</p><h2 id="组件可以访问Vue实例数据吗"><a href="#组件可以访问Vue实例数据吗" class="headerlink" title="组件可以访问Vue实例数据吗?"></a>组件可以访问Vue实例数据吗?</h2></li><li><p>不可以</p></li><li><p>组件是一个单独的功能模块的封装</p><ul><li>找个模块有属于自己的HTML模板,也应该有属于自己的属性data</li></ul></li><li><p>组件中的数据保存在哪?</p><ul><li>Vue组件应该有保存自己数据的地方</li><li>组件对象也有一个data属性(也可以有methods等属性）</li><li>只是这个data属性必须是一个函数</li><li>而且这个函数返回一个对象,对象内部保存着数据</li></ul></li><li><p>组件中的数据为什么需要成为一个函数?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">components:&#123;</span><br><span class="line">      cpm:&#123;</span><br><span class="line">        template: <span class="string">&#x27;#cpn&#x27;</span>,</span><br><span class="line">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="keyword">return</span>&#123;</span><br><span class="line">            title:<span class="string">&#x27;raiowandy&#x27;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li><li><p>组件需要复用,如果用函数里面的数据就不会相同</p><ul><li>同理于函数可以隔离作用域</li><li>模板复用,<strong>data如果只返回对象</strong>,则<strong>模板不会创建新的对象</strong>,等同于模板都操作<strong>同一个对象</strong></li></ul></li></ul><h2 id="父子组件的通信"><a href="#父子组件的通信" class="headerlink" title="父子组件的通信"></a>父子组件的通信</h2><h3 id="在开发中-往往一些数据确实需要从上层传递到下层"><a href="#在开发中-往往一些数据确实需要从上层传递到下层" class="headerlink" title="在开发中,往往一些数据确实需要从上层传递到下层"></a>在开发中,往往一些数据确实需要从上层传递到下层</h3><ul><li>比如在一个页面中,我们需要从服务器请求到了很多数据</li><li>其中一部分数据,并非是我们整个页面的大组件来展示的,而是需要下面的子组件进行展示</li><li>这个时候,并不会让子组件再次发送一个网络请求,而是直接让大组件将数据传递给<strong>小组件(子组件)</strong></li></ul><h3 id="如何进行父子组件间的通信"><a href="#如何进行父子组件间的通信" class="headerlink" title="如何进行父子组件间的通信?"></a>如何进行父子组件间的通信?</h3><ol><li><p>通过props向子组件传递数据</p><ol><li>子组件里使用属性props,props:[]</li><li>在模板上使用v-bind绑定子组件的属性</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span> <span class="attr">:cmovies</span>=<span class="string">&quot;movies&quot;</span> <span class="attr">:cmessage</span>=<span class="string">&quot;message&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;templ&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>哎呀<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in cmovies&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      &#123;&#123;cmessage&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">--------------------------------------------------------</span><br><span class="line">const cpn = &#123;</span><br><span class="line">    template:&#x27;#templ&#x27;,</span><br><span class="line">    props:[&#x27;cmovies&#x27;,&#x27;cmessage&#x27;]</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">const cpn = &#123;</span><br><span class="line">    template:&#x27;#templ&#x27;,</span><br><span class="line">    props:&#123;</span><br><span class="line">        cmovies:Array,</span><br><span class="line">        cmessage:&#123;</span><br><span class="line">type: String,</span><br><span class="line">default: &#x27;aaaaaaaa&#x27;</span><br><span class="line"><span class="comment">&lt;!--必须传入此值--&gt;</span></span><br><span class="line">required: true</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>可以使用数据验证<ul><li>String</li><li>Number</li><li>Boolean</li><li>Array</li><li>Object</li><li>Data</li><li>Function</li><li>Symbol</li><li>自定义类型</li></ul></li><li>可以提供默认值</li><li>props如果使用驼峰命令,比如cIn,则v-bind时属性需要改成c-in</li><li>总结<ol><li>数组,加引号</li><li>对象,确定参数类型</li><li>对象,确定默认值</li></ol></li></ul></li><li><p>通过事件向父组件发送消息</p><ul><li>子组件$emit(‘name’,param)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">    <span class="function"><span class="title">btnClick</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.$emit(<span class="string">&#x27;btn-click&#x27;</span>,item)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在组件标签处使用v-on监听事件</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span>&#123;&#123;counter&#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">con</span> @<span class="attr">comp-decre</span>=<span class="string">&quot;decrement&quot;</span> @<span class="attr">comp-incre</span>=<span class="string">&quot;increment&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">con</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;templ&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;comDecre&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;comIncre&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../../js/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> con = &#123;</span></span><br><span class="line"><span class="javascript">    template: <span class="string">&#x27;#templ&#x27;</span>,</span></span><br><span class="line">    methods:&#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">comDecre</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$emit(<span class="string">&#x27;comp-decre&#x27;</span>)</span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">comIncre</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$emit(<span class="string">&#x27;comp-incre&#x27;</span>)</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      counter: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    components:&#123;</span><br><span class="line">      con</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">decrement</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.counter--;</span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">increment</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.counter++;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="父子组件双向绑定"><a href="#父子组件双向绑定" class="headerlink" title="父子组件双向绑定"></a>父子组件双向绑定</h2><ul><li>修改任何父组件传向子组件的数据都需要将props的数据放入data里</li><li>props里修改因为是绑定所以会修改父组件的值</li><li>vue希望我们能够自己控制是否修改父组件的值,所以需要将其赋予子组件的data中,自己用事件决定是否修改父组件的值</li><li>v-model:<ul><li>v-bind绑定数据</li><li>event-target-value:input里value数据与@input一起使用</li></ul></li></ul><h2 id="父子组件的访问方式-children"><a href="#父子组件的访问方式-children" class="headerlink" title="父子组件的访问方式:$children"></a>父子组件的访问方式:$children</h2><ul><li>有时候我们需要父组件直接访问子组件,子组件直接访问父组件,或者是子组件访问根组件<ul><li>父组件访问子组件:使用$children或refs</li><li>子组件访问父组件:使用$parent</li></ul></li></ul><h2 id="父访问子"><a href="#父访问子" class="headerlink" title="父访问子"></a>父访问子</h2><h3 id="children-要想有父子关系必须在模板上进行挂载-一般不用-只有拿到所有的子组件才使用"><a href="#children-要想有父子关系必须在模板上进行挂载-一般不用-只有拿到所有的子组件才使用" class="headerlink" title="$children:要想有父子关系必须在模板上进行挂载:一般不用:只有拿到所有的子组件才使用"></a>$children:要想有父子关系必须在模板上进行挂载:一般不用:只有拿到所有的子组件才使用</h3><ul><li>this.$children是一个<strong>数组类型</strong>,它包含所有子组件对象</li><li>这里通过一个遍历,去除所有子组件的message状态</li></ul><h3 id="refs-用的非常多"><a href="#refs-用的非常多" class="headerlink" title="$refs:用的非常多"></a>$refs:用的非常多</h3><ul><li><p>对象类型,默认空对象</p></li><li><p>使用方法</p><ul><li><p>在组件上使用ref</p><ul><li>```javascript<br><cpn ref="aaa"></cpn><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 使用$ref.name拿到</span><br><span class="line"></span><br><span class="line">  * &#96;&#96;&#96;javascr</span><br><span class="line">    console.log(this.$refs.aaa);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>如果要调用子组件方法,则该方法必须要有返回值,而$children不需要写返回值</p><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210627104555830.png" alt="image-20210627104555830"></p></li><li><p>```javascript<br>methods:{<br>  showMessage(){</p><pre><code>return &#39;showMessage&#39;</code></pre><p>  }<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 子访问父</span><br><span class="line"></span><br><span class="line">### $parent:不建议使用</span><br><span class="line"></span><br><span class="line">* 会使子组件与父组件耦合度高</span><br><span class="line"></span><br><span class="line">### $root:访问根组件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 插槽</span><br><span class="line">## 为什么使用slot</span><br><span class="line">* 生活中的插槽</span><br><span class="line">* 生活中很多地方都有插槽,电脑的USB插槽,查办当中的电源插槽</span><br><span class="line">* 插槽的目的是拓展功能</span><br><span class="line">* 电脑USB可以插入U盘、硬盘、手机、音响、键盘、鼠标等</span><br><span class="line">* 组件中的插槽</span><br><span class="line">* 组件的插槽是为了组件的可扩展性</span><br><span class="line">* 让使用者可以决定组件内部的一些内容到底展示什么</span><br><span class="line">* 例子:移动网站中的导航栏</span><br><span class="line">* 移动开发中,几乎每个页面都有导航栏</span><br><span class="line">* 如何取封装这类组件</span><br><span class="line">* 他们有很多区别,但是也有很多共性</span><br><span class="line">* 抽取共性,保留不同</span><br><span class="line">## 使用slot</span><br><span class="line">* 模板中使用slot标签,可以添加默认值</span><br><span class="line">&#96;&#96;&#96;html</span><br><span class="line">&lt;template id&#x3D;&quot;cpn&quot;&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;我是组件&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;p&gt;我也是组件&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;slot&gt;&lt;button&gt;按钮&lt;&#x2F;button&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure></li><li><p>父模板中使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>哈哈哈<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;<span class="name">i</span>&gt;</span>咯咯咯<span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;<span class="name">button</span>&gt;</span>噜噜噜<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>一个插槽可以重复使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>啦啦啦啦<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="具名插槽使用"><a href="#具名插槽使用" class="headerlink" title="具名插槽使用"></a>具名插槽使用</h2></li><li><p>多插槽的使用</p><ul><li>为模板插槽命名<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>左边<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>中间<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>右边<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>使用插槽时slot标签<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-slot</span>(新版)/<span class="attr">slot</span>=<span class="string">&quot;left&quot;</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="编辑作用域"><a href="#编辑作用域" class="headerlink" title="编辑作用域"></a>编辑作用域</h2></li></ul></li><li><p>作用域插槽已被废弃</p></li><li><p>模板找变量去找所属组件的变量</p></li><li><p>父模板的所有东西都会在父级作用域内遍历</p></li><li><p>父组件替换插槽的标签,但是内容由子组件来提供</p></li><li><p>子组件的内容父组件用不同表现形式</p></li></ul><h3 id="父组件如何收到子组件的内容"><a href="#父组件如何收到子组件的内容" class="headerlink" title="父组件如何收到子组件的内容"></a>父组件如何收到子组件的内容</h3><ol><li><p>为了让 <code>user</code> 在父级的插槽内容中可用，我们可以将 <code>user</code> 作为 <code>&lt;slot&gt;</code> 元素的一个 attribute 绑定上去</p><ul><li>子组件</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template id=<span class="string">&quot;cpn&quot;</span>&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    <span class="comment">//为模板绑定内容data为自定义名字</span></span><br><span class="line">    &lt;slot :data(自定义)=<span class="string">&quot;pLanguage&quot;</span>&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &lt;li v-<span class="keyword">for</span>=<span class="string">&quot;item in pLanguage&quot;</span>&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    &lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><ul><li>父模板<ol><li>template标签</li><li>v-slot:default为绑定的属性取名,其中default为插槽名字v-slot:default可简写为v-slot=’name’</li><li>使用</li></ol></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>=<span class="string">&quot;slot&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">&quot;item in slot.data&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    <img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210627143957176.png" alt="image-20210627143957176"></p></li></ol><h1 id="为什么要进行模块化"><a href="#为什么要进行模块化" class="headerlink" title="为什么要进行模块化"></a>为什么要进行模块化</h1><h2 id="全局变量问题"><a href="#全局变量问题" class="headerlink" title="全局变量问题"></a>全局变量问题</h2><ul><li>全局变量会引起冲突</li><li>使用函数闭包,则代码复用性变差,全局变量无法使用</li></ul><h2 id="使用模块化可以解决这两个问题"><a href="#使用模块化可以解决这两个问题" class="headerlink" title="使用模块化可以解决这两个问题"></a>使用模块化可以解决这两个问题</h2><ul><li>使用模块作为出口</li><li>使用对象作为模块,模块作为变量的出口</li></ul><h2 id="常见的模块化-规范"><a href="#常见的模块化-规范" class="headerlink" title="常见的模块化 规范"></a>常见的模块化 规范</h2><ul><li><p>CommonJS(了解)</p><ul><li>模块化的两大核心</li><li>导入,导出<ul><li>var {prop,prop} = require(‘js’)</li><li>module.exports={prop,prop,function}</li></ul></li></ul></li><li><p>AMD</p></li><li><p>CMD</p></li><li><p>ES6的Modules</p><ul><li><p>import</p><ul><li>首先保证引入的文件type=”module”</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210627153931771.png" alt="image-20210627153931771"></p><ul><li>统一全部导入</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> aaa <span class="keyword">from</span> <span class="string">&#x27;./aaa.js&#x27;</span> </span><br></pre></td></tr></table></figure></li><li><p>export</p><ul><li>方式一</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  flag,</span><br><span class="line">  sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方式二</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> num1 = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> height = <span class="number">1.88</span></span><br></pre></td></tr></table></figure><ul><li>导出函数/类</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export function mul(num1,num2)&#123;</span><br><span class="line">return num1,num2</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;类</span><br><span class="line">export class Person&#123;</span><br><span class="line">function mul(num1,num2),</span><br><span class="line">num1 &#x3D; 1000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>export default:只能导出一个类</p><ul><li>某些情况下,一些模块具有一些功能但是我们不想为其取名字,名字由导入的用户而定</li><li>default导出的东西只能有一个,不然默认无法辨认</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> address = <span class="string">&#x27;北京市&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> address</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">argument</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> favor-name <span class="keyword">from</span> <span class="string">&#x27;js&#x27;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h1 id="webpack-前端模块化打包工具"><a href="#webpack-前端模块化打包工具" class="headerlink" title="webpack:前端模块化打包工具"></a>webpack:前端模块化打包工具</h1><h2 id="认识webpack"><a href="#认识webpack" class="headerlink" title="认识webpack"></a>认识webpack</h2><ul><li>webpack是一个现代的JavaScript应用的静态模块打包工具</li></ul><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><ul><li><p>模块化一些方案:AMD,CMD,CommonJs,ES6</p></li><li><p>webpack可以处理模块间的依赖关系</p></li><li><p>不仅仅JavaScript文件 ,Css，图片,json文件都会被当作模块来使用</p></li></ul><h3 id="打包-将入口与出口文件放入配置文件"><a href="#打包-将入口与出口文件放入配置文件" class="headerlink" title="打包:将入口与出口文件放入配置文件"></a>打包:将入口与出口文件放入配置文件</h3><ul><li>webpack为了可以正常运行,必须依赖于node环境</li><li>使用webpack识别设定的入口与出口webpack.config.js</li><li>path.resolve</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210628093047145.png" alt="image-20210628093047145"></p><ul><li>npm init后生成了<strong>package.json</strong>文件</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210628092710309.png" alt="image-20210628092710309"></p><h2 id="webpack的安装"><a href="#webpack的安装" class="headerlink" title="webpack的安装"></a>webpack的安装</h2><h2 id="webpack起步"><a href="#webpack起步" class="headerlink" title="webpack起步"></a>webpack起步</h2><h2 id="webpack的配置"><a href="#webpack的配置" class="headerlink" title="webpack的配置"></a>webpack的配置</h2><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210628094130159.png" alt="image-20210628094130159"></p><ul><li><p>优先使用本地的webpack,<strong>使用build采取npm run build映射</strong></p><ul><li>```json<br>“build”: “webpack”//本地<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 终端里面都是全局,所以需要定义脚本</span><br><span class="line"></span><br><span class="line">* package.json中scripts的脚本执行时会有次序</span><br><span class="line"></span><br><span class="line">  * 先执行本地,再执行全局</span><br><span class="line"></span><br><span class="line">### 开发时依赖</span><br><span class="line"></span><br><span class="line">* 只有在项目构建时才会使用  --save-dev</span><br><span class="line"></span><br><span class="line">![image-20210628094444862](https:&#x2F;&#x2F;twen-img-host.oss-cn-beijing.aliyuncs.com&#x2F;img&#x2F;vue&#x2F;image-20210628094444862.png)</span><br><span class="line"></span><br><span class="line">## loader的使用</span><br><span class="line"></span><br><span class="line">* 使用loader让webpack认识其他类型的文件</span><br><span class="line"></span><br><span class="line">  * webpack读取use从右向左读</span><br><span class="line"></span><br><span class="line">  * css-loader支付将css文件进行加载,不负责解析生效</span><br><span class="line">  * 需要使用style-loader:负责将样式添加到dom上</span><br><span class="line">  * 配置文件</span><br><span class="line"></span><br><span class="line">  ![image-20210628101216475](https:&#x2F;&#x2F;twen-img-host.oss-cn-beijing.aliyuncs.com&#x2F;img&#x2F;vue&#x2F;image-20210628101216475.png)</span><br><span class="line"></span><br><span class="line">* 没有使用loader的打包</span><br><span class="line"></span><br><span class="line">* 使用</span><br><span class="line"></span><br><span class="line">  * 安装</span><br><span class="line">  * 配置</span><br><span class="line"></span><br><span class="line">![image-20210628095820375](https:&#x2F;&#x2F;twen-img-host.oss-cn-beijing.aliyuncs.com&#x2F;img&#x2F;vue&#x2F;image-20210628095820375.png)</span><br><span class="line"></span><br><span class="line">### less,scss,stylus文件的配置</span><br><span class="line"></span><br><span class="line">* less</span><br><span class="line"></span><br><span class="line">![image-20210628102730523](https:&#x2F;&#x2F;twen-img-host.oss-cn-beijing.aliyuncs.com&#x2F;img&#x2F;vue&#x2F;image-20210628102730523.png)</span><br><span class="line"></span><br><span class="line">### 图片文件的处理</span><br><span class="line"></span><br><span class="line">* url的使用:如果超过limit则使用file-loader:file-loader不需要配置,只需要下载</span><br><span class="line"></span><br><span class="line">![image-20210628103823338](https:&#x2F;&#x2F;twen-img-host.oss-cn-beijing.aliyuncs.com&#x2F;img&#x2F;vue&#x2F;image-20210628103823338.png)</span><br><span class="line"></span><br><span class="line">* 配置文件</span><br><span class="line"></span><br><span class="line">![image-20210628103746740](https:&#x2F;&#x2F;twen-img-host.oss-cn-beijing.aliyuncs.com&#x2F;img&#x2F;vue&#x2F;image-20210628103746740.png)</span><br><span class="line"></span><br><span class="line">* 当图片小于limit会成为base64格式</span><br><span class="line">* 大于limit时会将图片进行打包放入dist,而index加载文件的路径在当前路径,因此会找不到</span><br><span class="line"></span><br><span class="line">![image-20210628104849811](https:&#x2F;&#x2F;twen-img-host.oss-cn-beijing.aliyuncs.com&#x2F;img&#x2F;vue&#x2F;image-20210628104849811.png)</span><br><span class="line"></span><br><span class="line">* 在output中添加publicPath,所有的文件路径都会到dist中寻找</span><br><span class="line"></span><br><span class="line">  ![image-20210628105807317](https:&#x2F;&#x2F;twen-img-host.oss-cn-beijing.aliyuncs.com&#x2F;img&#x2F;vue&#x2F;image-20210628105807317.png)</span><br><span class="line"></span><br><span class="line">* 管理图片</span><br><span class="line"></span><br><span class="line">  * 因为文件的hash值太长所以我们需要将其所见</span><br><span class="line">  * 在dist文件中生成img文件夹</span><br><span class="line"></span><br><span class="line">  ![image-20210628105653634](https:&#x2F;&#x2F;twen-img-host.oss-cn-beijing.aliyuncs.com&#x2F;img&#x2F;vue&#x2F;image-20210628105653634.png)</span><br><span class="line"></span><br><span class="line">### 使用Babel将ES6打包为ES5</span><br><span class="line"></span><br><span class="line">![image-20210628111548644](https:&#x2F;&#x2F;twen-img-host.oss-cn-beijing.aliyuncs.com&#x2F;img&#x2F;vue&#x2F;image-20210628111548644.png)</span><br><span class="line"></span><br><span class="line">## webpack中配置Vue</span><br><span class="line"></span><br><span class="line">* npm下载vue@2.6.14</span><br><span class="line"></span><br><span class="line">![image-20210628112147242](https:&#x2F;&#x2F;twen-img-host.oss-cn-beijing.aliyuncs.com&#x2F;img&#x2F;vue&#x2F;image-20210628112147242.png)</span><br><span class="line"></span><br><span class="line">* vue运行版本</span><br><span class="line">  * runtime-only-&gt;代码中不可以有任何template</span><br><span class="line">  * runtime-compiler-&gt;代码中可以有template,因为有compiler可以用于编译vue</span><br><span class="line"></span><br><span class="line">![image-20210628113132630](https:&#x2F;&#x2F;twen-img-host.oss-cn-beijing.aliyuncs.com&#x2F;img&#x2F;vue&#x2F;image-20210628113132630.png)</span><br><span class="line"></span><br><span class="line">指定版本</span><br><span class="line"></span><br><span class="line">![image-20210628113558392](https:&#x2F;&#x2F;twen-img-host.oss-cn-beijing.aliyuncs.com&#x2F;img&#x2F;vue&#x2F;image-20210628113558392.png)</span><br><span class="line"></span><br><span class="line">* html经过el挂载,vue里的template会替换</span><br><span class="line"></span><br><span class="line">### 配置.vue文件的loader</span><br><span class="line"></span><br><span class="line">* npm install vue-loader@15.4.2 vue-template-compiler@2.6.14 --save-dev</span><br><span class="line"></span><br><span class="line">  * 高版本loader添加plugin</span><br><span class="line"></span><br><span class="line">  ![image-20210628144655693](https:&#x2F;&#x2F;twen-img-host.oss-cn-beijing.aliyuncs.com&#x2F;img&#x2F;vue&#x2F;image-20210628144655693.png)</span><br><span class="line"></span><br><span class="line">  ![image-20210628144709285](https:&#x2F;&#x2F;twen-img-host.oss-cn-beijing.aliyuncs.com&#x2F;img&#x2F;vue&#x2F;image-20210628144709285.png)</span><br><span class="line"></span><br><span class="line">  ![image-20210628150323989](https:&#x2F;&#x2F;twen-img-host.oss-cn-beijing.aliyuncs.com&#x2F;img&#x2F;vue&#x2F;image-20210628150323989.png)</span><br><span class="line"></span><br><span class="line">  * compiler需要与vue版本一致</span><br><span class="line"></span><br><span class="line">* 使用别名</span><br><span class="line"></span><br><span class="line">  ![image-20210628145359872](https:&#x2F;&#x2F;twen-img-host.oss-cn-beijing.aliyuncs.com&#x2F;img&#x2F;vue&#x2F;image-20210628145359872.png)</span><br><span class="line"></span><br></pre></td></tr></table></figure>在resolve中添加  extensions: [‘.vue’],<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## plugin的使用</span><br><span class="line"></span><br><span class="line">* plugin是什么?</span><br><span class="line">  * plugin是插件的意思,通常是对于某个现有的架构进行扩展</span><br><span class="line">  * webpack中的插件,就是对webpack现有功能的各种扩展,比如打包优化,文件压缩等等</span><br><span class="line">* loader和plugin区别</span><br><span class="line">  * loader主要用于转换某些类型的模块,它是一个转换器</span><br><span class="line">  * plugin是插件,它实对webpack本身的扩展,是一个扩展器</span><br><span class="line">* plugin使用:</span><br><span class="line">  1. 通过npm安装需要使用的plugins(某些webpack已经内置的插件不需要安装)</span><br><span class="line">  2. 在webpack.config.js中的plugins中配置插件</span><br><span class="line"></span><br><span class="line">### 添加版权的Plugin</span><br><span class="line"></span><br><span class="line">![image-20210628150303279](https:&#x2F;&#x2F;twen-img-host.oss-cn-beijing.aliyuncs.com&#x2F;img&#x2F;vue&#x2F;image-20210628150303279.png)</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;javascript</span><br><span class="line">plugins:[</span><br><span class="line">    new webpack.BannerPlugin(&#39;最终版权归twen所有&#39;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul></li><li><p>使用插件需要引入</p></li></ul><h3 id="webpack-HtmlWebpackPlugin的使用"><a href="#webpack-HtmlWebpackPlugin的使用" class="headerlink" title="webpack-HtmlWebpackPlugin的使用"></a>webpack-HtmlWebpackPlugin的使用</h3><ul><li>将index导入dist文件夹中,可以将打包的js文件自动插入到body中</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210628151131744.png" alt="image-20210628151131744"></p><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210628151141439.png" alt="image-20210628151141439"></p><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210628151639427.png" alt="image-20210628151639427"></p><h4 id="两个问题"><a href="#两个问题" class="headerlink" title="两个问题"></a>两个问题</h4><ol><li><p>js文件引入路径问题    </p><ol><li>注释掉源index文件的js引入</li><li>将webpack中的publicPath去掉</li></ol></li><li><p>没有模板</p><ol><li>HtmlWebpackPlugin插件中添加模板对象</li></ol><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210628151920813.png" alt="image-20210628151920813"></p><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210628152817602.png" alt="image-20210628152817602"></p></li></ol><h3 id="压缩js-开发阶段不建议使用丑化"><a href="#压缩js-开发阶段不建议使用丑化" class="headerlink" title="压缩js:开发阶段不建议使用丑化"></a>压缩js:开发阶段不建议使用丑化</h3><ul><li><p>uglify压缩丑化</p></li><li><p>npm install <a href="mailto:&#117;&#103;&#108;&#x69;&#x66;&#121;&#106;&#x73;&#45;&#x77;&#101;&#98;&#112;&#97;&#99;&#107;&#x2d;&#112;&#x6c;&#117;&#103;&#x69;&#x6e;&#64;&#x31;&#x2e;&#x31;&#46;&#x31;">&#117;&#103;&#108;&#x69;&#x66;&#121;&#106;&#x73;&#45;&#x77;&#101;&#98;&#112;&#97;&#99;&#107;&#x2d;&#112;&#x6c;&#117;&#103;&#x69;&#x6e;&#64;&#x31;&#x2e;&#x31;&#46;&#x31;</a> –save-dev</p><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210628153907887.png" alt="image-20210628153907887"></p></li><li><p>丑化时会将声明删掉</p></li></ul><h2 id="部署本地服务器-实现热跟新"><a href="#部署本地服务器-实现热跟新" class="headerlink" title="部署本地服务器:实现热跟新"></a>部署本地服务器:实现热跟新</h2><h3 id="安装-webpack-dev-server"><a href="#安装-webpack-dev-server" class="headerlink" title="安装 webpack-dev-server"></a>安装 webpack-dev-server</h3><ul><li>npm install <a href="mailto:&#119;&#x65;&#x62;&#112;&#97;&#99;&#x6b;&#45;&#100;&#101;&#118;&#45;&#115;&#101;&#114;&#118;&#x65;&#x72;&#64;&#x32;&#46;&#x39;&#x2e;&#51;">&#119;&#x65;&#x62;&#112;&#97;&#99;&#x6b;&#45;&#100;&#101;&#118;&#45;&#115;&#101;&#114;&#118;&#x65;&#x72;&#64;&#x32;&#46;&#x39;&#x2e;&#51;</a> –save-dev</li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210628154607216.png" alt="image-20210628154607216"></p><ul><li>contentBase:服务文件夹</li><li>port:端口</li><li>inline:是否实时更新</li><li>不需要引入</li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li>使用package.json的脚本来使用本地dev文件</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210628155058055.png" alt="image-20210628155058055"></p><ul><li><p>自动打开浏览器,加上参数 –open</p><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210628155155007.png" alt="image-20210628155155007"></p></li></ul><h3 id="插件的打包与编译"><a href="#插件的打包与编译" class="headerlink" title="插件的打包与编译"></a>插件的打包与编译</h3><ul><li><p>丑化js代码在开发时不需要加入,而热编译文件在打包时不需要加入</p></li><li><p>如何进行配置文件的分离?</p><ul><li>npm install <a href="mailto:&#119;&#x65;&#x62;&#x70;&#x61;&#99;&#x6b;&#x2d;&#x6d;&#101;&#x72;&#x67;&#x65;&#x40;&#x34;&#x2e;&#x31;&#46;&#x35;">&#119;&#x65;&#x62;&#x70;&#x61;&#99;&#x6b;&#x2d;&#x6d;&#101;&#x72;&#x67;&#x65;&#x40;&#x34;&#x2e;&#x31;&#46;&#x35;</a> –save-dev</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210628160611084.png" alt="image-20210628160611084"></p><p>​    <img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210628160740486.png" alt="image-20210628160740486"></p></li><li><p>修改输出路径</p></li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210628161311003.png" alt="image-20210628161311003"></p><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><ul><li>似乎webpack.config.js文件会以package.json为中心开始搜索依赖、模板…</li></ul><h1 id="VUE-CLI"><a href="#VUE-CLI" class="headerlink" title="VUE CLI"></a>VUE CLI</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><ul><li>如果只是简单写几个Vue的Demo程序,就不需要Vue CLI</li><li>如果在开发大型项目,那么需要且必然使用Vue CLI</li><li>CLI 是Command-Line Interface 翻译为命令行界面,但是俗称脚手架</li><li>Vue CLI是一个官方发布vue,js项目脚手架</li><li>使用vue-cli可以快速搭建Vue开发环境以及对应的webpack配置</li></ul><h2 id="使用前提-Node"><a href="#使用前提-Node" class="headerlink" title="使用前提 Node"></a>使用前提 Node</h2><ul><li>安装NodeJs</li></ul><h2 id="使用前提webpack"><a href="#使用前提webpack" class="headerlink" title="使用前提webpack"></a>使用前提webpack</h2><h2 id="安装Vue脚手架"><a href="#安装Vue脚手架" class="headerlink" title="安装Vue脚手架"></a>安装Vue脚手架</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue&#x2F;cli</span><br></pre></td></tr></table></figure><h2 id="创建vue项目-through-vue-cli-gt-3-x"><a href="#创建vue项目-through-vue-cli-gt-3-x" class="headerlink" title="创建vue项目 through vue-cli &gt;@3.x"></a>创建vue项目 through vue-cli &gt;@3.x</h2><ul><li>vue create proj-name</li></ul><h2 id="拉取vue2-x的模板"><a href="#拉取vue2-x的模板" class="headerlink" title="拉取vue2.x的模板"></a>拉取vue2.x的模板</h2><ul><li><p>npm install -g @vue/cli-init</p></li><li><p>创建项目 <strong>vue init webpack proj-name</strong></p><ul><li>Project name:项目名</li><li>Project description(A Vue.js project):项目描述名称</li><li>Author (twen20010806<a href="mailto:&#49;&#50;&#53;&#56;&#x36;&#54;&#49;&#x30;&#52;&#49;&#64;&#x71;&#113;&#x2e;&#x63;&#x6f;&#x6d;">&#49;&#50;&#53;&#56;&#x36;&#54;&#49;&#x30;&#52;&#49;&#64;&#x71;&#113;&#x2e;&#x63;&#x6f;&#x6d;</a>):读取全局git</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210628213056922.png" alt="image-20210628213056922"></p><ul><li><p>Runtime+Compiler/Runtime-only</p><ul><li><p>推荐使用Runtime-only:轻量级    </p><ul><li>main.js中render直接转为虚拟dom,代码少</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210629093810521.png" alt="image-20210629093810521"></p><ul><li>而如果是.vue文件中则由vue-template-compiler转化为render函数而不传template,只传一个对象<ul><li>在运行前就已经将template编译为含有render方法的对象</li></ul></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">render:<span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//普通用法</span></span><br><span class="line">    <span class="comment">//createElement(&#x27;标签&#x27;,&#123;&#x27;标签属性&#x27;&#125;,[value])</span></span><br><span class="line">    <span class="keyword">return</span> createElement(<span class="string">&#x27;h2&#x27;</span>,&#123;<span class="attr">class</span>:<span class="string">&#x27;box&#x27;</span>&#125;,[<span class="string">&#x27;Hello World&#x27;</span>])</span><br><span class="line">    <span class="comment">//传入组件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Runtime+Compiler<ul><li>template -&gt; ast -&gt; render -&gt; vdom -&gt; UI</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template:<span class="string">&#x27;&lt;App/&gt;&#x27;</span>,</span><br><span class="line">components: &#123;App&#125;</span><br></pre></td></tr></table></figure></li><li><p>Install vue-router?(Y/n):是否安装vue路由</p></li><li><p>Use EsLint to lint your code?(Y/n):是否使用ES规范</p><ul><li>Pick an ESLint preset(Use arrow)<ul><li>Standard</li><li>Airbnb</li><li>none(configure it yourself)</li></ul></li></ul></li><li><p>Set up unit tests(Y/n):单元测试</p></li><li><p>Setup e2e tests with Nightwatch?(Y/n):</p><ul><li>end to end端到端测试</li><li>利用selenium或webdriver或phantomis等进行自动化测试的框架</li></ul></li><li><p>should we run <code>npm install</code> for you after the Project has been created?</p><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210628222511346.png" alt="image-20210628222511346"></p></li></ul></li></ul><h1 id="VUE-CLI3-x-4-x"><a href="#VUE-CLI3-x-4-x" class="headerlink" title="VUE CLI3.x|4.x"></a>VUE CLI3.x|4.x</h1><h2 id="vue-cli-3与2版本区别"><a href="#vue-cli-3与2版本区别" class="headerlink" title="vue-cli 3与2版本区别"></a>vue-cli 3与2版本区别</h2><ul><li>vue-cli3 是基于webpack4打造</li></ul><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><ul><li><p>vue create proj-name</p><ul><li>please pick a preset:选择预设</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210629095320914.png" alt="image-20210629095320914"></p><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210629095725394.png" alt="image-20210629095725394"></p><ul><li>Where do you prefer placing config for Babel,ESLint,etc.?</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210629095847914.png" alt="image-20210629095847914"></p><ul><li>Save this as a preset for future projects?</li></ul></li></ul><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210629101219227.png" alt="image-20210629101219227"></p><ul><li><p>public:会原封不动将此目录下的文件编译文件</p></li><li><p>main.js</p><p>​    <img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210629102207005.png" alt="image-20210629102207005" /></p></li></ul><h2 id="配置去哪了"><a href="#配置去哪了" class="headerlink" title="配置去哪了"></a>配置去哪了</h2><h3 id="UI方便的配置"><a href="#UI方便的配置" class="headerlink" title="UI方便的配置"></a>UI方便的配置</h3><ul><li>启动配置服务器 vue ui</li></ul><h3 id="创建vue-config-js"><a href="#创建vue-config-js" class="headerlink" title="创建vue.config.js"></a>创建vue.config.js</h3><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210629104309395.png" alt="image-20210629104309395"></p><h1 id="ES6箭头函数"><a href="#ES6箭头函数" class="headerlink" title="ES6箭头函数"></a>ES6箭头函数</h1><ul><li>一个参数小括号可省略</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> power = <span class="function"><span class="params">num</span> =&gt;</span> &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> power = <span class="function">(<span class="params">num1,num2</span>) =&gt;</span> &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>函数中只有一行代码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;有返回值</span><br><span class="line">const sum &#x3D; (num1,num2) &#x3D;&gt; num1 + num2</span><br><span class="line">const sum &#x3D; (num1,num2) &#x3D;&gt; &#123;</span><br><span class="line">&#x2F;&#x2F;多于一行代码放入大括号</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;没有返回值</span><br><span class="line">const demo &#x3D; () &#x3D;&gt; console.log(&#39;Hello Demo&#39;)</span><br></pre></td></tr></table></figure><ul><li>什么时候使用箭头函数<ul><li>对象中不推荐使用</li><li>一个函数中的参数是另一个函数时可以使用</li></ul></li><li>箭头函数的this<ul><li>箭头函数中的this引用的就是最近作用域中的this</li></ul></li></ul><h1 id="什么是路由"><a href="#什么是路由" class="headerlink" title="什么是路由"></a>什么是路由</h1><ul><li><p>路由是一个网络工程的术语</p></li><li><p>路由(routing)就是通过互联的网络把信息从源地址传输到目的地址的活动 –维基百科</p></li><li><p>路由器提供了两种机制:路由和转送</p><ul><li>路由是决定数据包从来源到目的地的路径</li><li>转送将输入端的数据转移到合适的输出端</li></ul></li><li><p>路由有一个非常重要的概念叫路由表</p><ul><li>路由表本质上就是一个映射表,决定了数据包的指向</li></ul></li></ul><h1 id="前端渲染"><a href="#前端渲染" class="headerlink" title="前端渲染"></a>前端渲染</h1><ul><li><p>后端路由有利于seo优化</p></li><li><p>前后端分离阶段:前端渲染</p><ul><li>后端只负责提供数据,不负责任何阶段的内容</li><li>ajax</li></ul></li><li><p>单页面复应用阶段</p><ul><li>SPA最主要特点实在前后端分离基础上加上了前端路由</li></ul></li></ul><h1 id="history与location-hash"><a href="#history与location-hash" class="headerlink" title="history与location.hash"></a>history与location.hash</h1><ul><li>history.pushState()<ul><li>入栈</li></ul></li><li>history.back()<ul><li>后退</li></ul></li><li>history.forward()<ul><li>向前</li></ul></li><li>history.go()<ul><li>负参数后退</li></ul></li><li>history.replace()<ul><li>替换,无法让网页进栈</li></ul></li><li>history运用了location.hash方法</li></ul><h1 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h1><ul><li><p>使用</p><ul><li>src下 的router文件夹创建index.js</li><li>导入Vue,vue-router</li><li>使用插件</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210629143122604.png" alt="image-20210629143122604"></p><ul><li>vue实例挂载</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210629141554660.png" alt="image-20210629141554660"></p><ul><li>App中template使用</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210629143441009.png" alt="image-20210629143441009"></p><ul><li>总结<ul><li>创建路由组件</li><li>配置路由映射</li><li>使用router-link和router-view</li></ul></li></ul></li></ul><h2 id="路由的默认设置"><a href="#路由的默认设置" class="headerlink" title="路由的默认设置"></a>路由的默认设置</h2><p>  <img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210629144250645.png" alt="image-20210629144250645"></p><h2 id="使用history模式而非hash"><a href="#使用history模式而非hash" class="headerlink" title="使用history模式而非hash"></a>使用history模式而非hash</h2><ul><li><p>hash模式的路径：<img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210629144321879.png" alt="image-20210629144321879"></p></li><li><p>使用history模式:</p><ul><li>在创建router组件时使用mode:history</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210629145046510.png" alt="image-20210629145046510"></p></li></ul><h2 id="router-link的其他属性"><a href="#router-link的其他属性" class="headerlink" title="router-link的其他属性"></a>router-link的其他属性</h2><ul><li><p>tag:tag可以指定&lt;router-link&gt;:vue3.x已经移除</p></li><li><p>replace:replace不会保留history记录</p></li><li><p>linkactiveclass</p><ul><li><p>router-link激活时会在按钮处动态添加删除class</p><ul><li>router-link-active</li><li>router-link-exact-active</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210629145808643.png" alt="image-20210629145808643"></p></li><li><p>可以修改</p><ol><li>在router-link标签上active-class</li></ol><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210629145854351.png" alt="image-20210629145854351"></p><ol start="2"><li>在router组件里linkActiveClass</li></ol></li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210629145933289.png" alt="image-20210629145933289"></p></li></ul><h2 id="使用代码跳转"><a href="#使用代码跳转" class="headerlink" title="使用代码跳转"></a>使用代码跳转</h2><ul><li>this.$router.push|replace|go.catch(err =&gt; err)</li><li>3.11版本以下需要捕获异常</li></ul><h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><ul><li>在某些情况下,一个页面的path路径可能是不确定的,比如我们进入用户页面时</li><li>this.$route:获取当前活跃的路由</li><li>官方推荐利用props传参减少与路由的耦合</li><li>组件里的props需要与路由里面的props相同</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210629160231781.png" alt="image-20210629160231781"></p><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210629160124685.png" alt="image-20210629160124685"></p><ul><li>to是属性需要绑定</li></ul><h2 id="打包文件解析"><a href="#打包文件解析" class="headerlink" title="打包文件解析"></a>打包文件解析</h2><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210629202655890.png" alt="image-20210629202655890"></p><ul><li>app:用户的代码:业务代码</li><li>manifest:对应用做底层支撑:地域支撑</li><li>vendor:第三方:vue/vue-router</li></ul><h2 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h2><ul><li><p>问题</p><ul><li>当打包构建应用时,Javascript包会变得非常大</li><li>影响页面加载</li></ul></li><li><p>解决办法</p><ul><li>将路由加载的文件封装到一个一个的组件中,使用时才引用</li></ul></li><li><p>懒加载方式</p><ul><li>ES6中,可以有更加简单的方法来组织路由懒加载</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210629204736463.png" alt="image-20210629204736463"></p><ul><li>打包后</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210629204813941.png" alt="image-20210629204813941"></p></li></ul><h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h2><ul><li><p>嵌套路是一个很常见的功能</p><ul><li>比如在home页面中,我们希望通过/home/news和/home/message访问一些内容</li><li>一个路径映射一个组件,访问这两个路径也会分别渲染两个组件</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210629211552907.png" alt="image-20210629211552907"></p><ul><li>使用path<ul><li>嵌套路由采用相对路径</li></ul></li></ul><h2 id="参数-传递"><a href="#参数-传递" class="headerlink" title="参数 传递"></a>参数 传递</h2><ul><li><p>传递参数主要有两种类型</p><ul><li><p>Params</p><ul><li>配置路由格式:/router/:id</li><li>传递方式:在path后面跟上对应的值</li><li>传递后形成的路径:/router/123,/router/abc</li><li>restful风格,pathVariable</li><li>参数少时适合</li></ul></li><li><p>query</p><ul><li>配置路由格式:/router,普通配置</li><li>传递方式:对象中使用query的key作为传递方式</li><li>传递后形成的路径:/router?id=123,/router?id=abc</li><li>传统风格,使用url?param传参,适合大量变量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:to&#x3D;&quot;&#123;path:&#39;&#39;,query:&#123;params:&#39;&#39;&#125;&#125;&quot;</span><br></pre></td></tr></table></figure><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210630092643213.png" alt="image-20210630092643213"></p><ul><li>使用函数传递</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210630092950198.png" alt="image-20210630092950198"></p></li></ul></li></ul></li></ul><h2 id="route和-router的区别"><a href="#route和-router的区别" class="headerlink" title="$route和$router的区别"></a>$route和$router的区别</h2><h3 id="router全局唯一"><a href="#router全局唯一" class="headerlink" title="router全局唯一"></a>router全局唯一</h3><h3 id="route是当前活跃的路由"><a href="#route是当前活跃的路由" class="headerlink" title="route是当前活跃的路由"></a>route是当前活跃的路由</h3><h3 id="所有的组件都继承自Vue类的原型"><a href="#所有的组件都继承自Vue类的原型" class="headerlink" title="所有的组件都继承自Vue类的原型"></a>所有的组件都继承自Vue类的原型</h3><h2 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h2><h3 id="Vue生命周期函数"><a href="#Vue生命周期函数" class="headerlink" title="Vue生命周期函数"></a>Vue生命周期函数</h3><ul><li>created</li><li>mounted</li><li>updated</li></ul><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><ul><li>在router.index.js中重写router.beforeEach(to,from,next)方法</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210630100442626.png" alt="image-20210630100442626"></p><ul><li><p>修改页面标题</p><ul><li>在route里添加meta:原数据</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210630100756603.png" alt="image-20210630100756603"></p><ul><li>在route.beforeEach方法中才做</li><li><strong>如果有路由嵌套</strong>则必须从route的matched中取出meta数据</li></ul></li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210630101219898.png" alt="image-20210630101219898"></p><ul><li><p>导航守卫的方式(全局守卫):需要通过router调用方法注册</p><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210630215449657.png" alt="image-20210630215449657"></p><ul><li>beforeEach:前置守卫</li><li>beforeresolve</li><li>afterEach:后置钩子<ul><li>不需要主动调用next函数</li></ul></li></ul></li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210630101526130.png" alt="image-20210630101526130"></p><ul><li><p>路由独享的守卫</p><ul><li>在路由里使用</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210630102634469.png" alt="image-20210630102634469"></p></li><li><p>组件内的守卫</p><ul><li>组件内使用<ul><li>beforeRouteEnter</li><li>beforeRouteUpdate</li><li>sbeforeRouteLeave</li></ul></li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210630102807128.png" alt="image-20210630102807128"></p></li></ul><h2 id="完整导航解析流程"><a href="#完整导航解析流程" class="headerlink" title="完整导航解析流程"></a>完整导航解析流程</h2><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210630103117617.png" alt="image-20210630103117617"></p><h2 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h2><ul><li><p>keep-alive时Vue内置的一个组件,可以使被包含的组件保留状态,或避免重新渲染</p></li><li><p>router-view也是一个组件,如果直接被包在keep-alive里面,所有路径匹配到的视图组件都会被缓存</p></li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/lifecycle.png" alt="img"></p><ul><li><p>keep-alive带入的两个函数</p><ul><li>因为keep-alive避免了组件重复被渲染,所以组件的created与destroyed不会经常被调用</li><li>activated()<ul><li>使用activated传入path参数</li></ul></li><li>deactivated()</li><li>组件里使用路由里的beforeRouteLeave</li><li>首页使用path属性记录离开时的路径</li></ul></li><li><p>keep-alive属性</p><ul><li>include-只有匹配的组件会被缓存,参数:组件的name</li><li>exclude-匹配的组件不会被缓存,参数:组件的name<ul><li>&lt;keep-alive exclude=”profile,user”&gt;</li></ul></li></ul></li></ul><p>##实验:TabBar实现</p><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h2 id="Promise解决异步操作问题"><a href="#Promise解决异步操作问题" class="headerlink" title="Promise解决异步操作问题"></a>Promise解决异步操作问题</h2><ul><li>一般情况下是有异步操作时使用promise对异步操作进行封装</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//网络请求</span></span><br><span class="line">    <span class="comment">//成功的时候调用resolve</span></span><br><span class="line">    resolve()</span><br><span class="line">    <span class="comment">//失败调用reject</span></span><br><span class="line">    reject(<span class="string">&quot;error message&quot;</span>)</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//请求处理</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   <span class="comment">//如果继续网络请求</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//网络请求,如果有参数resolve带入参数</span></span><br><span class="line">        resolve(data)</span><br><span class="line">       </span><br><span class="line">    &#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//这里处理异常</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>执行步骤<ul><li>new -&gt; 构造函数(1.保存了一些状态信息 2.执行传入的函数(resolve,reject) =&gt; {})</li><li>执行函数时传入参数resolve,reject</li><li>resolve,reject又是函数</li></ul></li></ul><h2 id="reject"><a href="#reject" class="headerlink" title="reject"></a>reject</h2><ul><li>当网络请求出现错误时使用reject,在函数后面使用catch捕获异常</li></ul><h2 id="promise三种状态"><a href="#promise三种状态" class="headerlink" title="promise三种状态"></a>promise三种状态</h2><ol><li>Pending:等待状态,比如正在进行网络请求或者定时器每有到时间</li><li>Fullfilled:满足状态,当我们调用resolve时在后面.then</li><li>Rejected:失败状态,当我们调用reject时在后面.catch</li><li>另一种调用方法then(fullfilled,rejected)</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">resolve()</span><br><span class="line">reject()</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">//这里处理正常信息</span></span><br><span class="line">&#125;,<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">//这里处理异常信息</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="promise链式操作"><a href="#promise链式操作" class="headerlink" title="promise链式操作"></a>promise链式操作</h2><ul><li>如果只对promise的结果进行链式封装,则是需要返回Promise的静态方法</li><li>如果要抛出异常,可以throw手动抛出也可以promise.reject(error message)</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210701144731532.png" alt="image-20210701144731532"></p><h2 id="Promise的all方法使用"><a href="#Promise的all方法使用" class="headerlink" title="Promise的all方法使用"></a>Promise的all方法使用</h2><ul><li>Promise.all([异步请求1,异步请求2])</li><li>Promise判断两个异步请求是否全部完成</li><li>后调用then函数传入结果results(数组对象)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">   asyn1,asyn2 </span><br><span class="line">]).then(<span class="function"><span class="params">results</span> =&gt;</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="什么是Vuex"><a href="#什么是Vuex" class="headerlink" title="什么是Vuex"></a>什么是Vuex</h1><ul><li><p>Vuex是一个专为Vue.js应用程序开发的状态管理模式</p><ul><li>它采用集中式存储管理应用的所有组件的状态,并以相应的规则保证状态以一种可预测的方式发生变化</li></ul></li><li><p>状态管理到底是什么?</p><ul><li>状态管理模式、集中式存储管理</li><li>简单认为,把需要多个组件共享的变量全部存储在一个对象里面</li><li>然后将这个对象放在顶层Vue实例中,让其他组件可以使用</li><li>那么多个组件是不是就可以共享这个对象的所有变量属性了呢?</li></ul></li></ul><h2 id="管理什么状态"><a href="#管理什么状态" class="headerlink" title="管理什么状态?"></a>管理什么状态?</h2><ul><li>用户的登陆状态、用户名称、头像、token</li><li>商品的收藏,购物车中的物品等等<ul><li>这些状态信息,我们都可以放在统一的地方,对它进行保存和管理,而且它们还是响应式的</li></ul></li></ul><h2 id="单页面状态的管理"><a href="#单页面状态的管理" class="headerlink" title="单页面状态的管理"></a>单页面状态的管理</h2><ul><li>Actions:用户行为</li><li>State:组件状态</li><li>View:视图</li></ul><h3 id="Vuex-Store-单例"><a href="#Vuex-Store-单例" class="headerlink" title="Vuex.Store:单例"></a>Vuex.Store:单例</h3><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210701155006578.png" alt="image-20210701155006578"></p><ul><li><p>全局读</p><ul><li>$store.state.xxx</li></ul></li><li><p>全局写</p><ul><li>使用Dispatch-&gt;Action-&gt;commit-&gt;Mutation-&gt;Mutate:便于开发工具追踪</li><li>Vue开发插件Devtools可以记录修改state的状态</li></ul></li></ul><h2 id="Vuex方法"><a href="#Vuex方法" class="headerlink" title="Vuex方法"></a>Vuex方法</h2><ul><li><p>state</p></li><li><p>mutations:处理同步</p><ul><li><p>Vuex更新store唯一方式:提交Mutation</p></li><li><p>mutation看作两部分</p><ul><li>事件类型</li><li>回调函数</li></ul></li><li><p>mutation传递参数:参数被称为payLoad(载荷)</p><ul><li>传递单个参数</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210702094021162.png" alt="image-20210702094021162"></p><ul><li>传递多个参数:使用对象</li></ul></li><li><p>mutation提交风格</p><ul><li><p>简单提交风格:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commit(&#39;incrementCount&#39;,data)</span><br></pre></td></tr></table></figure></li><li><p>特殊提交封装:会将参数封装成为对象(type,count等等)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">commit(&#123;</span><br><span class="line">type: &#39;increment&#39;,</span><br><span class="line">count</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210702095111789.png" alt="image-20210702095111789"></p><ul><li>传递对象</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210702095137733.png" alt="image-20210702095137733"></p></li></ul></li><li><p>mutation响应规则</p><ul><li>Vuex的store中的state是响应式的</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210702100113652.png" alt="image-20210702100113652"></p><ul><li>非响应式</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210702101144864.png" alt="image-20210702101144864"></p><ul><li>响应式:<ul><li>Vue.set:修改,增加</li><li>Vue.delete:删除</li></ul></li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210702101233463.png" alt="image-20210702101233463"></p></li></ul></li><li><p>actions:处理异步</p></li><li><p>getters:相当于vuex的计算属性</p><ul><li>如果要外部传入参数需要返回一个函数</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210702093647985.png" alt="image-20210702093647985"></p></li><li><p>modules</p></li></ul><h2 id="vuex-mutations的类型常量"><a href="#vuex-mutations的类型常量" class="headerlink" title="vuex-mutations的类型常量"></a>vuex-mutations的类型常量</h2><ul><li>mutation</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210702113643321.png" alt="image-20210702113643321"></p><ul><li><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210702113803388.png" alt="image-20210702113803388"></p></li><li><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210702114248174.png" alt="image-20210702114248174"></p></li></ul><h2 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h2><h3 id="mutations通常用于同步操作"><a href="#mutations通常用于同步操作" class="headerlink" title="mutations通常用于同步操作"></a>mutations通常用于同步操作</h3><ul><li>mutations追踪的是mutation快照</li><li>如果是异步操作,devtools将不能很好跟踪什么此操作什么时候完成</li></ul><h3 id="actions用于异步操作"><a href="#actions用于异步操作" class="headerlink" title="actions用于异步操作"></a>actions用于异步操作</h3><ul><li>action类似于mutation,用来代替mutation进行异步操作</li><li>action里不能直接修改值需要通过mutation</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">actions:&#123;</span><br><span class="line">&#x2F;&#x2F;获取上下文对象context(实际上就是store)</span><br><span class="line">updateInfo(context)&#123;</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F;利用mutation提交</span><br><span class="line">            context.commit(&#39;updateInfo&#39;)</span><br><span class="line">        &#125;,1000)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>调用action方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$store.dispatch(&#39;updateInfo&#39;)</span><br></pre></td></tr></table></figure><ul><li>携带payload,并且使用promise使其优雅</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210702141144976.png" alt="image-20210702141144976"></p><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210702141153480.png" alt="image-20210702141153480"></p><h2 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h2><ul><li>modules用来保存不同的数据模块</li><li>modules拥有自己的state,actions,mutation,getters</li></ul><h1 id="axois"><a href="#axois" class="headerlink" title="axois"></a>axois</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>在浏览器中发送XMLHttpRequests请求</li><li>在node,js中发送http请求</li><li>支持Promise API</li><li>拦截请求和响应</li><li>转换请去和响应数据</li></ul><h2 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h2><ul><li>axios({config})</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210703090720449.png" alt="image-20210703090720449"></p><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210703091100896.png" alt="image-20210703091100896"></p><ul><li><p>axios.method</p><ul><li>axios.get():参数用params传递</li><li>axios.post():参数用data传递</li></ul></li><li><p>并发请求(需要所有数据并处理),axios.all([axios,axios,axios….])</p><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210703090820626.png" alt="image-20210703090820626"></p></li></ul><h2 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h2><ul><li>axios.defaults.baseURL = ‘xxxx’</li><li>axios.defaults.headers.post[‘Cotent-Type’] = ‘application/x-www-form-rulencoded’</li><li>配置选项<ul><li>跨域是否带Token<ul><li>withCredentials</li><li>身份验证信息:{uname:’’,pwd:’’}</li><li>响应的数据格式:json,blob,document,arraybuffer/text/stream</li></ul></li></ul></li></ul><h2 id="axios的实例和模块封装"><a href="#axios的实例和模块封装" class="headerlink" title="axios的实例和模块封装"></a>axios的实例和模块封装</h2><ul><li><p>为什么要对axios封装?</p><ul><li>如果每个组件都import axios进行网络请求,那么以后修改就必须一个一个修改</li><li>而如果封装了网络请求,只需要对一个的文件进行修改</li></ul></li><li><p>并行请求的封装:</p><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210703104605026.png" alt="image-20210703104605026"></p><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210703104618023.png" alt="image-20210703104618023"></p></li></ul><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><ul><li><p>axios提供了拦截器,用于我们在发送每次请求或者得到响应后,阱行对用的处理</p></li><li><p>instance.interceptors.request|response.use(fullfilled,rejected)</p><ul><li>请求<ul><li>请求成功:param:config<ul><li>需要返回config</li><li>拦截器信息<ul><li>每次请求时,希望在界面中显示图标(转圈圈)</li><li>某些网络请求(比如token),必须携带一些特殊的信息</li></ul></li></ul></li><li>请求失败:param:err</li></ul></li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210703105932847.png" alt="image-20210703105932847"></p><ul><li><p>响应</p><ul><li><p>响应成功:param:res</p><ul><li>拦截成功相应需要放行res(return res)</li></ul><p><img src="https://twen-img-host.oss-cn-beijing.aliyuncs.com/img/vue/image-20210703110621842.png" alt="image-20210703110621842"></p></li><li><p>响应失败:param:err</p></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> front </category>
          
      </categories>
      
      
        <tags>
            
            <tag> framerwork </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot-data</title>
      <link href="2021/06/13/springboot-data/"/>
      <url>2021/06/13/springboot-data/</url>
      
        <content type="html"><![CDATA[<h1 id="数据访问"><a href="#数据访问" class="headerlink" title="数据访问"></a>数据访问</h1><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><ol><li>数据源的自动配置<ol><li>导入JDBC场景</li></ol></li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><img src="E:\资源\springboot-雷丰阳\springboot后源码\image-20210613115231185.png" alt="image-20210613115231185"></p><ol start="2"><li>数据库驱动为什么不导入?<ul><li>官方不知道我们需要操作什么数据库</li></ul></li><li>版本修改<ol><li>依赖就近原则,直接再pom里修改</li><li>属性就近原则,pom中properties中修改<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--改变版本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>8.0.20<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="自动配置的类"><a href="#自动配置的类" class="headerlink" title="自动配置的类"></a>自动配置的类</h3><ul><li>DataSourceAutoConfiguration:数据源的自动配置<ul><li>修改数据源相关的配置:spring.datasource</li><li>数据库连接池的配置,容器中没有DataSource自动配置</li><li>底层配置好的连接池是:HikariDataSource</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; DataSource.class, EmbeddedDatabaseType.class &#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(type = &quot;io.r2dbc.spi.ConnectionFactory&quot;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(DataSourceProperties.class)</span></span><br><span class="line"><span class="meta">@Import(&#123; DataSourcePoolMetadataProvidersConfiguration.class,</span></span><br><span class="line"><span class="meta">DataSourceInitializationConfiguration.InitializationSpecificCredentialsDataSourceInitializationConfiguration.class,</span></span><br><span class="line"><span class="meta">DataSourceInitializationConfiguration.SharedCredentialsDataSourceInitializationConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceAutoConfiguration</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>DataSourceTransactionManagerAutoConfiguration:事务管理的自动配置</li><li>JdbcTemplateAutoConfiguration:JdbcTemplate的自动配置<ul><li>可以修改这个配置项@ConfigurationProperteis(prefix=”spring.jdbc”)来修改jdbcTemplate</li><li>@Bean@Primary JdbcTemplate:容器中有此组件</li></ul></li><li>JndiDataSourceAutoConfiguration:Jndi的自动配置</li><li>XADataSourceAutoConfiguration:分布式事务相关</li></ul><h3 id="修改配置项"><a href="#修改配置项" class="headerlink" title="修改配置项"></a>修改配置项</h3><ul><li>url</li><li>driver-class-name</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/ssmBuild?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone</span> <span class="string">=</span> <span class="string">GMT</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="comment">#type: com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure><h3 id="整合第三方技术"><a href="#整合第三方技术" class="headerlink" title="整合第三方技术"></a>整合第三方技术</h3><ul><li><p>手动配置</p><ul><li>druid<ul><li>获取DataSource连接</li><li>获取DataSource连接之后便可以开始使用JdbcTemplate进行数据库操作</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Bean</span></span><br><span class="line"><span class="comment">//此处配置是为了与配置文件相关联</span></span><br><span class="line">   <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">       DruidDataSource dataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">       <span class="keyword">return</span> dataSource;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>配置监控项(Servlet,Filter):具体看druid官方</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 配置监控Servlet</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ServletRegistrationBean&lt;StatViewServlet&gt; <span class="title">statViewServlet</span><span class="params">()</span></span>&#123;</span><br><span class="line">       StatViewServlet statViewServlet = <span class="keyword">new</span> StatViewServlet();</span><br><span class="line">       ServletRegistrationBean&lt;StatViewServlet&gt; registrationBean = <span class="keyword">new</span> ServletRegistrationBean&lt;&gt;(statViewServlet, <span class="string">&quot;/druid/*&quot;</span>);</span><br><span class="line">       registrationBean.addInitParameter(<span class="string">&quot;loginUsername&quot;</span>,<span class="string">&quot;twen&quot;</span>);</span><br><span class="line">       registrationBean.addInitParameter(<span class="string">&quot;loginPassword&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> registrationBean;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 配置web应用监视</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> FilterRegistrationBean&lt;WebStatFilter&gt; <span class="title">webStatFilter</span><span class="params">()</span></span>&#123;</span><br><span class="line">       WebStatFilter webStatFilter = <span class="keyword">new</span> WebStatFilter();</span><br><span class="line">       FilterRegistrationBean&lt;WebStatFilter&gt; filterRegistrationBean = <span class="keyword">new</span> FilterRegistrationBean&lt;&gt;(webStatFilter);</span><br><span class="line">       <span class="comment">// &quot;/*&quot;会匹配所有路径 &quot;/**&quot;会匹配目录下的所有资源</span></span><br><span class="line">       filterRegistrationBean.setUrlPatterns(Arrays.asList(<span class="string">&quot;/*&quot;</span>));</span><br><span class="line"><span class="comment">//不对具有以下后缀的路径进行监控</span></span><br><span class="line">       filterRegistrationBean.addInitParameter(<span class="string">&quot;exclusions&quot;</span>,<span class="string">&quot;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> filterRegistrationBean;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>ServletRegistrationBean和FilterRegistrationBean都是通过反射获取属性名,所有会有addInitParameter方法传入属性名</li></ul></li></ul></li><li><p>使用druid场景启动器配置</p><ol><li>引入druid-starter</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>分析自动配置</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123;DruidDataSource.class&#125;)</span></span><br><span class="line"><span class="meta">@AutoConfigureBefore(&#123;DataSourceAutoConfiguration.class&#125;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;DruidStatProperties.class, DataSourceProperties.class&#125;)</span></span><br><span class="line"><span class="meta">@Import(&#123;DruidSpringAopConfiguration.class, DruidStatViewServletConfiguration.class, DruidWebStatFilterConfiguration.class, DruidFilterConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidDataSourceAutoConfigure</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>DruidSpringAopConfiguration.class,监控SpringBean的,配置项:spring-datasource-druid.aop-patterns</li><li>DruidStatViewServletConfiguration.class:监控页的配置,可以手动关闭</li></ul><p><img src="E:\资源\springboot-雷丰阳\springboot后源码\image-20210613153527287.png" alt="image-20210613153527287"></p><ul><li>DruidWebStatFilterConfiguration.class:web监控配置也可手动关闭</li></ul><p><img src="E:\资源\springboot-雷丰阳\springboot后源码\image-20210613153542631.png" alt="image-20210613153542631"></p><ul><li>DruidFilterConfiguration.class:所有Druid自己的filter的配置</li></ul><p><img src="E:\资源\springboot-雷丰阳\springboot后源码\image-20210613153702566.png" alt="image-20210613153702566"></p></li></ul><h3 id="整合mybatis"><a href="#整合mybatis" class="headerlink" title="整合mybatis"></a>整合mybatis</h3><h4 id="引入mybatis的场景启动器"><a href="#引入mybatis的场景启动器" class="headerlink" title="引入mybatis的场景启动器"></a>引入mybatis的场景启动器</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="配置模式"><a href="#配置模式" class="headerlink" title="配置模式"></a>配置模式</h4><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><ul><li>全局配置文件</li><li>SqlSessionfactory:自动配置好了</li><li>SqlSession:自动配置了<strong>SqlSessiontemplate</strong>组合了SqlSession<ul><li>Mybatis场景启动器会自动为每一个mapper接口添加一个autowired了SqlSession的实现类</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; factoryPropertyNames = (Set)Stream.of((<span class="keyword">new</span> BeanWrapperImpl(SqlSessionFactoryBean.class)).getPropertyDescriptors()).map(FeatureDescriptor::getName).collect(Collectors.toSet());</span><br><span class="line">Class&lt;? extends LanguageDriver&gt; defaultLanguageDriver = <span class="keyword">this</span>.properties.getDefaultScriptingLanguageDriver();</span><br><span class="line"><span class="keyword">if</span> (factoryPropertyNames.contains(<span class="string">&quot;scriptingLanguageDrivers&quot;</span>) &amp;&amp; !ObjectUtils.isEmpty(<span class="keyword">this</span>.languageDrivers)) &#123;</span><br><span class="line">    factory.setScriptingLanguageDrivers(<span class="keyword">this</span>.languageDrivers);</span><br><span class="line">    <span class="keyword">if</span> (defaultLanguageDriver == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.languageDrivers.length == <span class="number">1</span>) &#123;</span><br><span class="line">        defaultLanguageDriver = <span class="keyword">this</span>.languageDrivers[<span class="number">0</span>].getClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@Import(AutoConfiguredMapperScannerRegistrar.class)</li><li>Mapper:只要我们写的操作Mybatis的接口标注了Mapper注解</li></ul><h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><ol><li><p>导入Mybatis场景启动器</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写mapper接口与mapper映射器</p></li></ol><p><img src="E:\资源\springboot-雷丰阳\springboot后源码\image-20210613173123924.png" alt="image-20210613173123924"></p><ol start="3"><li><p>编写配置文件:</p><ul><li>xml映射器的位置</li><li>pojo类别名</li><li>配置文件:configuration</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mybatis/mapper/*.xml</span> <span class="comment">#配置映射</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.twen.springbootsysdemo1.bean</span> </span><br></pre></td></tr></table></figure></li></ol><h4 id="注解模式"><a href="#注解模式" class="headerlink" title="注解模式"></a>注解模式</h4><ul><li><p>小技巧,mapper.xml中可以使用哦个userGeneratedKeys来实现自增主键的返回,主键回填</p></li><li><p>引入mybatis-start</p></li><li><p>指定mapper-location即可</p></li><li><p>编写Mapper接口并标注@Mapper注解(使用于xml)</p></li><li><p>简单方法直接注解方式</p></li><li><p>复杂方法编写mapper.xml进行映射</p></li><li><p>@MapperScan(“packageName”),扫描Mapper接口</p></li></ul><h3 id="Mybatis-plus"><a href="#Mybatis-plus" class="headerlink" title="Mybatis-plus"></a>Mybatis-plus</h3><h4 id="什么是MyBatis-Plus"><a href="#什么是MyBatis-Plus" class="headerlink" title="什么是MyBatis-Plus?"></a>什么是MyBatis-Plus?</h4><h4 id="整合Mybatis-Plus"><a href="#整合Mybatis-Plus" class="headerlink" title="整合Mybatis-Plus:"></a>整合Mybatis-Plus:</h4><ul><li>已经导入jdbc,mybatis</li></ul><p><img src="E:\资源\springboot-雷丰阳\springboot后源码\image-20210613180312905.png" alt="image-20210613180312905"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>自动配置</p><ul><li>配置类绑定MybatisPlusProperties:底层是容器中的数据源</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123;SqlSessionFactory.class, SqlSessionFactoryBean.class&#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnSingleCandidate(DataSource.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;MybatisPlusProperties.class&#125;)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(&#123;DataSourceAutoConfiguration.class, MybatisPlusLanguageDriverAutoConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisPlusAutoConfiguration</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><img src="E:\资源\springboot-雷丰阳\springboot后源码\image-20210613180451762.png" alt="image-20210613180451762"></p><ul><li>SqlSessionFactory自动配置好</li><li>mapperLocations自动配置好:classpath:/mapper/**/*:任意包下的类路径下的所有mapper下的所有xml都是sql映射文件，建议以后都放在mapper下</li></ul><p><img src="E:\资源\springboot-雷丰阳\springboot后源码\image-20210613180800250.png" alt="image-20210613180800250"></p><ul><li>容器中也自动配置了SqlSessionTemplate</li><li>@Mapper标注的接口也会被自动扫描:建议直接@MapperScan(“path”)批量扫描就行</li></ul></li><li><p>优点:</p><ul><li>只需要Mapper接口继承BaseMapper<T>就可以拥有CRUD能力</li><li>简单查询不用写xml文件</li><li>Maybatis-plus会自动根据pojo名字找到名字相同的表</li><li>如果需要更换表名则在Mapper上通过@TableName注解更换</li></ul></li><li><p>基本查询</p><ul><li><p>tymleaf中的语法,</p><ul><li><p>sequence取出序列</p></li><li><p>{中使用()添加参数}</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;dataTables_paginate paging_bootstrap pagination&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--previous--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">th:class</span>=<span class="string">&quot;$&#123;page.current == 1?&#x27;prev disabled&#x27;:&#x27;prev&#x27;&#125;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>← Previous<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--current--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">th:class</span>=<span class="string">&quot;$&#123;number == page.current?&#x27;active&#x27;:&#x27;&#x27;&#125;&quot;</span> <span class="attr">th:each</span>=<span class="string">&quot;number:$&#123;#numbers.sequence(1,page.pages)&#125;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/dynamic_table.html(pn=$&#123;number&#125;)&#125;&quot;</span>&gt;</span>[[$&#123;number&#125;]]<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--next--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">th:class</span>=<span class="string">&quot;$&#123;page.current == page.pages?&#x27;next disabled&#x27;:&#x27;next&#x27;&#125;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Next → <span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">       </span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>每一列的写法Restful和普通的参数传递可以同时传递:th:href=”@{/user/delete/{id}(id=${user.id},pn=${page.current})</p></li></ul></li></ul></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;tr <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;gradeX&quot;</span> th:each=<span class="string">&quot;user,stat:$&#123;page.records&#125;&quot;</span>&gt;</span><br><span class="line">    &lt;td th:text=&quot;$&#123;stat.count&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">    &lt;td th:text=&quot;$&#123;user.id&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">    &lt;td th:text=&quot;$&#123;user.name&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">    &lt;td th:text=&quot;$&#123;user.age&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;[[$&#123;user.email&#125;]]&lt;/td&gt;</span><br><span class="line">    &lt;!--&lt;td&gt;Trident&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;Internet</span><br><span class="line">        Explorer 4.0&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;Win 95+&lt;/td&gt;</span><br><span class="line">    &lt;td class=&quot;center hidden-phone&quot;&gt;4&lt;/td&gt;--&gt;</span><br><span class="line">    &lt;td&gt;</span><br><span class="line">        &lt;a th:href=&quot;@&#123;/user/delete/&#123;id&#125;(id=$&#123;user.id&#125;,pn=$&#123;page.current&#125;)&#125;&quot; class=&quot;btn btn-danger btn-sm&quot; type=&quot;button&quot; &gt;delete&lt;/a&gt;</span><br><span class="line">    &lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br></pre></td></tr></table></figure><ul><li>controller中的写法<ul><li>运用redirectAttributes可以在重定向传递参数</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/user/delete/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">deleteUser</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="meta">@RequestParam(value = &quot;pn&quot;,defaultValue = &quot;1&quot;)</span> Integer pn,</span></span></span><br><span class="line"><span class="function"><span class="params">                             RedirectAttributes ra)</span></span>&#123;</span><br><span class="line">        userService.removeById(id);</span><br><span class="line">        System.out.println(<span class="string">&quot;pn&quot;</span>);</span><br><span class="line">        ra.addAttribute(<span class="string">&quot;pn&quot;</span>,pn);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/dynamic_table.html&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/dynamic_table.html&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">dynamic_table</span><span class="params">(<span class="meta">@RequestParam(value = &quot;pn&quot;,defaultValue = &quot;1&quot;)</span> Integer pn, Model model)</span></span>&#123;</span><br><span class="line">        List&lt;User&gt; list = userService.list();</span><br><span class="line"></span><br><span class="line">        Page&lt;User&gt; userPage = <span class="keyword">new</span> Page&lt;User&gt;(pn,<span class="number">2</span>);</span><br><span class="line">        Page&lt;User&gt; page = userPage;</span><br><span class="line">        userService.page(page);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;page&quot;</span>,page);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;tables/dynamic_table&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>获取分页插件</p><ul><li>在config文件中配置MybatisPlusInterceptor</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最新版</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MybatisPlusInterceptor <span class="title">mybatisPlusInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MybatisPlusInterceptor interceptor = <span class="keyword">new</span> MybatisPlusInterceptor();</span><br><span class="line">        <span class="comment">//这是分页拦截器</span></span><br><span class="line">        PaginationInnerInterceptor paginationInnerInterceptor = <span class="keyword">new</span> PaginationInnerInterceptor();</span><br><span class="line">        paginationInnerInterceptor.setMaxLimit(<span class="number">500L</span>);</span><br><span class="line">        interceptor.addInnerInterceptor(paginationInnerInterceptor);</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>也可以使用PageHelper</li></ul></li></ul><h3 id="SQL总结"><a href="#SQL总结" class="headerlink" title="SQL总结:"></a>SQL总结:</h3><ol><li><p>导入数据源场景启动器(默认hikari)</p></li><li><p>导入mybatis或myabtis场景启动器</p></li><li><p>编写配置文件</p></li><li><p>编写mapper接口与映射器</p></li><li><p>实现</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> datasource </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring-web</title>
      <link href="2021/06/12/springboot-web/"/>
      <url>2021/06/12/springboot-web/</url>
      
        <content type="html"><![CDATA[<h1 id="1-静态资源的配置"><a href="#1-静态资源的配置" class="headerlink" title="1.静态资源的配置"></a>1.静态资源的配置</h1><h2 id="1-1、修改静态资源的默认文件夹位置以及设置静态资源可以访问的路径"><a href="#1-1、修改静态资源的默认文件夹位置以及设置静态资源可以访问的路径" class="headerlink" title="1.1、修改静态资源的默认文件夹位置以及设置静态资源可以访问的路径"></a>1.1、修改静态资源的默认文件夹位置以及设置静态资源可以访问的路径</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">static-path-pattern:</span> <span class="string">/res/**</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">static-locations:</span> <span class="string">/haha</span></span><br></pre></td></tr></table></figure><h2 id="1-2、欢迎页支持"><a href="#1-2、欢迎页支持" class="headerlink" title="1.2、欢迎页支持"></a>1.2、欢迎页支持</h2><h3 id="1、静态资源下的index-html"><a href="#1、静态资源下的index-html" class="headerlink" title="1、静态资源下的index.html"></a>1、静态资源下的index.html</h3><ul><li>默认是index.html,名字不能边</li><li>如果修改了web访问路径,则不能找到主页,算是springboot的bug<h3 id="2、controller能处理-index"><a href="#2、controller能处理-index" class="headerlink" title="2、controller能处理/index"></a>2、controller能处理/index</h3></li></ul><h2 id="1-3、-静态资源配置原理"><a href="#1-3、-静态资源配置原理" class="headerlink" title="1.3、 静态资源配置原理"></a>1.3、 静态资源配置原理</h2><ul><li>SpringBoot启动默认加载 xxxAutoConfiguration类</li><li>SpringMVC功能的自动配置类 :org.SpringFrameWork.boot.autoconfigure/web/servlet/<strong>WebMvcAutoConfiguration</strong>生效<h3 id="WebMvcAutoConfiguration的注解"><a href="#WebMvcAutoConfiguration的注解" class="headerlink" title="WebMvcAutoConfiguration的注解"></a>WebMvcAutoConfiguration的注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,</span></span><br><span class="line"><span class="meta">ValidationAutoConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcAutoConfiguration</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li>当容器中有WebMvcConfigurationSupport.class的Bean时,SpringBoot的自动配置不会生效<ul><li>这意味着以后我们能够全权接管springMVC的配置<h3 id="WebMvcAutoCOnfiguration的内部类-WebMvcAutoConfigurationAdapter"><a href="#WebMvcAutoCOnfiguration的内部类-WebMvcAutoConfigurationAdapter" class="headerlink" title="WebMvcAutoCOnfiguration的内部类 WebMvcAutoConfigurationAdapter"></a>WebMvcAutoCOnfiguration的内部类 WebMvcAutoConfigurationAdapter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@Import(EnableWebMvcConfiguration.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123; WebMvcProperties.class,</span></span><br><span class="line"><span class="meta">org.springframework.boot.autoconfigure.web.ResourceProperties.class, WebProperties.class &#125;)</span></span><br><span class="line"><span class="meta">@Order(0)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcAutoConfigurationAdapter</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span>, <span class="title">ServletContextAware</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>@EnableConfigurationProperties:将此配置类于其他配置类关联<ul><li>WebMvcProperties.class：spring.mvc</li><li>org.springframework.boot.autoconfigure.web.ResourceProperties.class:spring.resources</li><li>WebProperties.class</li></ul></li><li><strong>配置中只有一个有参构造器</strong><ul><li>有参构造器所有参数的值都会从容器中确定<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WebMvcAutoConfigurationAdapter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">//获取和spring.resources绑定的所有值的对象</span></span></span><br><span class="line"><span class="function"><span class="params">org.springframework.boot.autoconfigure.web.ResourceProperties resourceProperties,</span></span></span><br><span class="line"><span class="function"><span class="params">//获取和其他配置类</span></span></span><br><span class="line"><span class="function"><span class="params">WebProperties webProperties, WebMvcProperties mvcProperties, </span></span></span><br><span class="line"><span class="function"><span class="params">//spring的bean工厂</span></span></span><br><span class="line"><span class="function"><span class="params">ListableBeanFactory beanFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">//找到所有的messageConverters</span></span></span><br><span class="line"><span class="function"><span class="params">ObjectProvider&lt;HttpMessageConverters&gt; messageConvertersProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">//找到用户的资源自定义器</span></span></span><br><span class="line"><span class="function"><span class="params">ObjectProvider&lt;ResourceHandlerRegistrationCustomizer&gt; resourceHandlerRegistrationCustomizerProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">//资源处理路径</span></span></span><br><span class="line"><span class="function"><span class="params">ObjectProvider&lt;DispatcherServletPath&gt; dispatcherServletPath,</span></span></span><br><span class="line"><span class="function"><span class="params">//给应用注册原生的Servlet,Filter</span></span></span><br><span class="line"><span class="function"><span class="params">ObjectProvider&lt;ServletRegistrationBean&lt;?&gt;&gt; servletRegistrations)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.resourceProperties = resourceProperties.hasBeenCustomized() ? resourceProperties</span><br><span class="line">: webProperties.getResources();</span><br><span class="line"><span class="keyword">this</span>.mvcProperties = mvcProperties;</span><br><span class="line"><span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line"><span class="keyword">this</span>.messageConvertersProvider = messageConvertersProvider;</span><br><span class="line"><span class="keyword">this</span>.resourceHandlerRegistrationCustomizer = resourceHandlerRegistrationCustomizerProvider.getIfAvailable();</span><br><span class="line"><span class="keyword">this</span>.dispatcherServletPath = dispatcherServletPath;</span><br><span class="line"><span class="keyword">this</span>.servletRegistrations = servletRegistrations;</span><br><span class="line"><span class="keyword">this</span>.mvcProperties.checkConfiguration();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>相关<ul><li><p>ObjectProvider<ResourceHandlerRegistrationCustomizer> resourceHandlerRegistrationCustomizerProvider</p><ul><li>找到用户的资源自定义器</li><li>资源处理默认规则</li></ul><p>   @Override<br>   public void addResourceHandlers(ResourceHandlerRegistry registry) {</p><pre><code>   //如果静态资源路径映射开启,则默认的静态资源配置无效,isAddMappings默认true   if (!this.resourceProperties.isAddMappings()) &#123;       logger.debug(&quot;Default resource handling disabled&quot;);       return;   &#125;   addResourceHandler(registry, &quot;/webjars/**&quot;, &quot;classpath:/META-INF/resources/webjars/&quot;);   addResourceHandler(registry, this.mvcProperties.getStaticPathPattern(), (registration) -&gt; &#123;       registration.addResourceLocations(this.resourceProperties.getStaticLocations());       if (this.servletContext != null) &#123;           ServletContextResource resource = new ServletContextResource(this.servletContext, SERVLET_LOCATION);           registration.addResourceLocations(resource);       &#125;   &#125;);</code></pre><p>   }</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* 默认四个静态资源位置</span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">private static final String[] CLASSPATH_RESOURCE_LOCATIONS &#x3D; &#123; &quot;classpath:&#x2F;META-INF&#x2F;resources&#x2F;&quot;,</span><br><span class="line">&quot;classpath:&#x2F;resources&#x2F;&quot;, &quot;classpath:&#x2F;static&#x2F;&quot;, &quot;classpath:&#x2F;public&#x2F;&quot; &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>欢迎页的配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WelcomePageHandlerMapping <span class="title">welcomePageHandlerMapping</span><span class="params">(ApplicationContext applicationContext,</span></span></span><br><span class="line"><span class="function"><span class="params">FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider)</span> </span>&#123;</span><br><span class="line">WelcomePageHandlerMapping welcomePageHandlerMapping = <span class="keyword">new</span> WelcomePageHandlerMapping(</span><br><span class="line"><span class="keyword">new</span> TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(),</span><br><span class="line"><span class="keyword">this</span>.mvcProperties.getStaticPathPattern());</span><br><span class="line">welcomePageHandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider));</span><br><span class="line">welcomePageHandlerMapping.setCorsConfigurations(getCorsConfigurations());</span><br><span class="line"><span class="keyword">return</span> welcomePageHandlerMapping;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>原理</p><ul><li>HandlerMapping:处理器映射,保存了每一个Handler你能处理哪些请求</li><li>WelcomePageHandlerMapping<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">WelcomePageHandlerMapping(TemplateAvailabilityProviders templateAvailabilityProviders,</span><br><span class="line">ApplicationContext applicationContext, Resource welcomePage, String staticPathPattern) &#123;</span><br><span class="line"><span class="comment">//欢迎页的映射为/**,则会走到欢迎页</span></span><br><span class="line"><span class="keyword">if</span> (welcomePage != <span class="keyword">null</span> &amp;&amp; <span class="string">&quot;/**&quot;</span>.equals(staticPathPattern)) &#123;</span><br><span class="line">logger.info(<span class="string">&quot;Adding welcome page: &quot;</span> + welcomePage);</span><br><span class="line">setRootViewName(<span class="string">&quot;forward:index.html&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果映射不为/**否则打印Adding welcome page template: index</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (welcomeTemplateExists(templateAvailabilityProviders, applicationContext)) &#123;</span><br><span class="line">logger.info(<span class="string">&quot;Adding welcome page template: index&quot;</span>);</span><br><span class="line">setRootViewName(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li></ul><h2 id="1-4、-请求参数处理"><a href="#1-4、-请求参数处理" class="headerlink" title="1.4、 请求参数处理"></a>1.4、 请求参数处理</h2><h3 id="1、请求映射"><a href="#1、请求映射" class="headerlink" title="1、请求映射"></a>1、请求映射</h3><ul><li><p>@xxxMapping:</p></li><li><p>Rest风格支持</p><ul><li><p>一般表单只能处理Get,Post请求</p></li><li><p>如果需要处理Put,Delete,springBoot默认支持</p><ul><li>需要以Post方式传输,并且传输一个隐藏input<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">valule</span>=<span class="string">&quot;DELETE&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h4 id="需要springboot配置开启Rest风格"><a href="#需要springboot配置开启Rest风格" class="headerlink" title="需要springboot配置开启Rest风格"></a>需要springboot配置开启Rest风格</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(HiddenHttpMethodFilter.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.mvc.hiddenmethod.filter&quot;, name = &quot;enabled&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> OrderedHiddenHttpMethodFilter <span class="title">hiddenHttpMethodFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> OrderedHiddenHttpMethodFilter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Rest风格原理(表单提交使用Rest)<ul><li>表单提交会带上”_method”隐藏域</li><li>请求会被filter拦截,处理请求</li><li>HiddenHttpMethodFilter</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"><span class="comment">//原生request</span></span><br><span class="line">    HttpServletRequest requestToUse = request;</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&quot;POST&quot;</span>.equals(request.getMethod()) &amp;&amp; request.getAttribute(<span class="string">&quot;javax.servlet.error.exception&quot;</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">          String paramValue = request.getParameter(<span class="keyword">this</span>.methodParam);</span><br><span class="line">          <span class="keyword">if</span> (StringUtils.hasLength(paramValue)) &#123;</span><br><span class="line"><span class="comment">//转为大写</span></span><br><span class="line">              String method = paramValue.toUpperCase(Locale.ENGLISH);</span><br><span class="line">              <span class="keyword">if</span> (ALLOWED_METHODS.contains(method)) &#123;</span><br><span class="line">                  requestToUse = <span class="keyword">new</span> HiddenHttpMethodFilter.HttpMethodRequestWrapper(request, method);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      filterChain.doFilter((ServletRequest)requestToUse, response);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">      ALLOWED_METHODS = Collections.unmodifiableList(Arrays.asList(HttpMethod.PUT.name(), HttpMethod.DELETE.name(), HttpMethod.PATCH.name()));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li><p>请求是否正常并且时POST</p><ul><li>获取到_method的值</li><li>大小写的method的value都可以</li><li>兼容以下请求,PUT,DELETE,PATCH</li><li>原生request(post),包装模式的requestWrapper重写了getmethod方法,返回的是传入的值,以后的方法调用的getMethod是调用requestWrapper的getMethod方法</li></ul></li><li><p>Rest使用客户端工具</p><ul><li>可以使用postMan直接发送put,delete等方式请求,无需使用filter</li></ul></li><li><p>因为表单只能发送get,post,所以才需要开启配置</p></li><li><p>如果前端能直接发送,则不需要开启配置</p></li><li><p>如何定制_method的名字</p><ul><li>继承HiddenHttpMethodFilter</li><li>通过setMethodParam方法修改</li></ul><p>  public void setMethodParam(String methodParam) {</p><pre><code>    Assert.hasText(methodParam, &quot;&#39;methodParam&#39; must not be empty&quot;);    this.methodParam = methodParam;</code></pre><p>}</p></li></ul><h3 id="2、普通参数与基本注解"><a href="#2、普通参数与基本注解" class="headerlink" title="2、普通参数与基本注解"></a>2、普通参数与基本注解</h3><ul><li>注解:  @PathVariable、@RequestHeader、@ModelAttribute、@RequestParam、@MatrixVariale、@CookieValue、@RequstBody<ol><li><p>@PathVariable:路径变量</p></li><li><p>@RequestHeader:获取请求头</p></li><li><p>@RequestParam:获取请求参数</p></li><li><p>@RequestBody:获取请求体[post]:只能用map封装,因为post请求是将信息封装再送</p><ul><li>以上可以用map&lt;String,String&gt;封装</li></ul></li><li><p>@CookieValue:获取cookie的值   </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@GetMapping(&quot;/getCar/&#123;id&#125;/owner/&#123;type&#125;&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getCar</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="keyword">int</span> id,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="meta">@PathVariable(&quot;type&quot;)</span> String type,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="meta">@PathVariable</span> Map&lt;String,String&gt; carMap,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="meta">@RequestHeader(&quot;Cache-Control&quot;)</span> String date,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="meta">@RequestHeader</span> Map&lt;String,String&gt; headers,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="meta">@RequestParam(&quot;username&quot;)</span> List&lt;String&gt; username,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="meta">@RequestParam</span> Map&lt;String,String&gt; params,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="meta">@CookieValue(&quot;Idea-5e32799b&quot;)</span> String cookieVal,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="meta">@CookieValue(&quot;Idea-5e32799b&quot;)</span> Cookie cookie)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="comment">/*map.put(&quot;id&quot;,id+&quot;&quot;);</span></span><br><span class="line"><span class="comment">       map.put(&quot;type&quot;,type);</span></span><br><span class="line"><span class="comment">       map.put(&quot;map&quot;,carMap);</span></span><br><span class="line"><span class="comment">       map.put(&quot;data:&quot;,date);</span></span><br><span class="line"><span class="comment">       map.put(&quot;headers&quot;,headers);</span></span><br><span class="line"><span class="comment">       map.put(&quot;username&quot;,username);</span></span><br><span class="line"><span class="comment">       map.put(&quot;params&quot;,params);</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">    map.put(<span class="string">&quot;cookieVal&quot;</span>,cookieVal);</span><br><span class="line">    map.put(<span class="string">&quot;cookieName&quot;</span>,cookie.getName());</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@RequestAttribute:获取request域属性</p><ul><li>不可以用map封装</li></ul></li></ol></li></ul><ol start="7"><li><p>@MatrixVariable:矩阵变量</p><pre><code> * http://localhost/cars/sell;low=34;brand=byd,audi,yd          * 矩阵变量必须要封装在路径变量里</code></pre>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@GetMapping(&quot;/cars/sell/&#123;boss&#125;/&#123;employee&#125;&quot;)</span></span><br><span class="line">    <span class="comment">//eg:/cars/sell/boss;id=1;name=twen/employee;id=2;name=twen(boss,employee不能重名)</span></span><br><span class="line">* 如果有多个相同的变量封装在不同的路径里,需要在参数里加<span class="meta">@PathVariable</span>    </span><br><span class="line">    ```java</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title">sellCars</span><span class="params">(<span class="meta">@MatrixVariable(value = &quot;id&quot;,pathVar = &quot;boss&quot;)</span> <span class="keyword">int</span> low,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="meta">@MatrixVariable(&quot;brand&quot;)</span> List&lt;String&gt; brand)</span></span></span><br><span class="line"><span class="function">#### springboot默认禁用矩阵变量功能</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">* URLPathHelper-&gt;removeSemicolonContent-&gt;setRemoveSemicolonContent</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  * 对于路径处理用UrlPathHelper解析</span></span><br><span class="line"><span class="function">  * removeSemicolonContent支持矩阵变量<span class="params">(移除分号内容)</span>默认<span class="keyword">true</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">* 两种办法:都是重写configurePathMatch接口</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  1. 直接注册一个bean-&gt;WebMvcConfigurer</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  ```java</span></span><br><span class="line"><span class="function">  @Bean</span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> WebMvcConfigurer <span class="title">webMvcConfigurer</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> WebMvcConfigurer() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configurePathMatch</span><span class="params">(PathMatchConfigurer configurer)</span> </span>&#123;</span><br><span class="line">              UrlPathHelper urlPathHelper = <span class="keyword">new</span> UrlPathHelper();</span><br><span class="line">              urlPathHelper.setAlwaysUseFullPath(<span class="keyword">false</span>);</span><br><span class="line">              configurer.setUrlPathHelper(urlPathHelper);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p> 实现WebMvcConfigurer接口</p></li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configurePathMatch</span><span class="params">(PathMatchConfigurer configurer)</span></span>&#123;</span><br><span class="line">    UrlPathHelper urlPathHelper = <span class="keyword">new</span> UrlPathHelper();</span><br><span class="line">    <span class="comment">//不移除分号后面的内容,矩阵变量功能可以生效</span></span><br><span class="line">    urlPathHelper.setRemoveSemicolonContent(<span class="keyword">false</span>);</span><br><span class="line">    configurer.setUrlPathHelper(urlPathHelper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果参数配置错误会出现400</li><li>Servlet API:   WebRequest、ervletRequest、MultipartRequest、HttpSession、javax.servlet.http.PushBuilder、Principal、InputStream、     Reader、HttpMethod、Locale、TimeZone、Zoneld</li><li>复杂参数   Map、Errors/BindingResult、Model、RedirectAttributes、ServletResponse、SessionStatus、UriComponentsBuilder、ServletUriComponentsBuilder</li><li>自定义对象参数 可以自动类型转化与格式化,可以级联封装</li></ul><h2 id="1-5、-参数处理的原理"><a href="#1-5、-参数处理的原理" class="headerlink" title="1.5、 参数处理的原理"></a>1.5、 参数处理的原理</h2><ul><li>HandlerMapping中能找到处理请求的Handler(Controller.method)</li><li>为当前Handler找到一个适配器HandlerAdapter:RequestMappingHandlerAdapter</li></ul><h3 id="1-HandlerAdapter"><a href="#1-HandlerAdapter" class="headerlink" title="1.HandlerAdapter"></a>1.HandlerAdapter</h3><ol><li><p>RequestMappingHandlerAdapter</p></li><li><p>HandlerFunctionAdapter</p></li></ol><h3 id="2-执行目标方法"><a href="#2-执行目标方法" class="headerlink" title="2.执行目标方法"></a>2.执行目标方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DispatcherServlet</span></span><br><span class="line">mv = ha.handle(processedRequest,response,mappedHandler.getHandler())</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行目标方法</span></span><br><span class="line">mav = invokeHandlerMethod(request,response,handlerMapping)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//ServletInvocableHandlerMethod,真正执行目标方法</span></span><br><span class="line">Object returnValue = invokeForRequest(webRequest,mavContainer,providedArgs)</span><br><span class="line"><span class="comment">//获取方法参数值</span></span><br><span class="line">Object[] args = getMethodArgumentValues(request,mavContainner,providedArgs)</span><br></pre></td></tr></table></figure><h3 id="3-参数解析器"><a href="#3-参数解析器" class="headerlink" title="3.参数解析器"></a>3.参数解析器</h3><ul><li>确定将要执行的目标方法的每一个参数是什么</li><li>SpringMVC目标方法能写多少种参数类型,取决于参数解析器</li></ul><p><img src="E:\资源\springboot-雷丰阳\springbootWeb\image-20210607172110860.png" alt="image-20210607172110860"></p><ul><li>当前解析器是否支持这种参数</li><li>返回值处理器</li></ul><h3 id="4、如何确定目标方法每一次参数的值"><a href="#4、如何确定目标方法每一次参数的值" class="headerlink" title="4、如何确定目标方法每一次参数的值"></a>4、如何确定目标方法每一次参数的值</h3><ul><li>InvocableHandlerMethod</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object[] getMethodArgumentValues(NativeWebRequest request, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer, Object... providedArgs) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    MethodParameter[] parameters = <span class="keyword">this</span>.getMethodParameters();</span><br><span class="line">    <span class="keyword">if</span> (ObjectUtils.isEmpty(parameters)) &#123;</span><br><span class="line">        <span class="keyword">return</span> EMPTY_ARGS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Object[] args = <span class="keyword">new</span> Object[parameters.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameters.length; ++i) &#123;</span><br><span class="line">            MethodParameter parameter = parameters[i];</span><br><span class="line">            parameter.initParameterNameDiscovery(<span class="keyword">this</span>.parameterNameDiscoverer);</span><br><span class="line">            args[i] = findProvidedArgument(parameter, providedArgs);</span><br><span class="line">            <span class="keyword">if</span> (args[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">this</span>.resolvers.supportsParameter(parameter)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(formatArgumentError(parameter, <span class="string">&quot;No suitable resolver&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    args[i] = <span class="keyword">this</span>.resolvers.resolveArgument(parameter, mavContainer, request, <span class="keyword">this</span>.dataBinderFactory);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception var10) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                        String exMsg = var10.getMessage();</span><br><span class="line">                        <span class="keyword">if</span> (exMsg != <span class="keyword">null</span> &amp;&amp; !exMsg.contains(parameter.getExecutable().toGenericString())) &#123;</span><br><span class="line">                            logger.debug(formatArgumentError(parameter, exMsg));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">throw</span> var10;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> args;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1、挨个判断哪个参数解析器能解析此参数"><a href="#4-1、挨个判断哪个参数解析器能解析此参数" class="headerlink" title="4.1、挨个判断哪个参数解析器能解析此参数"></a>4.1、挨个判断哪个参数解析器能解析此参数</h4><p><img src="E:\资源\springboot-雷丰阳\springbootWeb\image-20210607184055678.png" alt="image-20210607184055678"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HandlerMethodArgumentResolver result = (HandlerMethodArgumentResolver)<span class="keyword">this</span>.argumentResolverCache.get(parameter);</span><br><span class="line"><span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">    Iterator var3 = <span class="keyword">this</span>.argumentResolvers.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(var3.hasNext()) &#123;</span><br><span class="line">        HandlerMethodArgumentResolver resolver = (HandlerMethodArgumentResolver)var3.next();</span><br><span class="line">        <span class="keyword">if</span> (resolver.supportsParameter(parameter)) &#123;</span><br><span class="line">            result = resolver;</span><br><span class="line">            <span class="keyword">this</span>.argumentResolverCache.put(parameter, resolver);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2、解析这个参数的值"><a href="#4-2、解析这个参数的值" class="headerlink" title="4.2、解析这个参数的值"></a>4.2、解析这个参数的值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;HandlerMethodArgumentResolverComposite.class</span><br><span class="line">@Nullable</span><br><span class="line">public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception &#123;</span><br><span class="line">    HandlerMethodArgumentResolver resolver &#x3D; this.getArgumentResolver(parameter);</span><br><span class="line">    if (resolver &#x3D;&#x3D; null) &#123;</span><br><span class="line">    throw new IllegalArgumentException(&quot;Unsupported parameter type [&quot; + parameter.getParameterType().getName() + &quot;]. supportsParameter should be called first.&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F;执行此方法解析参数</span><br><span class="line">    return resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xxMethodArugumentResolvers.class</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer, NativeWebRequest webRequest, <span class="meta">@Nullable</span> WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="5、复杂参数"><a href="#5、复杂参数" class="headerlink" title="5、复杂参数"></a>5、复杂参数</h3><ul><li><p>map、model(map、model里面的数据会被放在 request的请求域中,request.setAttribute),Errors/BindingResult、RedirectAttributes(重定向携带数据)、ServletResponse(response)、SessionStatus、UriComponentsBuilder、ServletUriComponentBuilder</p></li><li><p>直接传入request域</p><ul><li>map.put:</li></ul></li></ul><h4 id="map被20-MapMethodProcessor解析-返回modelAndViewContainer对象"><a href="#map被20-MapMethodProcessor解析-返回modelAndViewContainer对象" class="headerlink" title="map被20.MapMethodProcessor解析,返回modelAndViewContainer对象"></a>map被20.MapMethodProcessor解析,返回modelAndViewContainer对象</h4><pre><code>* mavContrainer.getModel():--&gt;BindingAwareModelMap是Model也是Map</code></pre><ul><li>model</li></ul><h4 id="Model被19-ModelMethodProcessor解析"><a href="#Model被19-ModelMethodProcessor解析" class="headerlink" title="Model被19.ModelMethodProcessor解析"></a>Model被19.ModelMethodProcessor解析</h4><ul><li><p>map和model类型都调用mavContainer.getModel();方法</p><ul><li>得到的mvnModel都是一样的</li></ul></li><li><p>response</p><ul><li>reponseFaced</li></ul></li><li><p>request</p><ul><li>requestFaced</li></ul></li></ul><h3 id="6、目标方法执行完成"><a href="#6、目标方法执行完成" class="headerlink" title="6、目标方法执行完成"></a>6、目标方法执行完成</h3><ul><li>将所有数据都放在ModelAndViewCOntainer中,包含要去的页面地址VIew,还包含所需的数据model</li><li>之后将modelContainer处理为纯净的只包含数据的model</li></ul><h3 id="7、处理派发结果"><a href="#7、处理派发结果" class="headerlink" title="7、处理派发结果"></a>7、处理派发结果</h3><ul><li><strong>processDispatchResult</strong>(processedRequest,response,,mappedHandler,mv,dispachException)</li><li><strong>RendderMergedOutputModel(mergedModel,getRequestToExpose(request),response)</strong>//暴露模型作为请求域的属性</li></ul><h3 id="8、自定义对象参数-pojo类"><a href="#8、自定义对象参数-pojo类" class="headerlink" title="8、自定义对象参数(pojo类)"></a>8、自定义对象参数(pojo类)</h3><h4 id="6-ServletModelAttributeMethodProcessor解析"><a href="#6-ServletModelAttributeMethodProcessor解析" class="headerlink" title="6.ServletModelAttributeMethodProcessor解析"></a>6.ServletModelAttributeMethodProcessor解析</h4><ul><li><p>ServletModelAttributeMethodProcessor有两个,一个支持前面标注解,一个支持前面不标注解</p></li><li><p>先判断是否为简单类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSimpleValueType</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Void.class != type &amp;&amp; Void.TYPE != type &amp;&amp; (ClassUtils.isPrimitiveOrWrapper(type) || Enum.class.isAssignableFrom(type) || CharSequence.class.isAssignableFrom(type) || Number.class.isAssignableFrom(type) || Date.class.isAssignableFrom(type) || Temporal.class.isAssignableFrom(type) || URI.class == type || URL.class == type || Locale.class == type || Class.class == type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Web数据绑定<strong>WebDataBinder binder = binderFactory.createBinder(webRequest,attribute,name);</strong></p><ul><li>WebDataBinder:web数据绑定器,将数据绑定到指定的javaBean里</li><li>WebDataBinder利用它里面的COnverters将请求取数据转成指定的数据类型,再次封装近bean对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bindingResult == <span class="keyword">null</span>) &#123;</span><br><span class="line">            WebDataBinder binder = binderFactory.createBinder(webRequest, attribute, name);</span><br><span class="line">            <span class="keyword">if</span> (binder.getTarget() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!mavContainer.isBindingDisabled(name)) &#123;</span><br><span class="line">                    <span class="comment">//绑定参数</span></span><br><span class="line">                    <span class="keyword">this</span>.bindRequestParameters(binder, webRequest);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.validateIfApplicable(binder, parameter);</span><br><span class="line">                <span class="keyword">if</span> (binder.getBindingResult().hasErrors() &amp;&amp; <span class="keyword">this</span>.isBindExceptionRequired(binder, parameter)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BindException(binder.getBindingResult());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!parameter.getParameterType().isInstance(attribute)) &#123;</span><br><span class="line">                attribute = binder.convertIfNecessary(binder.getTarget(), parameter.getParameterType(), parameter);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            bindingResult = binder.getBindingResult();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li>GenericConversionService:在设置每一个值的时候,找它里面的所有converter哪个可以将这个数据类型(request带来的参数(String)转换到指定类型)</li><li>可以给WebDataBinder里面放自己的Converter</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToNumber</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">number</span>&gt; <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>,<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">//<span class="title">Converter</span>总接口</span></span><br><span class="line"><span class="class">@<span class="title">FunctionalInterface</span> <span class="title">public</span> <span class="title">interface</span> <span class="title">Converter</span>&lt;<span class="title">S</span>,<span class="title">T</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>创建pojo类-&gt;封装pojo类的属性-&gt;每次封装调用convert-&gt;从124个convert中找</li></ul></li><li><p>自定义convert实战</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WebMvcConfigurer <span class="title">webMvcConfigurer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WebMvcConfigurer() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configurePathMatch</span><span class="params">(PathMatchConfigurer configurer)</span> </span>&#123;</span><br><span class="line">            UrlPathHelper urlPathHelper = <span class="keyword">new</span> UrlPathHelper();</span><br><span class="line">            urlPathHelper.setAlwaysUseFullPath(<span class="keyword">false</span>);</span><br><span class="line">            configurer.setUrlPathHelper(urlPathHelper);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFormatters</span><span class="params">(FormatterRegistry registry)</span> </span>&#123;</span><br><span class="line">            registry.addConverter(<span class="keyword">new</span> Converter&lt;String, Pet&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Pet <span class="title">convert</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!StringUtils.isEmpty(s))&#123;</span><br><span class="line">                        Pet pet = <span class="keyword">new</span> Pet();</span><br><span class="line">                        String[] strings = s.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                        pet.setName(strings[<span class="number">0</span>]);</span><br><span class="line">                        pet.setAge(Integer.parseInt(strings[<span class="number">1</span>]));</span><br><span class="line">                        <span class="keyword">return</span> pet;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-6、响应原理"><a href="#1-6、响应原理" class="headerlink" title="1.6、响应原理"></a>1.6、响应原理</h2><h3 id="1-返回值解析器"><a href="#1-返回值解析器" class="headerlink" title="1.返回值解析器"></a>1.返回值解析器</h3><pre><code> 1. 返回值处理器判断是否支持这种类型返回值supportsReturnType 2. 返回值处理器调用handleReturnValue进行处理 3. RequestResponseBodyMethodProcessor可以处理返回值标了@ResponseBody注解的       1. 使用消息转换器进行写出操作;writeWithMessageConverters,利用messageConverter处理,将数据写为json            1. 内容协商:浏览器默认会以请求头的方式告诉服务器他能接收什么样的内容类型:acceptableTypes            2. 服务器最终根据自己自身的能力,决定服务器能生产什么样内容类型的数据:嵌套循环处理:producibleTypes            3. 得到输出的类型:mediaTypeToUse            4. 判断所有的messageConverters:依次判断是否能够支持输出媒体类型(可逆)                 1. 每一个messageConverter都有canRead(),canWrite()方法:是否支持将待输出的类型转为mediaType类型的数据                 2. Class转Json,Json转Class,解析可逆                 3. 每一种messageConverter的效果不同,都有一个属性包含自己支持的MediaType                      1. Byte                      2. String                      3. String                      4. Resource                      5. ResourceRegion                      6. Dom/Sax/Stax/StremSource/Source                      7. AllEncompassingFormHttpMessageConverter:                      8. MappingJackson2:返回true                      9. MappingJackson2:返回true                      10. Jaxb2:主持注解方式的xml           5. 最终MappingJackson2HttpMessageConverter把对象转为Json</code></pre><h3 id="2-返回值处理器-寻找返回值处理器"><a href="#2-返回值处理器-寻找返回值处理器" class="headerlink" title="2.返回值处理器:寻找返回值处理器"></a>2.返回值处理器:寻找返回值处理器</h3><ul><li><strong>返回值处理器</strong>先判断是否支持这种类型返回值<ol><li>SupprtsReturnType</li><li>HandleReturnValue(支持调用)</li></ol></li></ul><h3 id="3-springMVC支持哪些返回值"><a href="#3-springMVC支持哪些返回值" class="headerlink" title="3.springMVC支持哪些返回值"></a>3.springMVC支持哪些返回值</h3><ul><li>View</li><li>ModelAndView</li><li>Model</li><li>ResponseEntity</li><li>ResponseBodyEmitter</li><li>StreamingResponseBody</li><li>HttpEntity</li><li>HttpHeaders</li><li>Callable:判断是否异步</li><li>DeferredResult:</li><li>ListenableFuture</li><li>CompletionStage</li><li>WebAsynTask</li><li>标注ModelAttribute注解</li><li>RequestResponseBodyProcessor:返回值标注了@responseBody注解</li></ul><h2 id="1-7、内容协商原理"><a href="#1-7、内容协商原理" class="headerlink" title="1.7、内容协商原理"></a>1.7、内容协商原理</h2><ol><li>判断当前响应头中是否已经有确定的媒体类型。MediaType</li><li><strong>获取客户端支持接收的内容类型,获取客户端Accept请求头字段</strong><ul><li>contentNegotiationManager:内容协商管理器,默认使用基于请求头accept</li><li><strong>HeaderContentNegotiationStrategy</strong>:确定客户端可以接收的内容类型</li><li>parameterContentNegotiationStrategy:配置文件开启参数内容管理器</li></ul></li><li>遍历循环所有当前系统的MessageConverter,看谁支持操作这个对象</li><li>找到支持操作对象的converter,把converter支持的媒体类型统计出来</li><li>客户端需要,服务端能力</li></ol><h4 id="开启基于请求参数的内容协商"><a href="#开启基于请求参数的内容协商" class="headerlink" title="开启基于请求参数的内容协商"></a>开启基于请求参数的内容协商</h4><h4 id="导入jackson支持xml的包"><a href="#导入jackson支持xml的包" class="headerlink" title="导入jackson支持xml的包"></a>导入jackson支持xml的包</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">hiddenmethod:</span></span><br><span class="line">      <span class="attr">filter:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">contentnegotiation:</span></span><br><span class="line">      <span class="attr">favor-parameter:</span> <span class="literal">true</span> <span class="comment">#开启请求参数内容协商模式</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost/test/person?format=json</span></span><br><span class="line">http：<span class="comment">//localhost/test/person?format=xml</span></span><br></pre></td></tr></table></figure><ul><li>确定客户端接收什么样的内容类型<ul><li>parameter策略优先返回json数据(获取请求头中的format值)</li></ul></li></ul><h4 id="自定义accept"><a href="#自定义accept" class="headerlink" title="自定义accept"></a>自定义accept</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 添加新的WebMessageConverter,可以自定义处mediaType</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> converters</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extendMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;</span><br><span class="line">    converters.add(<span class="keyword">new</span> TwenConverter());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwenConverter</span> <span class="keyword">implements</span> <span class="title">HttpMessageConverter</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canRead</span><span class="params">(Class&lt;?&gt; aClass, MediaType mediaType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canWrite</span><span class="params">(Class&lt;?&gt; aClass, MediaType mediaType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> aClass.isAssignableFrom(User.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;MediaType&gt; <span class="title">getSupportedMediaTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MediaType.parseMediaTypes(<span class="string">&quot;application/twen&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">read</span><span class="params">(Class&lt;? extends User&gt; aClass, HttpInputMessage httpInputMessage)</span> <span class="keyword">throws</span> IOException, HttpMessageNotReadableException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(User user, MediaType mediaType, HttpOutputMessage httpOutputMessage)</span> <span class="keyword">throws</span> IOException, HttpMessageNotWritableException </span>&#123;</span><br><span class="line">        <span class="comment">//自定义协议数据的写出</span></span><br><span class="line">        String data = user.getName()+<span class="string">&quot;;&quot;</span>+user.getAge();</span><br><span class="line">        OutputStream body = httpOutputMessage.getBody();</span><br><span class="line">        body.write(data.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="用url的format确定参数"><a href="#用url的format确定参数" class="headerlink" title="用url的format确定参数"></a>用url的format确定参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 自定义策略器的配置</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> configurer</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureContentNegotiation</span><span class="params">(ContentNegotiationConfigurer configurer)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, MediaType&gt; myNegotiation = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    myNegotiation.put(<span class="string">&quot;json&quot;</span>,MediaType.APPLICATION_JSON);</span><br><span class="line">    myNegotiation.put(<span class="string">&quot;xml&quot;</span>, MediaType.APPLICATION_XML);</span><br><span class="line">    myNegotiation.put(<span class="string">&quot;gg&quot;</span>,MediaType.parseMediaType(<span class="string">&quot;application/twen&quot;</span>));</span><br><span class="line">    <span class="comment">//参数策略配置器</span></span><br><span class="line">    ParameterContentNegotiationStrategy parameter = <span class="keyword">new</span> ParameterContentNegotiationStrategy(myNegotiation);</span><br><span class="line">    <span class="comment">//添加头策略配置器</span></span><br><span class="line">    HeaderContentNegotiationStrategy headerStrategy = <span class="keyword">new</span> HeaderContentNegotiationStrategy();</span><br><span class="line">    configurer.strategies(Arrays.asList(parameter,headerStrategy));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-Thymeleaf"><a href="#2-Thymeleaf" class="headerlink" title="2.Thymeleaf"></a>2.Thymeleaf</h1><h2 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1.引入依赖"></a>1.引入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-自动配置好了thmeleaf"><a href="#2-自动配置好了thmeleaf" class="headerlink" title="2.自动配置好了thmeleaf"></a>2.自动配置好了thmeleaf</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(ThymeleafProperties.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; TemplateMode.class, SpringTemplateEngine.class &#125;)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(&#123; WebMvcAutoConfiguration.class, WebFluxAutoConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThymeleafAutoConfiguration</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><p>自动配好的策略</p><ul><li>所有thymeleaf的配置值都在ThymeleafProperties</li><li><strong>配置好了SpringTemplateEngine</strong></li><li><strong>配好了ThymeleafViewResolver</strong></li><li>我们只需要直接开发页面</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_PREFIX = <span class="string">&quot;classpath:/templates/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_SUFFIX = <span class="string">&quot;.html&quot;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;msg&#125;&quot;</span>&gt;</span>twen<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;www.atguigu.com&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;$&#123;link&#125;&quot;</span>&gt;</span>去百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;www.atguigu.com&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;link&#125;&quot;</span>&gt;</span>去百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>@{/}如果加上/则会自动加上项目路径</p></li><li><p>重定向</p><ul><li><p>在使用重定向时，返回的字符串指的是一个请求，而不是一个具体的资源。并且在当前方法设置的Model的Attribute会消失，session不会。url会变成重定向设置的url。</p></li><li><dl><dt>“redirect:xxx”</dt><dd>后不加/表示不从根路径开始查找资源，而是从当前Controller查找RequestMapping的value为/xxx的请求，用于同一Controller内跳转。</dd></dl></li><li><p>“redirect:/xxx”<br>/xxx表示跳转到RequestMapping的value为/xxx的请求，这种方式既可以在不同Controller之间跳转也可以同一Controller中跳转。</p></li></ul></li></ul></li></ul><h2 id="1-项目创建"><a href="#1-项目创建" class="headerlink" title="1.项目创建"></a>1.项目创建</h2><h2 id="2-静态资源处理"><a href="#2-静态资源处理" class="headerlink" title="2.静态资源处理"></a>2.静态资源处理</h2><h2 id="3-路径构建"><a href="#3-路径构建" class="headerlink" title="3.路径构建"></a>3.路径构建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 来登陆页</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(value = &#123;&quot;/&quot;,&quot;/login&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">loginPage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登陆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">main</span><span class="params">(String username,String password)</span></span>&#123;</span><br><span class="line">        <span class="comment">//登陆成功重定向到main.html</span></span><br><span class="line">        <span class="comment">//请求</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 去main页面</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/index.html&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  String <span class="title">mainPage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-模板抽取"><a href="#4-模板抽取" class="headerlink" title="4.模板抽取"></a>4.模板抽取</h2><ol><li>第一种<ul><li>th:fragment=”commonheader”</li><li>th:insert=””插入:包含引入标签</li><li>th:replace插入:不包含主动引入标签</li><li>th:include:只包含引用的引用体</li></ul></li><li>运用选择器<ul><li>th:th:insert=”common::#copy-setion”<h2 id="5-页面跳转"><a href="#5-页面跳转" class="headerlink" title="5.页面跳转"></a>5.页面跳转</h2></li></ul></li></ol><h2 id="6-数据渲染"><a href="#6-数据渲染" class="headerlink" title="6.数据渲染"></a>6.数据渲染</h2><h2 id="7-视图解析原理"><a href="#7-视图解析原理" class="headerlink" title="7.视图解析原理"></a>7.视图解析原理</h2><ol><li>目标方法处理过程中,所有的数据都会被放在ModelAndViewCOntainer里。包括数据和视图地址。</li><li>方法的参数是一个自定类型对象(从请求参数中确定),把他重新放在ModelAndViewContainer</li><li>任何目标方法执行完成以后都会返回ModelAndView对象</li><li>processDispatchResult:处理派发结果(页面该如何响应)<ol><li>render(mv,request,response):进行页面渲染逻辑<ol><li>根据Controller的String返回值得到view对象[定义了页面的渲染逻辑]<ol><li>viewResolver:所有的视图解析器尝试是否能根据当前返回值得到view对象</li><li>根据”redirect:***.html”返回值得到了一个redirectViewResolver</li><li>得到了redirect:/main.html –&gt;Thymeleaf new RedirectView()</li><li>ContentNegotiationViewResolver里面包含了所有的视图解析器,内部还是利用下面所有有视图解析器得到的视图对象</li><li>视图对象是一个接口,调用View.render(mv.getModelInternal(),request,response):视图对象调用自定义的rende进行页面渲染工作<ol><li>RedirectView如何渲染</li><li>获取目标url地址</li><li>response.sendRedirec(encodedURL)<h3 id="视图解析"><a href="#视图解析" class="headerlink" title="视图解析:"></a>视图解析:</h3></li></ol></li></ol></li></ol></li></ol></li></ol><ul><li>返回值以forward开始:new InternalResourceView(forward(Url))–&gt;request.getRequestDispatcher(path).forward(request.response);</li><li>返回值以redirec开始:new RedirectView()–&gt;render就是重定向</li><li>返回值是普通字符串:new ThymeleafView()–&gt;    <h1 id="3-拦截器"><a href="#3-拦截器" class="headerlink" title="3.拦截器"></a>3.拦截器</h1><h2 id="1-拦截器使用"><a href="#1-拦截器使用" class="headerlink" title="1.拦截器使用"></a>1.拦截器使用</h2></li></ul><ol><li>定义一个拦截器对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Object user = request.getSession().getAttribute(<span class="string">&quot;loginUser&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(user != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            request.getRequestDispatcher(<span class="string">&quot;/&quot;</span>).forward(request,response);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        HandlerInterceptor.<span class="keyword">super</span>.postHandle(request, response, handler, modelAndView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        HandlerInterceptor.<span class="keyword">super</span>.afterCompletion(request, response, handler, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>将拦截器对象注册进入webmvcConfiguer<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfiguer</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Overrides</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        LoginInterceptor loginInterceptor = <span class="keyword">new</span> LoginInterceptor();</span><br><span class="line">        <span class="comment">//给所有路径都加上此拦截器</span></span><br><span class="line">        registry.addInterceptor(loginInterceptor).addPathPatterns(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line"><span class="comment">//去除某些路径,对于restful风格也适用</span></span><br><span class="line">        .excludePathPatterns(<span class="string">&quot;/&quot;</span>,<span class="string">&quot;/login&quot;</span>,<span class="string">&quot;/css/**&quot;</span>,<span class="string">&quot;/fonts/**&quot;</span>,<span class="string">&quot;/images/**&quot;</span>,<span class="string">&quot;/js/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-源码解析"><a href="#2-源码解析" class="headerlink" title="2.源码解析"></a>2.源码解析</h2></li></ol><h1 id="4-文件的上传与下载"><a href="#4-文件的上传与下载" class="headerlink" title="4.文件的上传与下载"></a>4.文件的上传与下载</h1><h2 id="1-表单里添加enctype-method只能为post"><a href="#1-表单里添加enctype-method只能为post" class="headerlink" title="1.表单里添加enctype,method只能为post"></a>1.表单里添加enctype,<strong>method只能为post</strong></h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">&quot;form-horizontal&quot;</span> <span class="attr">role</span>=<span class="string">&quot;form&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-如果是多个文件用multiple"><a href="#2-如果是多个文件用multiple" class="headerlink" title="2.如果是多个文件用multiple"></a>2.如果是多个文件用multiple</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;exampleInputFile2&quot;</span> <span class="attr">multiple</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-controller里注解-MultiplePart-可以用单个对象或者数组"><a href="#3-controller里注解-MultiplePart-可以用单个对象或者数组" class="headerlink" title="3.controller里注解@MultiplePart,可以用单个对象或者数组"></a>3.controller里注解@MultiplePart,可以用单个对象或者数组</h2><h1 id="5-错误处理"><a href="#5-错误处理" class="headerlink" title="5.错误处理"></a>5.错误处理</h1><h2 id="1-默认规则"><a href="#1-默认规则" class="headerlink" title="1.默认规则"></a>1.默认规则</h2><pre><code>1. 默认情况下,Spring Boot提供了/error处理所有错误的映射2. 对于及其客户端,它将生成JSON响应,其中包含错误HTTP状态和异常消息的详细信息。对于浏览器客户端，响应一个“ whitelabel”错误视图，以HTML格式呈现相同的数据，比如访问不存在的页面</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/9e5a798f34c8503ce05211ab68768e82.png" alt="image-20210203160042411"></p><h2 id="2-要对其自定义-添加View解析为error"><a href="#2-要对其自定义-添加View解析为error" class="headerlink" title="2.要对其自定义,添加View解析为error"></a>2.要对其自定义,添加View解析为error</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/eb22dd620e4ed6bfc3f7bc4df501107c.png" alt="image-20210203162152345"></p><h2 id="3-异常处理自动配置原理"><a href="#3-异常处理自动配置原理" class="headerlink" title="3.异常处理自动配置原理"></a>3.异常处理自动配置原理</h2><ul><li>ErrorMvcAutoConfiguration:自动异常配置<ul><li>容器中的组件:类型:DefaultErrorAttributes -&gt; errorAttributes<ul><li>public class <strong>DefaultErrorAttributes</strong> implements <strong>ErrorAttributes,HandlerExceptionResolver</strong></li><li>DefaultErrorAttributes:定义错误可以包含哪些数据</li></ul></li><li>容器中的组件:类型:BasicErrorController – &gt;id:basicErrorController(json+白页适配响应):修改默认错误响应<ul><li>处理默认/error路径:页面响应 new ModelAndView(“error”,model)</li><li>可以在配置文件中配置:server-error-path:修改响应页面路径</li><li>容器中有组件:view-&gt;id时error(响应默认值)</li><li>容器中放组件:BeanNameViewResolver(视图解析器):按照返回的视图名作为组件的id去容器中找到View对象</li><li>如果想要返回页面,就会找到error视图[staticView],默认时一个白页</li><li>容器中的组件:类型:DefaultErrorViewResolver -&gt; id:conventionErrorViewResolver<ul><li>如果发生错误、会以HTTP的状态码作为视图页地址(viewName),找到真正的页面</li><li>error/404.html<h2 id="4-异常处理步骤流程"><a href="#4-异常处理步骤流程" class="headerlink" title="4.异常处理步骤流程"></a>4.异常处理步骤流程</h2></li></ul></li></ul></li></ul></li></ul><ol><li>执行目标放,目标方法执行期间有任何异常都会被catch、而且标志当前请求结束,并且用<strong>dispachException</strong>处理异常</li><li>进入视图解析流畅(页面渲染)<ul><li>processDispatchResult(processedRequest,response,mappedHandler,mv,<strong>dispatchException</strong>)</li></ul></li><li>mv = pricessHandlerException;处理handler发生的异常,处理完成返回ModelAndView<ol><li>遍历所有的handlerExceptionResolvers看看谁能处理当前异常[处理异常解析器]</li><li>系统默认的异常解析器<ol><li>DefalutErrorAttributes</li><li>HandlerExceptionResolverComposite<ol><li>ExceptionhandlerExceptionResolver</li><li>ResponseStatusExceptionResolver</li><li>DefaultHandlerExceptionResolver</li></ol></li></ol><ul><li>defaultErrorAttributes先来处理异常,将异常信息保存到request域,并且返回null;</li><li>来到handlerExceptionResolverComposite下的解析器,默认没有任何处理器能处理异常,则异常会被抛出</li><li>如果没有任何人能够处理最终底层会发送/error请求—&gt;BasicErrorController</li><li>解析错误视图:遍历所有的ErrorViewResolver,看谁能解析,</li><li>默认DefaultErrorViewResolver,作用是把响应状态码作为错误页的地址</li></ul></li></ol></li></ol><h2 id="5-自定义异常"><a href="#5-自定义异常" class="headerlink" title="5.自定义异常"></a>5.自定义异常</h2><ol><li>@ControllerAdvice+@ExceptionHandler处理异常:可以处理特定出现的错误<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(&#123;ArithmeticException.class,NullPointerException.class&#125;)</span><span class="comment">//处理异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handleArithException</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index.html&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在ExceptionHandler上填写异常的.class,该注解由ExceptionHandlerExceptionResoler解析</li></ul></li><li>@ResponseStatus+自定义异常:可以自定义异常 throw Exception,该注解由ResponseStatusExceptionResolver解析<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseStatus(value = HttpStatus.FORBIDDEN,reason = &quot;测试异常&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestException</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestException</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/basic_table.html&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">basic_table</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TestException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;tables/basic_table&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Spring底层的异常,参数类型转化异常:运用DefaultHandlerExceptionResolver</li></ol><ul><li>底层用if判断是否出现框架底层异常</li></ul><ol start="4"><li>自定义实现HandlerExceptionResolver处理异常<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order(Ordered.HIGHEST_PRECEDENCE)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">myHandler</span> <span class="keyword">implements</span> <span class="title">HandlerExceptionResolver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveException</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            httpServletResponse.sendError(<span class="number">512</span>,<span class="string">&quot;我不喜欢的错误&quot;</span>);</span><br><span class="line">            System.out.println(<span class="number">512</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ioException) &#123;</span><br><span class="line">            ioException.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>ErrorViewResolver:实现自定义处理异常<h3 id="senError-此次请求立即结束-由tomcat发出异常被底层BasicErrorController处理"><a href="#senError-此次请求立即结束-由tomcat发出异常被底层BasicErrorController处理" class="headerlink" title="senError:此次请求立即结束,由tomcat发出异常被底层BasicErrorController处理"></a>senError:此次请求立即结束,由tomcat发出异常被底层BasicErrorController处理</h3></li></ol><h1 id="6-Web原生组件注入"><a href="#6-Web原生组件注入" class="headerlink" title="6.Web原生组件注入"></a>6.Web原生组件注入</h1><h2 id="1、使用Servlet-API"><a href="#1、使用Servlet-API" class="headerlink" title="1、使用Servlet API"></a>1、使用Servlet API</h2><ul><li>@ServletComponentScan(basePacakges = “”):指定原生Servlet组件都放在里面</li><li>@WebServlet,@WebFilter,@WebListener<h2 id="2、使用RegistrationBean-使用confige"><a href="#2、使用RegistrationBean-使用confige" class="headerlink" title="2、使用RegistrationBean:使用confige"></a>2、使用RegistrationBean:使用confige</h2></li><li>@ServletRegistrationBean</li><li>@FilterRegistrationBean</li><li>@ServletListenerRegistrationBean<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRegistBean</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">getServlet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        MyServlet myServlet = <span class="keyword">new</span> MyServlet();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServletRegistrationBean(myServlet,<span class="string">&quot;/get&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、为何自定义Servlet会生效"><a href="#3、为何自定义Servlet会生效" class="headerlink" title="3、为何自定义Servlet会生效?"></a>3、为何自定义Servlet会生效?</h2></li><li>SpringBoot配置的路径映射机制是最详细路径映射</li><li>DispacherServlet默认路径是/</li><li>只要Servlet路径小于/则会映射到Servlet<h1 id="7-嵌入式Web容器"><a href="#7-嵌入式Web容器" class="headerlink" title="7.嵌入式Web容器"></a>7.嵌入式Web容器</h1><h2 id="1-切换嵌入式Servlet容器"><a href="#1-切换嵌入式Servlet容器" class="headerlink" title="1.切换嵌入式Servlet容器"></a>1.切换嵌入式Servlet容器</h2></li><li>默认支持的webServer<ul><li>Tomcat,Jetty,Undertow</li><li>ServletWebServerApplicationContext,容器启动寻找ServletWebServerFactory并引导创建服务器</li></ul></li><li>切换服务器</li><li>原理<ul><li>SpringBoot应用启动发现当前是web应用</li><li>web应用会常见一个web版的IOC容器<strong>ServletWebServelApplicationContext</strong></li><li>ServletWebServerApplicationContxt启动时寻找ServletWebServerFacotry:Servlet的Web服务器工厂<h2 id="2-定制Servlet容器"><a href="#2-定制Servlet容器" class="headerlink" title="2.定制Servlet容器"></a>2.定制Servlet容器</h2></li></ul></li><li>实现<strong>WebServerFactoryCustomized<ConfigurableServletWebServerFactory></strong><ul><li>把配置文件的值和ServletServerFactory进行绑定</li></ul></li><li>修改配置文件Server.xxx</li><li>直接自定义ConfigurableServletWebServerFacotry</li></ul><ul><li>xxxxCustomeized:用于用户定制化</li></ul><h1 id="8-定制化原理"><a href="#8-定制化原理" class="headerlink" title="8.定制化原理"></a>8.定制化原理</h1><h2 id="1、定制化的常见方式"><a href="#1、定制化的常见方式" class="headerlink" title="1、定制化的常见方式"></a>1、定制化的常见方式</h2><ul><li><p>@Bean替换、增加容器中默认组件:视图解析器</p></li><li><p>修改配置文件</p></li><li><p>xxxCustomizer</p></li><li><p>编写自定义的配置类 xxxConfiguration</p></li><li><p><strong>web应用 实现 WebMvcConfiguer 即可定制化web功能</strong>+@Bean给容器中再扩展一些组件</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfiguer</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        LoginInterceptor loginInterceptor = <span class="keyword">new</span> LoginInterceptor();</span><br><span class="line">        <span class="comment">//给所有路径都加上此拦截器</span></span><br><span class="line">        registry.addInterceptor(loginInterceptor).addPathPatterns(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">        .excludePathPatterns(<span class="string">&quot;/&quot;</span>,<span class="string">&quot;/login&quot;</span>,<span class="string">&quot;/css/**&quot;</span>,<span class="string">&quot;/fonts/**&quot;</span>,<span class="string">&quot;/images/**&quot;</span>,<span class="string">&quot;/js/**&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>@EnableWebMvc + WebMvcConfiguer ——@Bean 可以全面接管SpringMVC,所有的规则全部自己重新配置;实现定制和扩展功能</p><ul><li><p>autoConfiguration不能生效,默认的SpringMvc的自动配置功能类。静态资源、欢迎页</p></li><li><p>一旦使用@EnableWebMvc,会导入@Import(DelegatingWebMvcConfigutation.class)</p></li><li><p>DelegatingWebMvcConfiguration,只保证了SpringMvc最基本的使用</p><ul><li>把系统中的WebMvcConfigurer拿过来依次生效,所有功能的定制都是这些WebMvcConfiguere合起来一起生效</li><li>自动配置了一些非常底层的组件。RequestMappingHandlerMapping、这些组件依赖的组件都是从容器中获取</li></ul></li><li><p>WebMvcAutoConfiguration里面的配置要生效必须:与DelegatingWebMvcConfiguration互斥(DelegatingWebMvcConfiguration继承)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</span>--&gt;DelegatingWebMvcConfiguration 继承了该类</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatingWebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span></span></span><br></pre></td></tr></table></figure></li><li><p>@EnableWebMvc导致了WebMvcAutoConfiguraion生效</p></li></ul></li></ul><h2 id="2、原理分析套路"><a href="#2、原理分析套路" class="headerlink" title="2、原理分析套路"></a>2、原理分析套路</h2><ul><li><strong>场景starter</strong> –xxxxAutoConfiguration-导入xxx组件-绑定xxxProperties–绑定配置文件项</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> springboot-web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot起步</title>
      <link href="2021/06/04/springboot-start/"/>
      <url>2021/06/04/springboot-start/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Getting-Start"><a href="#1-Getting-Start" class="headerlink" title="1 Getting Start"></a>1 Getting Start</h1><h2 id="1-1-SpringBoot优点"><a href="#1-1-SpringBoot优点" class="headerlink" title="1.1 SpringBoot优点"></a>1.1 SpringBoot优点</h2><ul><li>创建独立Spring应用</li><li>内嵌web服务器</li><li>自动starSter依赖,简化构建配置</li><li>自动配置Spring以及第三方功能</li><li>提供生态级别的监控、健康检查以及外部化配置</li><li>无代码生成、无需编写XML</li></ul><h2 id="1-2-SpringBoot缺点"><a href="#1-2-SpringBoot缺点" class="headerlink" title="1.2 SpringBoot缺点"></a>1.2 SpringBoot缺点</h2><ul><li>迭代快,需要时刻关注变化</li><li>封装太深,内部原理复杂,不容易精通</li></ul><h1 id="2-basic-concept"><a href="#2-basic-concept" class="headerlink" title="2 basic concept"></a>2 basic concept</h1><h2 id="2-1-微服务"><a href="#2-1-微服务" class="headerlink" title="2.1 微服务"></a>2.1 微服务</h2><ul><li><p>微服务是一种架构风格</p></li><li><p>一个应用拆分为一组小型服务</p></li><li><p>每个服务运行再自己的进程内,也就是可独立部署和升级</p></li><li><p>服务之间使用轻量级HTTP交互</p></li><li><p>服务围绕业务功能拆分</p></li><li><p>可以由全自动部署机制独立部署</p></li><li><p>去中心化、服务自治、服务可以使用不同的语言、不同的存储技术</p></li></ul><h2 id="2-2-分布式"><a href="#2-2-分布式" class="headerlink" title="2.2 分布式"></a>2.2 分布式</h2><h3 id="分布式困难"><a href="#分布式困难" class="headerlink" title="分布式困难"></a>分布式困难</h3><ul><li>远程调用</li><li>服务发现</li><li>负载均衡</li><li>服务容错</li><li>配置管理</li><li>服务监控</li><li>链路追踪</li><li>日志管理</li><li>任务调度</li><li>…<h3 id="分布式的解决"><a href="#分布式的解决" class="headerlink" title="分布式的解决"></a>分布式的解决</h3></li><li>SpringBoot+SpringCloud</li></ul><h2 id="2-3-云原生"><a href="#2-3-云原生" class="headerlink" title="2.3 云原生"></a>2.3 云原生</h2><ul><li>原生应用如何上云<h3 id="上云的困难"><a href="#上云的困难" class="headerlink" title="上云的困难"></a>上云的困难</h3></li><li>服务自愈</li><li>弹性伸缩</li><li>服务隔离</li><li>自动化部署</li><li>灰度发布</li><li>流量治理</li><li>…<h1 id="3-Hello-World"><a href="#3-Hello-World" class="headerlink" title="3 Hello World"></a>3 Hello World</h1><h2 id="2-1-创建"><a href="#2-1-创建" class="headerlink" title="2.1 创建"></a>2.1 创建</h2></li><li>导入springboot父工程<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-parent --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>导入springbootweb场景启动器<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>引入jar插件,把项目达成jar包,直接在目标服务器执行<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-2-引入依赖"><a href="#2-2-引入依赖" class="headerlink" title="2.2 引入依赖"></a>2.2 引入依赖</h2><h2 id="2-3-创建主程序"><a href="#2-3-创建主程序" class="headerlink" title="2.3 创建主程序"></a>2.3 创建主程序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MainApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-编写业务"><a href="#2-4-编写业务" class="headerlink" title="2.4 编写业务"></a>2.4 编写业务</h2><h2 id="2-5-测试"><a href="#2-5-测试" class="headerlink" title="2.5 测试"></a>2.5 测试</h2><h2 id="2-6-简化配置"><a href="#2-6-简化配置" class="headerlink" title="2.6 简化配置"></a>2.6 简化配置</h2></li><li>统一配置</li><li>只需要抽取一个配置文件放在resources下</li><li>修改tomcat服务器端口<h2 id="2-7-简化部署"><a href="#2-7-简化部署" class="headerlink" title="2.7 简化部署"></a>2.7 简化部署</h2></li><li>引入fat jars,可以用maven-jar打包方式而不用war</li></ul><h1 id="4、自动配置原理"><a href="#4、自动配置原理" class="headerlink" title="4、自动配置原理"></a>4、自动配置原理</h1><h2 id="4-1、管理依赖版本号"><a href="#4-1、管理依赖版本号" class="headerlink" title="4.1、管理依赖版本号"></a>4.1、管理依赖版本号</h2><ul><li><p>依赖管理</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>父依赖的父依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>自动版本仲裁</p></li><li><p>可以在pom文件直接修改,依赖就近原则下</p></li><li><p>也可以,查看spring-boot-dependencies里的key</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>5.7.1<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>8.0.20<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>自动依赖版本管理只会管理版本,不会自动添加依赖</p></li><li><p><strong>何为starter?</strong></p><ul><li>spring-boot-starter-*, *为某种场景</li><li>例如,spring-boot-starter-web:为web场景的starter</li><li>starter抽取了常用的依赖并进行了依赖管理</li><li>如果非官方的starter</li><li>*-spring-boot-starter,第三方简化开发的场景启动器</li><li>引入非版本仲裁的jar,一定要写版本号</li><li>所有场景启动器依赖最底层的依赖是spring-boot-starter<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-2、自动配置"><a href="#4-2、自动配置" class="headerlink" title="4.2、自动配置"></a>4.2、自动配置</h2></li></ul></li><li><p>自动配好Tomcat</p><ul><li>引入Tomcat依赖,配置</li><li>配置Tomcat<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>自动配置好SpringMVC</p><ul><li>引入SpringMVC全套组件</li><li>自动配好SpringMVC常用组件</li></ul></li><li><p>自动配好Web常见功能,如:字符编码问题</p><ul><li>SpringBoot帮我们配置好了所有web开发的常见场景</li></ul></li><li><p>默认的包结构</p><ul><li>主程序所在的包及其下面的所有子包里面的组件都会被默认扫描</li><li>无需配置以前的包扫描</li><li>想要改变扫描路径<ul><li>使用@SpringBootApplication(ScanBasePackages=”com.atguigu”)</li><li>@ComponentScan指定扫描路径</li></ul></li><li>一个@SpringBootApplication于三个注解<br>  @SpringBootConfiguration<br>  @EnableAutoConfiguration<br>  @ComponentScan(“com.twen.springboot”)</li></ul></li><li><p>各种配置拥有默认值</p><ul><li>默认配置最终都是映射到一个类上</li><li>配置文件的值最终会绑定到某个类上,这个类会在容器中创建对象</li></ul></li><li><p>按需加载所有自动配置项</p><ul><li><p>依赖按需加载</p></li><li><p>引入了哪些场景这个场景的自动配置才会开启</p></li><li><p>pringBoot所有的自动配置功能都在</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">* 配置类:@Configuration</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  @Configuration(proxyBeanMethods = true)//lite或full模式</span><br><span class="line">  public class MyConfig &#123;</span><br><span class="line">  @Bean</span><br><span class="line">      public User user01()&#123;</span><br><span class="line">          User user = new User(&quot;zhangsan&quot;, 18);</span><br><span class="line">          //User组件依赖了tomcat</span><br><span class="line">          user.setPet(tomcat());</span><br><span class="line">          return user;</span><br><span class="line">      &#125;</span><br><span class="line">      @Bean(&quot;tom&quot;)</span><br><span class="line">      public Pet tomcat()&#123;</span><br><span class="line">          return new Pet();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>配置类的@Bean注册的组件默认Singelton</p><ul><li>以方法名为Bean名</li><li>Component只能注册简单的组件</li></ul></li><li><p>@Configuration配置类默认也是一个组件</p></li><li><p>默认@Configuration(proxyBeanMethods = true)</p><ul><li>获取到的对象本身就是代理对象,注解中的值为true,获取代理对象</li><li>如果为true则不会被代理</li><li>代理Bean方法,被代理的@Bean方法会默认单例</li><li>外部无论对配置类中@Bean方法配置多少次,默认都是同一个对象</li></ul></li><li><p>最佳实战</p><ul><li>配置类组件之间无依赖管理用lite模式加速容器启动过程、减少判断</li><li>配置类组件之间有依赖关系,方法会被调用得到之间的单实例组件、用full模式</li></ul></li></ul></li><li><p>@Bean、@Component、@Controller、@Service、@Repository </p></li><li><p>@ComponentScan、@Import</p><ul><li>@ComponentScan扫描包</li><li>@Import:<ul><li>将指定类型组件导入,给容器中自动创建出这两个类型的组件</li><li>可以写在任意一个组件上</li><li>默认组件名字是全类名</li></ul></li></ul></li><li><p>@Conditional:根据条件装配</p><ul><li>加载方法上,当条件成立,该方法才会生效</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnBean(name = &quot;tom&quot;)</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">user01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    <span class="comment">//User组件依赖了tomcat</span></span><br><span class="line">    user.setPet(tomcat());</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Pet <span class="title">tomcat</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Pet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named <span class="string">&#x27;user01&#x27;</span> available</span><br></pre></td></tr></table></figure><ul><li>加载类上<ul><li>当条件成立,该类下面的所有配置才会生效</li></ul></li></ul></li><li><p>.xml原生配置文件的引入,@ImportResource(“classpath:*.xml”)</p></li><li><p><strong>配置绑定</strong>:使用javaBean类来进行 配置</p><ol><li><p>@Component+@ConfigurationProperties,注册配置组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;mycar&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">     <span class="meta">@RestController</span></span><br><span class="line">     <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Controller1</span> </span>&#123;</span><br><span class="line">         <span class="meta">@Autowired</span></span><br><span class="line">         Car car;</span><br><span class="line">     </span><br><span class="line">         <span class="meta">@RequestMapping(&quot;/car&quot;)</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> Car <span class="title">mycar</span><span class="params">()</span></span>&#123;</span><br><span class="line">             <span class="keyword">return</span> car;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; </span><br><span class="line"><span class="number">2.</span>  在配置类里<span class="meta">@EnableConfigurationProperties(Class *)</span>:</span><br><span class="line"></span><br><span class="line">   * 开启容器配置</span><br><span class="line">   * 自动注入容器</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 配置一定有两步</span><br><span class="line"></span><br><span class="line">   <span class="number">1.</span>  配置绑定<span class="meta">@ConfigurationProperties</span></span><br><span class="line">   <span class="number">2.</span>  注册Bean类<span class="meta">@Component</span>或<span class="meta">@EnableConfigurationProperties</span></span><br><span class="line">## 4.3、自动配置原理解析</span><br><span class="line"></span><br><span class="line">### 1.引导加载自动配置类</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br></pre></td></tr></table></figure></li></ol></li></ul><ol><li><p><strong>@SpringBootConfiguration</strong></p><ul><li>底层@Configuration、代表当前是一个配置类</li></ul></li><li><p>@ComponentScan</p><ul><li>指定扫描哪些，Spring注解</li></ul></li><li><p>@EnableAutoConfiguration</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br></pre></td></tr></table></figure><ol><li><p>AutoConfigurationPackage:指定默认包规则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(AutoConfigurationPackages.Registrar.class)</span><span class="comment">//给容器中导入组件,批量注册</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoConfigurationPackage &#123;&#125;<span class="comment">//将指定的一个包下面组件注入</span></span><br></pre></td></tr></table></figure><ul><li>利用Registrar导入一系列组件AutoConfigurationPackages的内部类注册器:registrar</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    register(registry, <span class="keyword">new</span> PackageImports(metadata).getPackageNames().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Import(AutoConfigurationImportSelector.class):导入指定包</p><ul><li>AutoConfigurationImportSelector</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">    &#125;</span><br><span class="line">    AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line">    <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>getAutoConfigurationEntry:调用同类方法得到自动配置入口</p><ul><li>同样的类中的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">    &#125;</span><br><span class="line">    AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">    <span class="comment">//获取候选配置</span></span><br><span class="line">    List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">    <span class="comment">//去除重复配置</span></span><br><span class="line">    configurations = removeDuplicates(configurations);</span><br><span class="line">    <span class="comment">//得到筛选条件</span></span><br><span class="line">    Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">    checkExcludedClasses(configurations, exclusions);</span><br><span class="line">  <span class="comment">//根据条件移除</span></span><br><span class="line">    configurations.removeAll(exclusions);</span><br><span class="line">    configurations = getConfigurationClassFilter().filter(configurations);</span><br><span class="line">    fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>getCandidateConfigurations:同类中的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//工厂加载器加载获取得到所有组件名</span></span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</span><br><span class="line">                                                                         getBeanClassLoader());</span><br><span class="line">    Assert.notEmpty(configurations, <span class="string">&quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;</span></span><br><span class="line">                    + <span class="string">&quot;are using a custom packaging, make sure that file is correct.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>springBoot默认的配置类全在spring-boot-autofiguer/META-INF/spring.factories里</li></ul></li></ul></li></ol><h3 id="2-按需开启自动配置项"><a href="#2-按需开启自动配置项" class="headerlink" title="2. 按需开启自动配置项"></a>2. 按需开启自动配置项</h3><pre><code> * 虽然所有的默认配置类会在启动时默认全部加载,但是会按需配置,但是按照条件装配原则,相应的配置类会被@Conditional所按需装配 * 所以springboot实际上加载了自动配置类,而自动配置类里又有内部配置类,内部配置类根据条件选择是否配置,以及具体配置所需要的包需要自己导入</code></pre><h3 id="3-修改默认配置"><a href="#3-修改默认配置" class="headerlink" title="3. 修改默认配置"></a>3. 修改默认配置</h3><pre><code> * 总结   * springBoot先加载所有的自动配置类,xxxxAutoConfiguration(xxxxProperties.class)   * 每个自动配置类按照条件进行生效,每一个配置类生效,默认都会绑定配置文件指定的值(),xxxProperties里面拿,xxxProperties和配置文件进行了绑定    * 如果生效,生效的配置类给容器中装配很多组件   * 只要容器中有组件,功能生效   * 只要用户有自己配置的,以用户优先   * 定制化配置     * 用户直接自己@Bean替换底层组件     * 修改配置文件</code></pre><h3 id="4-最佳实践"><a href="#4-最佳实践" class="headerlink" title="4. 最佳实践"></a>4. 最佳实践</h3><pre><code> * 引入场景依赖 * 查看自动配置了哪些   * 自己分析   * 在配置文件中debug=true开启自动配置报告 Negative(不生效)\Positive(生效) * 是否需要修改   * 参照文档修改配置项     * 自己分析,xxxproperties绑定了配置文件哪些比如,mysql   * 自定义加入或者替换组件     * @Bean,@component   * 额外的自定义器</code></pre><h1 id="5-开发小技巧"><a href="#5-开发小技巧" class="headerlink" title="5. 开发小技巧"></a>5. 开发小技巧</h1><h2 id="5-1、-Lombok"><a href="#5-1、-Lombok" class="headerlink" title="5.1、 Lombok"></a>5.1、 Lombok</h2><ul><li>用于javaBean的创建<h2 id="5-2、-Spring-Initailizer"><a href="#5-2、-Spring-Initailizer" class="headerlink" title="5.2、 Spring Initailizer"></a>5.2、 Spring Initailizer</h2></li><li>IDEA创建项目时自动配置<h2 id="5-3、-dev-tools"><a href="#5-3、-dev-tools" class="headerlink" title="5.3、 dev-tools"></a>5.3、 dev-tools</h2></li><li>用于热部署,bug较多<h1 id="6-YAML"><a href="#6-YAML" class="headerlink" title="6. YAML"></a>6. YAML</h1></li><li>用YAML代替properties配置<h2 id="6-1-语法"><a href="#6-1-语法" class="headerlink" title="6.1 语法"></a>6.1 语法</h2></li><li>类似于json写法</li><li>key-val</li><li>对象,map<ul><li>单行配置需要使用{}</li><li>多行配置 key:[space]value</li></ul></li><li>数组,集合<ul><li>单行配置需要使用[]</li><li>多行配置需要使用 -[space]value</li></ul></li><li>自我理解<ul><li>数组结合的-也许是默认的key</li></ul></li><li>配置优先级<ul><li>properties文件优先级最高</li><li>yaml文件优先级较低</li></ul></li></ul><h2 id="6-2-实践"><a href="#6-2-实践" class="headerlink" title="6.2 实践"></a>6.2 实践</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">person1:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">张三</span></span><br><span class="line">  <span class="attr">hobbies:</span> [<span class="string">&quot;吃饭&quot;</span>,<span class="string">&quot;睡觉&quot;</span>,<span class="string">&quot;打豆豆&quot;</span>]</span><br><span class="line">  <span class="attr">pet:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">大猫</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">18</span></span><br><span class="line">  <span class="attr">pets:</span></span><br><span class="line">    <span class="attr">sick:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">猫老大</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">猫老二</span></span><br><span class="line">    <span class="attr">helth:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">猫老三</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">猫老四</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;person1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; hobbies;</span><br><span class="line">    <span class="keyword">private</span> Pet pet;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,List&lt;String&gt;&gt; pets;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-3-省略配置文件提示工具的打包"><a href="#5-3-省略配置文件提示工具的打包" class="headerlink" title="5.3 省略配置文件提示工具的打包"></a>5.3 省略配置文件提示工具的打包</h2><ol><li><p>依赖加入配置文件提示工具</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>省略此依赖的打包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclude</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="7、SpringBoot的默认静态资源"><a href="#7、SpringBoot的默认静态资源" class="headerlink" title="7、SpringBoot的默认静态资源"></a>7、SpringBoot的默认静态资源</h1></li></ol><h2 id="7-1-默认静态资源文件夹"><a href="#7-1-默认静态资源文件夹" class="headerlink" title="7.1. 默认静态资源文件夹"></a>7.1. 默认静态资源文件夹</h2><ol><li><p><strong>META-INF/resources/</strong></p></li><li><p><strong>resources</strong></p></li><li><p><strong>static</strong></p></li><li><p><strong>public</strong></p></li></ol><h2 id="7-2-修改默认静态资源文件夹"><a href="#7-2-修改默认静态资源文件夹" class="headerlink" title="7.2.修改默认静态资源文件夹"></a>7.2.修改默认静态资源文件夹</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">static-locations:</span> <span class="string">classpath:/haha</span></span><br></pre></td></tr></table></figure><ul><li><strong>将默认静态资源文件夹改为/哈哈下的文件</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> microServer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整合ssm</title>
      <link href="2021/05/27/ssmbuild/"/>
      <url>2021/05/27/ssmbuild/</url>
      
        <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul><li><strong>IDEA</strong></li><li><strong>MySQL 8.2.0</strong></li><li><strong>Tomcat 9</strong></li><li><strong>Maven3.6</strong><h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="pom静态资源"><a href="#pom静态资源" class="headerlink" title="pom静态资源"></a>pom静态资源</h1><pre><code>&lt;resources&gt;        &lt;resource&gt;            &lt;directory&gt;../mybatis-08/src/main/java&lt;/directory&gt;            &lt;includes&gt;                &lt;include&gt;**/*.xml&lt;/include&gt;                &lt;include&gt;**/*.properties&lt;/include&gt;            &lt;/includes&gt;            &lt;filtering&gt;true&lt;/filtering&gt;        &lt;/resource&gt;        &lt;resource&gt;            &lt;directory&gt;../mybatis-08/src/main/resources&lt;/directory&gt;            &lt;includes&gt;                &lt;include&gt;**/*.xml&lt;/include&gt;                &lt;include&gt;**/*.properties&lt;/include&gt;            &lt;/includes&gt;            &lt;filtering&gt;true&lt;/filtering&gt;        &lt;/resource&gt;&lt;/resources&gt; </code></pre><h1 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h1><pre><code>jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true&amp;serverTimezone = GMT</code></pre><h1 id="编写配置文件"><a href="#编写配置文件" class="headerlink" title="编写配置文件"></a>编写配置文件</h1><ol><li>mybatis-config</li><li>applicationContext.xml</li><li>数据库配置文件:druid.properties</li></ol><h1 id="整合Mybatis层-Mapper-Pojo"><a href="#整合Mybatis层-Mapper-Pojo" class="headerlink" title="整合Mybatis层:Mapper,Pojo"></a>整合Mybatis层:Mapper,Pojo</h1><ul><li><p>applicationContext.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--新:关联数据库配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:druid.properties&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--连接池--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driverClassName&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.initialSize&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxActive&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.maxActive&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxWait&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.maxWait&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--SqlSessionFactory--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--绑定mybatis配置文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置dao接口扫描包,动态实现dao接口可以注入到spring容器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--注入sqlSessionFactory--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--要扫描的dao包--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.twen.ssmBuild.dao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>mybaits-config.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;db.properties&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--log settings--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--显示开启全局缓存--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--aliases--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.twen.ssmBuild.pojo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注册mapper--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.twen.ssmBuild.dao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="整合Spring层-Mybatis、Application"><a href="#整合Spring层-Mybatis、Application" class="headerlink" title="整合Spring层:Mybatis、Application"></a>整合Spring层:Mybatis、Application</h1><ul><li>查看Mybatis</li></ul><h1 id="整合SpringMVC层-Controller"><a href="#整合SpringMVC层-Controller" class="headerlink" title="整合SpringMVC层:Controller"></a>整合SpringMVC层:Controller</h1><ul><li><p>springMVC</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--注解驱动,如果使用jackSon注意编码问题--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--静态资源过滤--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--扫描包:controller--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.twen.ssmBuild.controller&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--视图解析器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="attr">id</span>=<span class="string">&quot;internalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>spring-service</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span> <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.twen.ssmBuild.service&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookServiceImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.twen.ssmBuild.service.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookMapper&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookMapper&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--声明式事务配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--注入数据源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;update*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--声明切入点--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt1&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.twen.ssmBuild.service.BookService.*())&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--织入事务--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="关于spring-service"><a href="#关于spring-service" class="headerlink" title="关于spring-service"></a>关于spring-service</h1><ul><li>因为service业务较广,所以需要给其配置事务</li></ul><h1 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h1><ul><li><p>用application获取sqlSession/sqlSessionFactory</p><ul><li><p>获取数据库配置文件(placeHolder)</p></li><li><p>注册数据源</p></li><li><p>获取sqlSessionFactory</p></li><li><p>用application注册具体的dao实现类(可以使用自动)</p></li></ul></li><li><p>用springmvc注册controller:扫描包</p><ol><li>注册驱动</li><li>静态资源过滤</li><li>扫描包</li><li>视图解析器</li></ol></li><li><p>使用spring-service注册service,配置事务</p><ol><li><p>事务配置</p><ol><li>注册DataSource的TransactionManager</li><li>编辑事务通知</li><li>织入事务</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--编织事务--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--使用数据源的TransactionManager--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--事务--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--给update方法编织事务--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--propagation:传播方式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;update*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--织入事务--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--切入点--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt1&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.twen.ssmbuildByMySelf.service.BookService.*())&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--织入事务--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt1&quot;</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li><li><p>Web-INF下</p><ol><li>获取DispatcherServlet</li><li>使用Filter屏蔽乱码问题</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssm </tag>
            
            <tag> 整合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC</title>
      <link href="2021/05/27/SpringMVC/"/>
      <url>2021/05/27/SpringMVC/</url>
      
        <content type="html"><![CDATA[<h1 id="1、初始"><a href="#1、初始" class="headerlink" title="1、初始"></a>1、初始</h1><h2 id="1-1概述"><a href="#1-1概述" class="headerlink" title="1.1概述"></a>1.1概述</h2><ol><li>springMVC是基于java实现的MVC框架<ul><li>MVC是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范。</li><li>是将业务逻辑、数据、显示分离的方法来组织代码。</li><li>MVC主要作用是<strong>降低了视图与业务逻辑间的双向偶合</strong>。</li><li>MVC不是一种设计模式，<strong>MVC是一种架构模式</strong>。当然不同的MVC存在差异</li></ul></li></ol><h2 id="1-2基于maven的javaweb"><a href="#1-2基于maven的javaweb" class="headerlink" title="1.2基于maven的javaweb"></a>1.2基于maven的javaweb</h2><ol><li><p>导入包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp/jsp-api --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp.jstl/jstl --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/javax.servlet/jstl --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h1 id="2、什么是SpringMVC"><a href="#2、什么是SpringMVC" class="headerlink" title="2、什么是SpringMVC"></a>2、什么是SpringMVC</h1><h2 id="2、1概述"><a href="#2、1概述" class="headerlink" title="2、1概述"></a>2、1概述</h2><p>Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。</p><p>查看官方文档：<a href="https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/web.html#spring-web">https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/web.html#spring-web</a></p><p><strong>我们为什么要学习SpringMVC呢?</strong></p><p> Spring MVC的特点：</p><ol><li>轻量级，简单易学</li><li>高效 , 基于请求响应的MVC框架</li><li>与Spring兼容性好，无缝结合</li><li>约定优于配置</li><li>功能强大：RESTful、数据验证、格式化、本地化、主题等</li><li>简洁灵活</li></ol><p>Spring的web框架围绕<strong>DispatcherServlet</strong> [ 调度Servlet ] 设计。</p><p>DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解形式进行开发，十分简洁；</p><p>正因为SpringMVC好 , 简单 , 便捷 , 易学 , 天生和Spring无缝集成(使用SpringIoC和Aop) , 使用约定优于配置 . 能够进行简单的junit测试 . 支持Restful风格 .异常处理 , 本地化 , 国际化 , 数据验证 , 类型转换 , 拦截器 等等……所以我们要学习 .</p><p><strong>最重要的一点还是用的人多 , 使用的公司多 .</strong></p><h3 id="2-2、中心控制器"><a href="#2-2、中心控制器" class="headerlink" title="2.2、中心控制器"></a>2.2、中心控制器</h3><p>​    Spring的web框架围绕DispatcherServlet设计。DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解的controller声明方式。</p><p>​    Spring MVC框架像许多其他MVC框架一样, <strong>以请求为驱动</strong> , <strong>围绕一个中心Servlet分派请求及提供其他功能</strong>，**DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类)**。</p><h3 id="2-3、SpringMVC执行原理"><a href="#2-3、SpringMVC执行原理" class="headerlink" title="2.3、SpringMVC执行原理"></a>2.3、<strong>SpringMVC执行原理</strong></h3><p><img src="E:\资源\SMM-狂神\SpringMVC\springMVC\640.png" alt="640"></p><ol><li><p>第一部分,接收请求,找到控制器名字</p><ol><li>HandlerMapping,接收用户请求,找到控制器的名字</li><li>HandlerExecution执行handler返回数据到DispatcherServlet</li></ol></li><li><p>第二部分根据控制器名字适配控制器</p><ol><li>HandlerAdapter,适配控制器,找到对应的控制器并且执行响应conotroller</li><li>对应的controller完成相应业务逻辑,返回封装有模型和视图的ModelAndView对象</li></ol></li><li><p>第三部分</p><ol><li>ViewResolver处理对应的视图与模型,找到视图,根据模型渲染视图</li><li>ViewResolver将渲染好的视图传回给DispatcherServlet并返回给用户<h3 id="2-4-使用注解开发"><a href="#2-4-使用注解开发" class="headerlink" title="2.4 使用注解开发"></a>2.4 使用注解开发</h3></li></ol></li><li><p>依旧在web.xml中配置DispatcherServler</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>完成springmvc-servlet的配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">       https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.twen.springMVC04.controller&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 让Spring MVC不处理静态资源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    支持mvc注解驱动</span></span><br><span class="line"><span class="comment">        在spring中一般采用@RequestMapping注解来完成映射关系</span></span><br><span class="line"><span class="comment">        要想使@RequestMapping注解生效</span></span><br><span class="line"><span class="comment">        必须向上下文中注册DefaultAnnotationHandlerMapping</span></span><br><span class="line"><span class="comment">        和一个AnnotationMethodHandlerAdapter实例</span></span><br><span class="line"><span class="comment">        这两个实例分别在类级别和方法级别处理。</span></span><br><span class="line"><span class="comment">        而annotation-driven配置帮助我们自动完成上述两个实例的注入。</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 视图解析器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">id</span>=<span class="string">&quot;internalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 前缀 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 后缀 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用注解开发类</p><ol><li>controller:(component的衍生,用于注解注册bean)</li><li>RequsetMapping:用于请求的映射,可以嵌套</li><li>方法<ol><li>returnType-String(“返回的view的地址,其中前缀后缀都已经在配置文件中配置”)</li><li>传入参数model(“传入的参数,用于封装数据”)</li></ol></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/ho&quot;)</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">    @RequestMapping(&quot;/hello&quot;)</span><br><span class="line">    public String returnView(Model model)&#123;</span><br><span class="line">        //封装数据</span><br><span class="line">        model.addAttribute(&quot;msg&quot;,&quot;helloAnnotation&quot;);</span><br><span class="line"></span><br><span class="line">        return &quot;hello&quot;;//会被视图解析器处理</span><br><span class="line">    &#125;</span><br><span class="line">    @RequestMapping(&quot;/hello1&quot;)</span><br><span class="line">    public String returnView1(Model model)&#123;</span><br><span class="line">        //封装数据</span><br><span class="line">        model.addAttribute(&quot;msg&quot;,&quot;helloAnnotation1&quot;);</span><br><span class="line"></span><br><span class="line">        return &quot;hello&quot;;//会被视图解析器处理</span><br><span class="line">    &#125;</span><br><span class="line">    @RequestMapping(&quot;/hello2&quot;)</span><br><span class="line">    public String returnView2(Model model)&#123;</span><br><span class="line">        //封装数据</span><br><span class="line">        model.addAttribute(&quot;msg&quot;,&quot;helloAnnotation2&quot;);</span><br><span class="line"></span><br><span class="line">        return &quot;hello&quot;;//会被视图解析器处理</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-5-小知识点"><a href="#2-5-小知识点" class="headerlink" title="2.5 小知识点"></a>2.5 小知识点</h3><ol><li>在springMVC中的 / 和 /*<ul><li>/ 只会匹配所有的请求,不会匹配jsp页面</li><li>/* 匹配所有的请求,包括jsp页面</li></ul></li><li> 关于classpath和classpath*</li></ol><ul><li>classpath会匹配当前类路径下的文件</li><li>classpath*匹配所有路径文件</li></ul><ol start="3"><li>启动级别<ul><li>load-on-startup</li></ul></li><li>处理器<ol><li>BeanNameUrlHandlerMapping<ul><li>只会根据bean的名字去适配</li></ul></li></ol></li></ol><h3 id="2-6-restful风格"><a href="#2-6-restful风格" class="headerlink" title="2.6 restful风格"></a>2.6 restful风格</h3><ul><li><p>传统方式操作资源:通过不同的参数来实现不同的效果</p><ul><li><p><a href="http://127.0.0.1/item/queryItem.action?id=1">http://127.0.0.1/item/queryItem.action?id=1</a> 查询,GET</p></li><li><p><a href="http://127.0.0.1/item/saveItem.action">http://127.0.0.1/item/saveItem.action</a> 新增,POST</p></li><li><p><a href="http://127.0.0.1/item/updateItem.action">http://127.0.0.1/item/updateItem.action</a> 更新,POST</p></li><li><p><a href="http://127.0.0.1/item/deleteItem.action?id=1">http://127.0.0.1/item/deleteItem.action?id=1</a> 删除,GET或POST</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springMVC </tag>
            
            <tag> java </tag>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注解使用MVC</title>
      <link href="2021/05/26/springMVCAnnotation/"/>
      <url>2021/05/26/springMVCAnnotation/</url>
      
        <content type="html"><![CDATA[<h1 id="使用注解开发"><a href="#使用注解开发" class="headerlink" title="使用注解开发"></a>使用注解开发</h1><h2 id="1-依旧在web-xml中配置DispatcherServler"><a href="#1-依旧在web-xml中配置DispatcherServler" class="headerlink" title="1.依旧在web.xml中配置DispatcherServler"></a>1.依旧在web.xml中配置DispatcherServler</h2>   <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-完成springmvc-servlet的配置"><a href="#2-完成springmvc-servlet的配置" class="headerlink" title="2.完成springmvc-servlet的配置"></a>2.完成springmvc-servlet的配置</h2>   <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">       https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.twen.springMVC04.controller&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 让Spring MVC不处理静态资源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    支持mvc注解驱动</span></span><br><span class="line"><span class="comment">        在spring中一般采用@RequestMapping注解来完成映射关系</span></span><br><span class="line"><span class="comment">        要想使@RequestMapping注解生效</span></span><br><span class="line"><span class="comment">        必须向上下文中注册DefaultAnnotationHandlerMapping</span></span><br><span class="line"><span class="comment">        和一个AnnotationMethodHandlerAdapter实例</span></span><br><span class="line"><span class="comment">        这两个实例分别在类级别和方法级别处理。</span></span><br><span class="line"><span class="comment">        而annotation-driven配置帮助我们自动完成上述两个实例的注入。</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 视图解析器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">id</span>=<span class="string">&quot;internalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 前缀 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 后缀 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-使用注解开发的类"><a href="#3-使用注解开发的类" class="headerlink" title="3.使用注解开发的类"></a>3.使用注解开发的类</h2><ol><li>controller:(component的衍生,用于注解注册bean)<ol><li>Controller</li><li>Service</li><li>Repository</li><li>component</li></ol></li><li>RequsetMapping:用于请求的映射,可以嵌套</li><li>方法<ol><li>returnType-String(“返回的view的地址,其中前缀后缀都已经在配置文件中配置”)</li><li>传入参数model(“传入的参数,用于封装数据”)</li></ol></li></ol>   <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/ho&quot;)</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">    @RequestMapping(&quot;/hello&quot;)</span><br><span class="line">    public String returnView(Model model)&#123;</span><br><span class="line">        //封装数据</span><br><span class="line">        model.addAttribute(&quot;msg&quot;,&quot;helloAnnotation&quot;);</span><br><span class="line"></span><br><span class="line">        return &quot;hello&quot;;//会被视图解析器处理</span><br><span class="line">    &#125;</span><br><span class="line">    @RequestMapping(&quot;/hello1&quot;)</span><br><span class="line">    public String returnView1(Model model)&#123;</span><br><span class="line">        //封装数据</span><br><span class="line">        model.addAttribute(&quot;msg&quot;,&quot;helloAnnotation1&quot;);</span><br><span class="line"></span><br><span class="line">        return &quot;hello&quot;;//会被视图解析器处理</span><br><span class="line">    &#125;</span><br><span class="line">    @RequestMapping(&quot;/hello2&quot;)</span><br><span class="line">    public String returnView2(Model model)&#123;</span><br><span class="line">        //封装数据</span><br><span class="line">        model.addAttribute(&quot;msg&quot;,&quot;helloAnnotation2&quot;);</span><br><span class="line"></span><br><span class="line">        return &quot;hello&quot;;//会被视图解析器处理</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springMVC </tag>
            
            <tag> java </tag>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis基础</title>
      <link href="2021/05/21/mybatis/"/>
      <url>2021/05/21/mybatis/</url>
      
        <content type="html"><![CDATA[<p>#1、Mybais简介</p><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><ul><li>github地址：<a href="https://github.com/mybatis/mybatis-3">https://github.com/mybatis/mybatis-3</a></li><li>mybatis中文文档:<a href="https://mybatis.org/mybatis-3/zh/index.html">https://mybatis.org/mybatis-3/zh/index.html</a></li><li>xml配置<pre><code>      &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;      &lt;dependency&gt;          &lt;groupId&gt;org.mybatis&lt;/groupId&gt;          &lt;artifactId&gt;mybatis&lt;/artifactId&gt;          &lt;version&gt;3.5.2&lt;/version&gt;      &lt;/dependency&gt;</code></pre></li></ul><h2 id="1-持久化"><a href="#1-持久化" class="headerlink" title="1 持久化"></a>1 持久化</h2><ul><li><p>数据持久化</p><ul><li>持久化就是将程序的数据再持久状态和瞬时状态转化的过程</li><li>内存:<strong>断电即失</strong></li><li>数据库(jdbc),io文件持久化</li></ul></li><li><p><strong>为什么需要持久化?</strong></p><ul><li>有一些对象,不能让他丢掉</li><li>内存稀缺 <h2 id="1-持久层"><a href="#1-持久层" class="headerlink" title="1 持久层"></a>1 持久层</h2></li></ul></li><li><p>Dao层,Service层,Controller层</p><ul><li>完成持久化工作的代码块</li><li>层界限十分明显。<h2 id="1-为什么需要Mybatis"><a href="#1-为什么需要Mybatis" class="headerlink" title="1 为什么需要Mybatis"></a>1 为什么需要Mybatis</h2></li></ul></li><li><p>帮助程序员将数据存入到数据库中</p></li><li><p>方便</p></li><li><p>传统的JDBC代码太复杂了。简化,框架。</p></li><li><p>不用Mybatis也可以。更容易上手,<strong>技术没有高低之分</strong></p></li><li><p>接触sql与程序代码的耦合,sql和代码的分离</p></li><li><p>提供映射标签,支持对象与数据库的orm字段关系映射</p></li><li><p>提供对象关系映射标签,支持对象关系组件维护</p></li><li><p>提供xml标签,支持编写动态sql</p></li><li><p><strong>最重要的一点:使用的人多!</strong></p></li><li><p>Spring Spring MVN Spring Boot</p></li></ul><pre><code>    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;8.0.20&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;        &lt;version&gt;3.5.2&lt;/version&gt;    &lt;/dependency&gt;</code></pre><p>#2 熟悉mybatis</p><h2 id="2、第一个Mybatis程序"><a href="#2、第一个Mybatis程序" class="headerlink" title="2、第一个Mybatis程序"></a>2、第一个Mybatis程序</h2><ol><li><p>搭建数据库</p></li><li><p>新建项目   </p></li><li><p>删除src目录</p></li><li><p>导入mvn依赖</p><h2 id="2、创建一个模块"><a href="#2、创建一个模块" class="headerlink" title="2、创建一个模块"></a>2、创建一个模块</h2></li><li><p>编写Mybatis核心配置文件</p><ol><li>连接数据库</li></ol></li><li><p>获取sqlSessionFactory</p><ol><li><p>读取Mybatis核心配置文件</p></li><li><p>获取sqlSessionFactoryBuilder,通过sqlSessionFactoryBuilder.build(InputStream is)拿取sqlSessionFactory</p></li><li><p>总结:流读取resources中的Mybatis核心配置文件</p><pre><code> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration         PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;         &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;!--核心配置文件--&gt; &lt;configuration&gt;     &lt;!--配置多套环境--&gt;     &lt;environments default=&quot;development&quot;&gt;         &lt;environment id=&quot;development&quot;&gt;             &lt;transactionManager type=&quot;JDBC&quot;/&gt;             &lt;dataSource type=&quot;POOLED&quot;&gt;                 &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;                 &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;useSSL=true&amp;amp;serverTimezone = GMT&quot;/&gt;                 &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;                 &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;             &lt;/dataSource&gt;         &lt;/environment&gt;     &lt;/environments&gt;     &lt;!--&lt;mappers&gt;         &lt;mapper resource=&quot;com/twen/mybatis_01/dao/UserMapper.xml&quot;&gt;&lt;/mapper&gt;     &lt;/mappers&gt;--&gt; &lt;/configuration&gt;    </code></pre></li></ol></li><li><p>创建pojo实体类</p></li><li><p>创建Mapper,Mapper.xml</p><pre><code> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper         PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;         &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;com.twen.mybatis_01.dao.UserMapper&quot;&gt;     &lt;!--查询语句--&gt;     &lt;select id=&quot;getUserList&quot; resultType=&quot;com.twen.mybatis_01.pojo.User&quot;&gt;         SELECT * FROM mybatis.user     &lt;/select&gt; &lt;/mapper&gt;</code></pre></li><li><p>在Mybatis核心配置文件中绑定Mapper  </p></li></ol><ol start="6"><li>tips:每生成一个Mapper就得将此Mapper添加到核心配置文件的mappers中</li><li><mapper resource="com/twen/mybatis_01/dao/UserMapper.xml"></mapper></li></ol><h2 id="2-测试"><a href="#2-测试" class="headerlink" title="2 测试"></a>2 测试</h2><ul><li><p>遇到的错误1</p><ol><li><p>无法找到非java项目的配置文件</p><pre><code> ### Error building SqlSession. ### The error may exist in com.twen.mybatis_01.dao.UserMapper ### Cause: org.apache.ibatis.builder.BuilderException: Error parsing SQL Mapper Configuration. Cause: java.io.IOException: Could not find resource com.twen.mybatis_01.dao.UserMapper  </code></pre></li><li><p>maven中添加配置</p><pre><code> &lt;resources&gt;     &lt;resource&gt;         &lt;directory&gt;src/main/java&lt;/directory&gt;         &lt;includes&gt;             &lt;include&gt;**/*.xml&lt;/include&gt;             &lt;include&gt;**/*.properties&lt;/include&gt;         &lt;/includes&gt;         &lt;filtering&gt;true&lt;/filtering&gt;     &lt;/resource&gt;     &lt;resource&gt;         &lt;directory&gt;src/main/resources&lt;/directory&gt;         &lt;includes&gt;             &lt;include&gt;**/*.xml&lt;/include&gt;             &lt;include&gt;**/*.properties&lt;/include&gt;         &lt;/includes&gt;         &lt;filtering&gt;true&lt;/filtering&gt;     &lt;/resource&gt; &lt;/resources&gt; </code></pre></li></ol></li><li><p>错误2</p><ol><li>无法加载mysql驱动</li><li>添加mysql-connerctor配置文件   </li></ol></li><li><p>错误3</p><ol><li>查询结果为null</li><li>查询的表需要用数据库名.表名</li></ol></li><li><p>错误4</p><ol><li>配置文件生成成功,但是找不到配置文件</li><li>配置文件路径写错,不能写成※.※,而是要※/※</li></ol></li><li><p>错误5</p><ol><li>namespace为空</li><li><mapper namespace="全限定名">## 2总结</li></ol></li></ul><ol><li>配置mybatis核心配置文件,数据库</li><li>创建实体类</li><li>创建dao包,创建mapper</li><li>将创建好的mapper添加进核心配置文件       </li><li>实际上,就是用xml文件取代了实现类</li><li>xml文件中的命名空间namespace绑定Mapper,指定返回值类型,全限定名<br>#3 数据库操作<h2 id="3-CRUD操作"><a href="#3-CRUD操作" class="headerlink" title="3 CRUD操作"></a>3 CRUD操作</h2></li><li>namespace<ol><li>namespace中的包名要和Dao/Mapper中的包名一致</li></ol></li><li>select <ol><li>选择查询语句</li><li>id:对应 的namespace中的方法名</li><li>resultType:Sql语句执行的返回值</li><li>parameterType:参数类型</li></ol></li><li>insert</li><li>delete</li><li>update</li></ol><ol start="3"><li>tips:<ol><li>resultType和parameterType默认为int,如果为int可不写</li><li>SqlSession默认支持事务,增删改之后必须提交<h2 id="3-万能的Map"><a href="#3-万能的Map" class="headerlink" title="3 万能的Map"></a>3 万能的Map</h2></li></ol></li><li>假设,实体类中对象的参数过多,可以使用map存储数据</li><li>map中的sql键值可以更改,需要与map保持一致,map中的key可以随意定制。对象传递参数,直接在sql中取对象的属性</li><li>只有一个基本类型参数的情况下,可以直接在sql中取到,随意名字,但是#{}中必须有值,多个参数用map或者**(????)**<h2 id="3-模糊查询"><a href="#3-模糊查询" class="headerlink" title="3 模糊查询"></a>3 模糊查询</h2></li><li>传递参数的时候在两边拼接%%</li><li>第二种方式,在sql中拼接”%”,”%”,但是存在sql注入问题,尽量少使用String作为参数<pre><code> &lt;select id=&quot;fuzzyQuery&quot; resultType=&quot;com.twen.mybatis_02.pojo.User&quot; parameterType=&quot;string&quot;&gt;     SELECT * FROM user WHERE name LIKE &quot;%&quot;#&#123;name&#125;&quot;%&quot;; &lt;/select&gt;</code></pre></li></ol><h1 id="4、配置解析"><a href="#4、配置解析" class="headerlink" title="4、配置解析"></a>4、配置解析</h1><h2 id="4-核心配置文件"><a href="#4-核心配置文件" class="headerlink" title="4 核心配置文件"></a>4 核心配置文件</h2><ul><li><p>mybatis.xml</p></li><li><p>Mybatis的配置文件包含了会深深影响Mybatis欣慰的设置和属性信息</p><pre><code>  configuration（配置）      properties（属性）      settings（设置）      typeAliases（类型别名）      typeHandlers（类型处理器）      objectFactory（对象工厂）      plugins（插件）      environments（环境配置）      environment（环境变量）      transactionManager（事务管理器）      dataSource（数据源）      databaseIdProvider（数据库厂商标识）      mappers（映射器）</code></pre></li><li><p>环境配置(environments)</p><ul><li>MyBatis可以配置多套运行环境</li><li>不过要记住:尽管可以配hi多个环境,但每个SqlSessionFactory实例只能许选择一种环境</li><li>学会使用配置多套运行环境</li><li>Mybatis默认的事务管理器是JDBC,连接池:Pooled:支持池化(UnPooled,JNP)</li></ul></li><li><p>属性(properties)</p><ul><li><p>可以动态配置properties</p></li><li><p>可以直接引入外部文件,注意顺序<properteis resource=""/></p><pre><code>  &lt;properties resource=&quot;db.properties&quot;/&gt;  &lt;properties resource=&quot;db.properties&quot;&gt;      &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;    &lt;/properties&gt;</code></pre></li><li><p>可以在其中增加一些属性配置</p></li><li><p>如果在properties标签中添加了<property>属性,会先读取内部的property属性,在读取外部的配置文件,如果外部文件有同样的名字的属性,则会被覆盖</p></li></ul></li><li><p>类型别名(typeAliases)</p><ol><li>替换冗余类名<ul><li><p>可以将类型设置为一个短的名字</p></li><li><p>存在的意义仅在于用来减少类完全限定名的冗余</p><pre><code>  &lt;typeAliases&gt;      &lt;typeAlias type=&quot;com.twen.mybatis_02.pojo.User&quot; alias=&quot;User&quot;/&gt;  &lt;/typeAliases&gt;</code></pre></li><li><p>此句的的作用是将com.twen.mybatis_02.pojo.User 替换为User假名</p></li></ul></li><li>扫描包获取类(该类大小写可以随意,但是推荐小写,为了方便别人看,推荐小写)<pre><code> &lt;typeAliases&gt;     &lt;package name=&quot;com.twen.mybatis_02.pojo&quot;/&gt; &lt;/typeAliases&gt;</code></pre><ul><li>这里在xml文件中可以直接填写实体类名,推荐使用小写</li></ul></li><li>关于java内置的类型别名<ol><li>int 原始类型 _int</li><li>Integer 包装类型 int</li></ol></li></ol></li><li><p>设置settings</p></li></ul><table><thead><tr><th>设置名</th><th>描述</th><th>有效值</th><th>默认值</th></tr></thead><tbody><tr><td>cacheEnabled</td><td>全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。</td><td>true / false</td><td>true</td></tr><tr><td>lazyLoadingEnabled</td><td>延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置 fetchType 属性来覆盖该项的开关状态。</td><td>true / false</td><td>false</td></tr><tr><td>mapUnderscoreToCamelCase</td><td>是否开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn。</td><td>true / false</td><td>false</td></tr></tbody></table><ul><li><p>配置完整的属性</p><pre><code>  &lt;settings&gt;        &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;        &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;        &lt;setting name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot;/&gt;        &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt;        &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;false&quot;/&gt;        &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;PARTIAL&quot;/&gt;        &lt;setting name=&quot;autoMappingUnknownColumnBehavior&quot; value=&quot;WARNING&quot;/&gt;        &lt;setting name=&quot;defaultExecutorType&quot; value=&quot;SIMPLE&quot;/&gt;        &lt;setting name=&quot;defaultStatementTimeout&quot; value=&quot;25&quot;/&gt;        &lt;setting name=&quot;defaultFetchSize&quot; value=&quot;100&quot;/&gt;        &lt;setting name=&quot;safeRowBoundsEnabled&quot; value=&quot;false&quot;/&gt;        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;false&quot;/&gt;        &lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot;/&gt;        &lt;setting name=&quot;jdbcTypeForNull&quot; value=&quot;OTHER&quot;/&gt;        &lt;setting name=&quot;lazyLoadTriggerMethods&quot; value=&quot;equals,clone,hashCode,toString&quot;/&gt;  &lt;/settings&gt;        </code></pre></li><li><p>映射器:注册Mapper时使用</p><ol><li><p>resouce:项目下的mapper少,用resouce”注意使用/“</p></li><li><p>url:一般不使用</p></li><li><p>class:一般用resouce代替,类的全限定名</p></li><li><p>name:将包内的映射器结构实现全部注册为映射器,包的全限定名</p><ul><li><p>用name要保证Mapper.xml必须与mapper.java(interface)名字相同,不然会无法完成注册</p></li><li><p>class同理,class和package可以使用注解</p><pre><code>  &lt;!-- 使用相对于类路径的资源引用 --&gt;  &lt;mappers&gt;    &lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&gt;    &lt;mapper resource=&quot;org/mybatis/builder/BlogMapper.xml&quot;/&gt;    &lt;mapper resource=&quot;org/mybatis/builder/PostMapper.xml&quot;/&gt;  &lt;/mappers&gt;  &lt;!-- 使用完全限定资源定位符（URL） --&gt;  &lt;mappers&gt;    &lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&gt;    &lt;mapper url=&quot;file:///var/mappers/BlogMapper.xml&quot;/&gt;    &lt;mapper url=&quot;file:///var/mappers/PostMapper.xml&quot;/&gt;  &lt;/mappers&gt;  &lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;  &lt;mappers&gt;    &lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt;    &lt;mapper class=&quot;org.mybatis.builder.BlogMapper&quot;/&gt;    &lt;mapper class=&quot;org.mybatis.builder.PostMapper&quot;/&gt;  &lt;/mappers&gt;  &lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;  &lt;mappers&gt;    &lt;package name=&quot;org.mybatis.builder&quot;/&gt;  &lt;/mappers&gt;</code></pre></li></ul></li></ol></li></ul><h3 id="关于mybatis-config-xml的配置"><a href="#关于mybatis-config-xml的配置" class="headerlink" title="关于mybatis-config.xml的配置"></a>关于mybatis-config.xml的配置</h3><ul><li>设置Aliases是为了能在返回时好写,减少代码冗余</li><li>设置Mappers里的路径是为了注册Mapper</li><li>设置额外的配置文件properties是为了能够将程序解耦,以后修改配置文件就可以运行不同的数据库<h2 id="4-声明周期和作用域"><a href="#4-声明周期和作用域" class="headerlink" title="4 声明周期和作用域"></a>4 声明周期和作用域</h2><h4 id="不同作用域和生命周期类别是至关重要的，因为错误的使用会导致非常严重的并发问题"><a href="#不同作用域和生命周期类别是至关重要的，因为错误的使用会导致非常严重的并发问题" class="headerlink" title="不同作用域和生命周期类别是至关重要的，因为错误的使用会导致非常严重的并发问题"></a>不同作用域和生命周期类别是至关重要的，因为错误的使用会导致非常严重的并发问题</h4></li></ul><ol><li>SqlSessionFactoryBuilder<ul><li>一旦创建SqlSessionFactory此类就不用了</li><li>局部变量</li></ul></li><li>SqlSessionFactory<ul><li>说白了就是数据库连接池</li><li>一旦被创建就应该在引用的运行期间一致存在</li><li>最简单的就是使用单例模式或者静态单例模式</li></ul></li><li>SqlSession    <ul><li>连接到连接池的一个请求,每个业务逻辑开始创建,业务逻辑结束关闭</li><li>实例不是线程安全的,不能被共享</li><li>用完需要赶紧关闭,否则资源被占用<img src="E:\资源\SMM-狂神\MyBatis\mybatis基础\三对象关系.jpg" alt="三对象关系"><h1 id="5、解决属性名和字段名不一致的问题"><a href="#5、解决属性名和字段名不一致的问题" class="headerlink" title="5、解决属性名和字段名不一致的问题"></a>5、解决属性名和字段名不一致的问题</h1></li></ul></li></ol><ul><li><p>使用resultMap</p></li><li><p>resultMap是Mybatis中最强大的类</p><pre><code>  &lt;resultMap id=&quot;userMapper&quot; type=&quot;user&quot;&gt;      &lt;result column=&quot;id&quot; property=&quot;id&quot;/&gt;  &lt;/resultMap&gt;  &lt;select id=&quot;getUserList&quot; resultMap=&quot;userMapper&quot;&gt;      SELECT * FROM user  &lt;/select&gt;</code></pre></li></ul><h1 id="6、日志"><a href="#6、日志" class="headerlink" title="6、日志"></a>6、日志</h1><h2 id="6、日志工厂"><a href="#6、日志工厂" class="headerlink" title="6、日志工厂"></a>6、日志工厂</h2><ul><li>如果一个数据库操作出现了异常,我们需要排错。日志时最好的助手</li></ul><p><img src="E:\资源\SMM-狂神\MyBatis\mybatis基础\setting.jpg" alt="setting"></p><ul><li><p>logImpl</p></li><li><p>LOG4J      【掌握】</p></li><li><p>LOG4J2</p></li><li><p>JDK_LOGGING</p></li><li><p>STDOUT_LOGGING 【掌握】</p></li><li><p>在mybatis中配置日志</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="6、Log4j"><a href="#6、Log4j" class="headerlink" title="6、Log4j"></a>6、Log4j</h2></li><li><p>什么是LOG4J？</p><ul><li>Log4j是<a href="https://baike.baidu.com/item/Apache/8512995">Apache</a>的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是<a href="https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E5%8F%B0/2438626">控制台</a>、文件、<a href="https://baike.baidu.com/item/GUI">GUI</a>组件，甚至是套接口服务器、<a href="https://baike.baidu.com/item/NT/3443842">NT</a>的事件记录器、<a href="https://baike.baidu.com/item/UNIX">UNIX</a> <a href="https://baike.baidu.com/item/Syslog">Syslog</a><a href="https://baike.baidu.com/item/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/966835">守护进程</a>等；我们也可以控制每一条日志的输出格式；</li><li>通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。</li><li>最令人感兴趣的就是，这些可以通过一个<a href="https://baike.baidu.com/item/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/286550">配置文件</a>来灵活地进行配置，而不需要修改应用的代码</li></ul></li><li><p>LOG4J配置文件</p><pre><code>    properties    #将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码    log4j.rootLogger=DEBUG,console,file        #控制台输出的相关设置    log4j.appender.console = org.apache.log4j.ConsoleAppender    log4j.appender.console.Target = System.out    log4j.appender.console.Threshold=DEBUG    log4j.appender.console.layout = org.apache.log4j.PatternLayout    log4j.appender.console.layout.ConversionPattern=【%c】-%m%n        #文件输出的相关设置    log4j.appender.file = org.apache.log4j.RollingFileAppender    log4j.appender.file.File=./log/kuang.log    log4j.appender.file.MaxFileSize=10mb    log4j.appender.file.Threshold=DEBUG    log4j.appender.file.layout=org.apache.log4j.PatternLayout    log4j.appender.file.layout.ConversionPattern=【%p】【%d&#123;yy-MM-dd&#125;】【%c】%m%n        #日志输出级别    log4j.logger.org.mybatis=DEBUG    log4j.logger.java.sql=DEBUG    log4j.logger.java.sql.Statement=DEBUG    log4j.logger.java.sql.ResultSet=DEBUG    log4j.logger.java.sql.PreparedStatement=DEBUG</code></pre></li><li><p>配置log4j为日志的实现</p></li><li><p>xml</p><pre><code>       &lt;settings&gt;           &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;       &lt;/settings&gt;</code></pre></li></ul><ul><li>LOG4J的使用,直接运行测试类<h1 id="7、分页"><a href="#7、分页" class="headerlink" title="7、分页"></a>7、分页</h1></li></ul><ol><li><p>为什么要分页?</p><ul><li>减少数据处理量</li></ul></li><li><p>使用Limit分页</p><pre><code> SELECT * FROM user LIMIT startIndex,pageCount</code></pre></li><li><p>使用mybatis实现分页</p><ul><li>使用 map传参实现LIMIT分页</li><li>使用sqlsession自带类实现分页<h1 id="8、mybatis中注解"><a href="#8、mybatis中注解" class="headerlink" title="8、mybatis中注解"></a>8、mybatis中注解</h1></li></ul></li><li><p>注解实现sql</p><ul><li>sql</li><li>多参数可以用@param(“”)在””里天上虚拟id</li><li>优点<ul><li>简化代码</li><li>sql简单可以使用此方法</li></ul></li><li>缺点<ul><li>对于resultMap不支持,将pojo类锁死</li><li>复杂查询不好用</li></ul></li></ul></li><li><p>lombok注解实现javaBean</p><ul><li>下载插件</li><li>pom里配置依赖</li></ul></li><li><p>关于#{}与${}</p><ol><li>#{}防止sql注入</li><li>${}不能很好防止sql注入<h1 id="9、一对多-多对一"><a href="#9、一对多-多对一" class="headerlink" title="9、一对多,多对一"></a>9、一对多,多对一</h1></li></ol></li><li><p>实例    </p><ol><li>学生与老师的对应关系,多个学生对应一个老师,一个老师对应多个学生</li><li>在写pojo时多对一的多端需要持有一个一端对象,表明多对一关系(对应java中的引用引用同一个对象)</li></ol></li><li><p>多对一</p></li><li><p>多对一将唯一一个JavaType写在多端</p><ol><li>嵌套查询,将结果处理丢给xml</li></ol>   <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--结果映射&gt;</span></span><br><span class="line"><span class="comment">&lt;resultMap id=&quot;studentMap&quot; type=&quot;Student&quot;&gt;</span></span><br><span class="line"><span class="comment">    &lt;association property=&quot;teacher&quot; column=&quot;tid&quot; javaType=&quot;Teacher&quot; select=&quot;selectTeacher&quot;/&gt;</span></span><br><span class="line"><span class="comment">&lt;/resultMap&gt;</span></span><br><span class="line"><span class="comment">&lt;!--主方法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;studentMap&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM student;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--用于关联的副方法&gt;</span></span><br><span class="line"><span class="comment">&lt;select id=&quot;selectTeacher&quot; resultType=&quot;Teacher&quot;&gt;</span></span><br><span class="line"><span class="comment">    SELECT * FROM teacher WHERE id = #&#123;tid&#125;</span></span><br><span class="line"><span class="comment">&lt;/select&gt;</span></span><br></pre></td></tr></table></figure>    2. 联合查询,结果处理均衡</li></ol><pre><code><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--结果映射&gt;</span></span><br><span class="line"><span class="comment">&lt;resultMap id=&quot;studentMap&quot; type=&quot;Student&quot;&gt;</span></span><br><span class="line"><span class="comment">    &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt;</span></span><br><span class="line"><span class="comment">    &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt;</span></span><br><span class="line"><span class="comment">    &lt;association property=&quot;teacher&quot; javaType=&quot;Teacher&quot;&gt;</span></span><br><span class="line"><span class="comment">    &lt;result property=&quot;id&quot; column=&quot;tid&quot;/&gt;</span></span><br><span class="line"><span class="comment">    &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt;</span></span><br><span class="line"><span class="comment">    &lt;/association&gt;</span></span><br><span class="line"><span class="comment">&lt;/resultMap&gt;</span></span><br><span class="line"><span class="comment">&lt;!--主方法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;studentMap&quot;</span>&gt;</span></span><br><span class="line">    SELECT s.id sid,s.name sname,t.id tid,t.name tname</span><br><span class="line">    FROM student s</span><br><span class="line">    JOIN teacher t</span><br><span class="line">    ON s.tid = t.id</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure></code></pre><ol start="3"><li>一对多</li></ol><ol start="4"><li>理解:<ol><li>association实际上是将数据库中查到的数据封装进java类里.</li><li>collaction<h1 id="10、动态SQL"><a href="#10、动态SQL" class="headerlink" title="10、动态SQL"></a>10、动态SQL</h1><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2></li></ol></li></ol><h1 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h1><ol><li><p>什么是动态SQL?</p><ul><li>利用mavenresources和java平级可以在resources里建立dao的实现xml层,但是resources里面不能含有java源码</li></ul></li><li><p>环境搭建</p><pre><code> CREATE TABLE `blog`(     `id` VARCHAR(50) NOT NULL COMMENT &#39;博客id&#39;,     `title` VARCHAR(100) NOT NULL COMMENT &#39;博客标题&#39;,     `author` VARCHAR(30) NOT NULL COMMENT &#39;博客作者&#39;,     `create_time` DATETIME NOT NULL COMMENT &#39;创建时间&#39;,     `views` INT(30) NOT NULL COMMENT &#39;浏览量&#39; )ENGINE=INNODB DEFAULT CHARSET=utf8;</code></pre></li><li><p>动态sql:类jstl标签:<strong>本质就是SQL,只是可以在SQL层面执行一个逻辑代码</strong></p><ol><li>if<pre><code> &lt;select id=&quot;queryBlogIf&quot; parameterType=&quot;map&quot;&gt;     SELECT * FROM blog WHERE 1 = 1     &lt;if test=&quot;title != null&quot;&gt;         and title = #&#123;title&#125;     &lt;/if&gt;     &lt;if test=&quot;author != null&quot;&gt;         and author = #&#123;author&#125;     &lt;/if&gt; &lt;/select&gt;</code></pre></li><li>choose(switch),when,otherwise</li><li>Foreach</li><li>SQL片段:提高sql复用性<pre><code> &lt;sql id=&quot;if-title-author&quot;&gt; &lt;/sql&gt;  &lt;select ....     SELECT * FROM blog     &lt;where&gt;         **&lt;include refid=&quot;if-title-author&quot;&gt;&lt;/include&gt;**     &lt;/where&gt; /select&gt;</code></pre><ul><li>最好基于单表定义SQL片段</li></ul></li></ol><ul><li>where 标签,自动去除首部and,Or</li><li>set 标签,自动去除无关逗号</li><li>trim:定制化去掉</li></ul></li></ol><h1 id="11、缓存"><a href="#11、缓存" class="headerlink" title="11、缓存"></a>11、缓存</h1><h2 id="1、cache概念"><a href="#1、cache概念" class="headerlink" title="1、cache概念"></a>1、cache概念</h2><ul><li>应对高并发</li><li>缓存使用条件<ul><li>经常查询,不经常改变的数据<h2 id="2、-mybatis缓存分级"><a href="#2、-mybatis缓存分级" class="headerlink" title="2、 mybatis缓存分级"></a>2、 mybatis缓存分级</h2></li></ul></li><li>一级缓存<ul><li>自动开启</li><li>基于session</li></ul></li><li>二级缓存<ul><li>手动开启</li><li>基于namespace,一个mapper一个缓存</li><li>为了提高扩展性,mybatis设置了cache自定义,可以实现cache接口自定义二级缓存</li></ul></li><li>tips<ul><li>二级缓存只会在一级缓存结束后将缓存添加入二级缓存,一级缓存不死,二级缓存不会存在</li><li>关于xml中select,insert,update,delete语句的flushCache,useCache</li><li>当为select语句时：<ul><li>flushCache默认为false，表示任何时候语句被调用，都不会去清空本地缓存和二级缓存。</li><li>useCache默认为true，表示会将本条语句的结果进行二级缓存。</li></ul></li><li>当为insert、update、delete语句时：<ul><li>flushCache默认为true，表示任何时候语句被调用，都会导致本地缓存和二级缓存被清空。</li><li>useCache属性在该情况下没有。</li></ul></li><li>flushCache为true的时候，每次调用都清理缓存，这样等于你每次调用都要重新读数据库和写缓存，自然很慢；</li><li>flushCache为false的时候，每次调用不清缓存，除了第一次调用较慢，后面都会很快。</li><li>flushCache：如果设成true，当语句调用时一级二级缓存都会被清理掉。select语句默认是false</li><li>useCache：如果设成true，语句调用的结果会缓存在二级缓存里。select语句默认是true</li></ul></li></ul><pre><code>* 无论如何,一级缓存都会生效* 使用缓存,**需要将实体类序列化**,否则会报错</code></pre><h2 id="3、-缓存失效的情况"><a href="#3、-缓存失效的情况" class="headerlink" title="3、 缓存失效的情况:"></a>3、 缓存失效的情况:</h2><ol><li>查询不同的东西</li><li>增删改操作可能会改变原来的数据,必定会刷新缓存</li><li>不同mapper</li><li>手动刷新缓存<ol><li>sqlSession.clearCache() <h2 id="4、-查询顺序"><a href="#4、-查询顺序" class="headerlink" title="4、 查询顺序"></a>4、 查询顺序</h2></li></ol></li><li>查询到来时,先查询二级缓存</li><li>再查询一级缓存</li><li>最后查询数据库<h1 id="12、自定义缓存-ehcache"><a href="#12、自定义缓存-ehcache" class="headerlink" title="12、自定义缓存-ehcache"></a>12、自定义缓存-ehcache</h1></li><li>思想:实现了cache接口,可以自己定义cache接口使用复杂的策略</li><li>现在常用redis做缓存</li></ol><h1 id="附-mybaits执行流程"><a href="#附-mybaits执行流程" class="headerlink" title="附:mybaits执行流程"></a>附:mybaits执行流程</h1><p><img src="E:\资源\SMM-狂神\MyBatis\mybatis基础\mybatis执行流程.jpg" alt="mybatis执行流程"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> mybatis </tag>
            
            <tag> framwork </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ajax&amp;json</title>
      <link href="2021/05/15/ajax-json/"/>
      <url>2021/05/15/ajax-json/</url>
      
        <content type="html"><![CDATA[<h4 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h4><p>1.概念 ASynchronous JavaScript And XML 异步的JavaScript 和 XML<br>    1. 异步,同步:客户端和服务器通信的基础上<br>        1. 同步:客户端必须等待服务器的响应,在等待的期间客户端不能做其他操作<br>        2. 异步:客户端不需要等待服务器端的响应,在服务器处理请求的过程中,客户端可以进行其他操作<br>            * 客户端的各个元素之间异步,互不影响</p><pre><code>3. Ajax即Asynchronous Javascript And XML（异步JavaScript和XML）在 2005年被Jesse James Garrett提出的新术语，用来描述一种使用现有技术集合的‘新’方法，包括: HTML 或 XHTML, CSS, JavaScript, DOM, XML, XSLT, 以及最重要的XMLHttpRequest。 使用Ajax技术网页应用能够快速地将增量更新呈现在用户界面上，而不需要重载（刷新）整个页面，这使得程序能够更快地回应用户的操作。</code></pre><ol start="2"><li><p>实现方式</p><ol><li><p>原生的Js实现方式(了解)</p></li><li><p>JQuery实现方式</p><ol><li><p>$.ajax()</p><pre><code> $.ajax(&#123;   url:&quot;/Ajax/ajaxServlet&quot;,   type:&quot;post&quot;,   data:&#123;&quot;username&quot;:&quot;twen&quot;,&quot;age&quot;:&quot;23&quot;&#125;,   success:function (data)&#123;     alert(data);   &#125; &#125;);</code></pre><ul><li>success:function,error:function里的data为response里的响应内容</li></ul></li><li><p>$.get()</p><ul><li>用来发送get请求</li><li>语法:$.get(url,[data],[SuccessCallback],[type])</li><li>url:请求路径</li><li>请求参数</li><li>回调函数</li><li>响应数据类型</li><li>使用get不再需要写键名</li></ul></li><li><p>$.post()</p><ul><li>用来发送post请求</li><li>语法:$.post(url(必写),[data],[callback],[type]</li></ul></li></ol><ul><li>常用的键:<ul><li>url</li><li>type:”post”,”get”</li><li>data:发送的数据</li><li>success:function(data)</li><li>error:function(data)</li><li>dataType:获取的响应的格式(MIME类型)</li></ul></li></ul></li></ol></li></ol><h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><ol><li><p>概念:JavaScript Object Notation JavaScript对象表示法</p><pre><code> var p = (&quot;name&quot;:张三,&quot;age&quot;:23,&quot;gender&quot;:&quot;男);</code></pre><ul><li>JSON现多用于存储和交换文本信息的语法</li><li>进行数据的传输</li><li>JSON比XML更小,更快,更易解析</li></ul></li><li><p>语法:</p><ol><li><p>基本规则</p><ol><li>数据在名称键值对中:Json数据由键值对构成<ul><li>键用引号(单双都行)引起来,也可以不使用引号</li><li>值的取值类型:<ul><li>数字(正数或浮点型)</li><li>字符型(在双引号中)</li><li>逻辑值(true或false)</li><li>数值(在方括号中):{“person”:[{},{}]}</li><li>对象(在花括号中):{“address”:{“province”:”陕西”,….}}</li><li>null</li></ul></li></ul></li><li>数据由逗号分隔</li><li>花括号保存对象</li><li>方括号保存数组</li></ol></li><li><p><strong>获取数据</strong></p><ol><li><p>json对象.键名</p></li><li><p>json对象[“键名”]</p></li><li><p>数组对象[索引]</p></li><li><p><strong>对于Json对象和Json数组的遍历</strong></p><ol><li><p>对象<br> ** for中的key是字符串,所以不能用person.key获取数据</p><pre><code> for(key in person)&#123;      alert(person[key]);  &#125;</code></pre></li><li><p>键值对,数组对象的嵌套</p><pre><code> var persons =&#123; &quot;person&quot;:  [&#123;&quot;name&quot;: &quot;张三&quot;, age: 23, &quot;gender&quot;: true&#125;,       &#123;&quot;name&quot;: &quot;李四&quot;, age: 24, &quot;gender&quot;: false&#125;,       &#123;&quot;name&quot;: &quot;王五&quot;, age: 25, &quot;gender&quot;: true&#125;]   &#125;;      for (let i = 0; i &lt; persons.person.length; i++) &#123;   var person = persons.person[i];   for(key in person)&#123;       alert(person[key]);   &#125;   &#125;    </code></pre></li></ol></li></ol></li></ol></li><li><p>JSON数据和java对象的相互转换</p><ol><li><p>Json解析器</p><ul><li>常见的解析器:Jsonlib,Gson(Google提供),fastjson(阿里),jackson(Spring MVC框架内置)</li></ul></li><li><p>Json转为Java对象        </p><ol><li>redValue(json数据,Class)</li></ol></li><li><p>Java对象转换Json</p><ol><li><p>使用步骤</p><ol><li><p>导入jackson的相关jar包</p></li><li><p>创建Jackson核心对象ObjectMapper</p></li><li><p>调用ObjectMapper的相关方法</p><ol><li><p>转换方法</p><ul><li>writeValue(参数1,参数2)<ul><li>参数1<ul><li>file:将obj对象转换为JSON字符串,并保存到指定的文件中</li><li>Writer:将obj对象转换为Json字符串,并将json数据填充到字符输出流中</li><li>OutputStream:子节输出流</li></ul></li></ul></li><li>writeValueAsString(),传入对象将对象转换为Json字符串    </li></ul></li><li><p>注解:</p><ol><li>@JsonIgnore:排除属性</li><li>@JsonFormat:属性值的格式化(格式化与DateFormat要求一样)</li></ol></li><li><p>复杂的java对象转换</p><ol><li>list:数组</li><li>Map:和对象格式一致</li></ol></li></ol></li></ol></li></ol></li></ol></li></ol><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><ul><li>校验用户名是否存在</li><li>tips:$.get;$.post方法的返回值需要设置MIME类型(json),如果不设置,默认text纯文本类型。服务器也可以指定MIME类型application/jason/setContentType(;charset);</li></ul>]]></content>
      
      
      <categories>
          
          <category> front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ajax </tag>
            
            <tag> json </tag>
            
            <tag> front-end </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jquery</title>
      <link href="2021/05/15/jQuery/"/>
      <url>2021/05/15/jQuery/</url>
      
        <content type="html"><![CDATA[<h4 id="JQuery基础"><a href="#JQuery基础" class="headerlink" title="JQuery基础"></a>JQuery基础</h4><ul><li><p>概念: 一个Javscript框架,能够简化javascript代码</p></li><li><p>本质: js文件,封装了js的原生代码</p></li><li><p>版本</p><ol><li>1.x:<ul><li>兼容ie,使用最广泛,官方只做BUG维护,功能不再新增。一般项目用1.x版本就可以</li><li>最终版本:1.12.4(2016/5/20)</li></ul></li><li>2.x:<ul><li>使用最少</li></ul></li><li>3.x:<ul><li>最新版本:新浏览器支持</li></ul></li><li>jquery-xxx.js 与 jquery-xxx.min.js区别<ol><li>jquery-xxx.js:开发版本,良好的缩进与注释,给程序员看</li><li>jquery-xxx.min.js:生产版本,程序中使用,没有缩进,体积小,程序加载更快<h4 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h4></li></ol></li></ol></li><li><p>步骤</p></li><li><p>导入Jquery文件,导入min.js文件</p></li><li><p>使用</p><pre><code>  var div1 = $(&quot;#div1&quot;);  alert(div1.html());</code></pre></li><li><p>优势</p><ul><li>jquery对象在操作时更加方便’</li><li>jquery对象和js对象不通用</li></ul></li><li><p>Jquery与js对象转换</p></li><li><p>jq – &gt; js:jsq对象[索引] 或者 jq对象.get(索引)(jq对象本质上是Object的数组)</p></li><li><p>js – &gt; jq:$(js对象)</p><pre><code>       let $div2 = $(&quot;div&quot;);       alert($div2.length)       $div2.html(&quot;bbb&quot;)            $div2[0].innerHTML = &quot;ccc&quot;;       $div2.get(1).innerHTML = &quot;ddd&quot;;</code></pre></li><li><p>选择器:筛选具有相似特征的元素(标签）</p><ol><li><p>基本语法学习</p><ol><li>事件绑定</li><li>入口函数<ol><li>js中的window.onload方法会被下一个函数覆盖</li><li>Jquery中的$(function())可以重复</li></ol></li><li>样式控制<ul><li>$(function(){$(“#div1”.css(“backgroundColour”,”pink”))})</li></ul></li></ol></li><li><p>分类</p><ol><li><p>基本选择器</p><ol><li>标签选择器（元素选择器）<ul><li>语法： $(“html标签名”) 获得所有匹配标签名称的元素</li></ul></li><li>id选择器 <ul><li>语法： $(“#id的属性值”) 获得与指定id属性值匹配的元素</li></ul></li><li>类选择器<ul><li>语法： $(“.class的属性值”) 获得与指定的class属性值匹配的元素</li></ul></li><li>并集选择器：<ul><li>语法： $(“选择器1,选择器2….”) 获取多个选择器选中的所有元素</li></ul></li></ol></li><li><p>层级选择器</p><ol><li>后代选择器<ul><li>语法: $(“A B”) 选择A元素内部的所有B元素(包括所有后辈)</li></ul></li><li>自带选择器<ul><li>语法: $(“A &gt; B”) 选择A元素内部的自带B元素</li></ul></li></ol></li><li><p>属性选择器</p><ol><li><p>属性名称选择器 </p><ul><li>语法： $(“A[属性名]”) 包含指定属性的选择器</li></ul></li><li><p>属性选择器</p><ul><li>语法： $(“A[属性名=’值’]”) 包含指定属性等于指定值的选择器</li></ul></li><li><p>复合属性选择器</p><ul><li>语法： $(“A[属性名=’值’][]…”) 包含多个属性条件的选择器</li></ul></li><li><p>属性选择器里的正则表达式</p><ol><li><p>开头</p><ul><li>$(“A[属性^=’ee’]”);</li></ul></li><li><p>结尾</p><ul><li>$(“A[属性$=’ee’]”);</li></ul></li><li><p>包含</p><ul><li>$(“A[属性*=’ee’]”);</li></ul><ol start="4"><li>过滤选择器</li></ol></li><li><p>首元素选择器 </p><ul><li>语法： :first 获得选择的元素中的第一个元素</li></ul></li><li><p>尾元素选择器 </p><ul><li>语法： :last 获得选择的元素中的最后一个元素</li></ul></li><li><p>非元素选择器</p><ul><li>语法： :not(selector) 不包括指定内容的元素</li></ul></li><li><p>偶数选择器</p><ul><li>语法： :even 偶数，从 0 开始计数</li></ul></li><li><p>奇数选择器</p><ul><li>语法： :odd 奇数，从 0 开始计数</li></ul></li><li><p>等于索引选择器</p><ul><li>语法： :eq(index) 指定索引元素</li></ul></li><li><p>大于索引选择器 </p><ul><li>语法： :gt(index) 大于指定索引元素,不等于</li></ul></li><li><p>小于索引选择器 </p><ul><li>语法： :lt(index) 小于指定索引元素,不等于</li></ul></li><li><p>标题选择器</p><ul><li>语法： :header 获得标题（h1~h6）元素，固定写法</li></ul></li></ol></li><li><p>表单过滤选择器</p><ol><li>可用元素选择器 <ul><li>语法： :enabled 获得可用元素</li></ul></li><li>不可用元素选择器 <ul><li>语法： :disabled 获得不可用元素</li></ul></li><li>选中选择器 <ul><li>语法： :checked 获得单选/复选框选中的元素</li></ul></li><li>选中选择器 <ul><li>语法： :selected 获得下拉框选中的元素</li></ul></li></ol></li></ol></li></ol></li></ol></li></ul><h4 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h4><ol><li><p>内容操作</p><ol><li><p>html(): 获取/设置元素的标签体内容</p><pre><code> &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt;  --&gt; &lt;font&gt;内容&lt;/font&gt;</code></pre></li><li><p>text(): 获取/设置元素的题纯文本内容,设置text内容时会换掉其所在的标题标签</p><pre><code> 获取/设置元素的标签体纯文本内容   &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt; --&gt; 内容</code></pre></li><li><p>val(): 获取/设置元素的value属性值</p></li></ol></li><li><p>属性操作</p><ol><li><p>通用属性操作</p><ol><li>attr(): 获取/设置元素的属性</li><li>removeAttr(): 删除属性</li><li>prop(): 获取/设置元素的属性</li><li>removeProp(): 删除属性</li></ol><ul><li>attr和prop区别<ol><li>如果操作的是元素的固有属性,建议使用prop</li><li>如果操作的是自定义属性,建议使用attr</li></ol></li></ul></li><li><p>对class属性的操作</p><ol><li>addClass():添加class属性值</li><li>removerClass():删除class属性值</li><li>toggleClass():切换class属性值<ul><li>如果元素对象有class则删除,如果不存在则添加</li></ul></li><li>css():获取/设置css样式</li></ol></li></ol></li><li><p>CRUD操作</p><ol><li>添加<ol><li>父级元素的添加<ol><li>append():父元素将子元素追加到末尾<ul><li>对象1.append(对象2):将对象2添加到对象1元素内部,并且在末尾</li></ul></li><li>prepend():父元素将子元素追加到开头<ul><li>对象1.prepend(对象2):将对象2添加到对象1元素内部,并且在开头</li></ul></li><li>appentTO():括号里追加调用方法者在末尾<ul><li>对象1.appendTo(对象2):将对象1添加到对象2内部,并且在末尾</li></ul></li><li>prepentTo():括号里追加调用方法者在开头<ul><li>对象1.appendTo(对象2):将对象1添加到对象2内部,并且在开头</li></ul></li></ol></li><li>兄弟元素的添加<ol><li>after():将元素添加到元素后面<ul><li>对象1.after(对象2):将对象2添加到对象1后,为兄弟关系</li></ul></li><li>before():将元素添加到元素前边<ul><li>对象1.before(对象2):将对象2添加到对象1后,为兄弟关系</li></ul></li><li>insertAfter():插队</li><li>insertBefore():插队</li></ol></li></ol></li><li>移除<ol><li>remove():移除元素<ul><li>对象.remove():将此对象删除</li></ul></li><li>empty():清空元素的所有后代元素<ul><li>对象.empty():将此元素的所有子节点删除,但保留该节点和属性</li></ul></li></ol></li></ol></li></ol><h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><ul><li>this是dom对象不是jQuery对象,需要$(this)才能调用this的Jquery对象</li></ul><h4 id="Jquery高级"><a href="#Jquery高级" class="headerlink" title="Jquery高级"></a>Jquery高级</h4><ol><li><p>动画</p><ol><li><p>三种方式显示和隐藏元素</p><ol><li><p>默认显示和隐藏方式</p><ol><li>show([speed,[easing],[fn]])<ol><li>参数：<ol><li>speed：动画的速度。三个预定义的值(“slow”,”normal”, “fast”)或表示动画时长的毫秒数值(如：1000)</li><li>easing：用来指定切换效果，默认是”swing”，可用参数”linear”<ul><li>swing：动画执行时效果是 先慢，中间快，最后又慢</li><li>linear：动画执行时速度是匀速的</li></ul></li><li>fn：在动画完成时执行的函数，每个元素执行一次。</li></ol></li></ol></li><li>hide([speed,[easing],[fn]])</li><li>toggle([speed],[easing],[fn])</li></ol></li><li><p>滑动显示和隐藏方式</p><ol><li>slideDown([speed],[easing],[fn])</li><li>slideUp([speed,[easing],[fn]])</li><li>slideToggle([speed],[easing],[fn])</li></ol></li><li><p>淡入淡出显示和隐藏方式</p><ol><li>fadeIn([speed],[easing],[fn])</li><li>fadeOut([speed],[easing],[fn])</li><li>fadeToggle([speed,[easing],[fn]])</li></ol></li></ol></li></ol></li><li><p>遍历</p><ol><li>js的遍历方式</li></ol><ul><li>for(初始化值;循环结束条件;步长)</li></ul><ol start="2"><li><p>jq的遍历方式</p><ol><li>jq对象.each(callback)<ol><li>语法：<br> jquery对象.each(function(index,element){});<pre><code> * index:就是元素在集合中的索引 * element：就是集合中的每一个元素对象 * this：集合中的每一个元素对象 * function中的index,element固定位置,但是可以省略</code></pre></li><li>回调函数返回值：<ul><li>true:如果当前function返回为false，则结束循环(break)。</li><li>false:如果当前function返回为true，则结束本次循环，继续下次循环(continue)</li></ul></li></ol></li><li>$.each(object, [callback]):可以传递js数组对象,不仅jq对象</li><li>for..of: jquery 3.0 版本之后提供的方式<br> for(元素对象 of 容器对象)</li><li>tips:如果callback()函数里有返回false,则相当于break,如果是true,则相当于continue</li></ol></li><li><p>事件绑定</p><ol><li>jQuery标准的绑定方式<ul><li>jq对象.事件方法(回调函数);</li><li>tips:如果调用事件方法,不传递回调函数,则会出发浏览器默认行为。<ul><li>对象.submit,提交表单</li><li>对象.focus(如果没有回调函数,默认设置焦点)</li></ul></li></ul></li><li>on绑定事件/off解绑事件<ul><li>jq对象.on(“事件名称”,回调函数);</li><li>jq对象.off(“事件名称”);</li><li>tips:如果off不传入任何参数,则会默认解绑所有事件</li></ul></li><li>事件切换:toggle<ul><li>jq对象.toggle(fn1,fn2);<ul><li>点击会依次循环切换执行函数。</li><li>jQuery1.9取消此功能,导入jQuery-migrate.js可以执行</li></ul></li></ul></li></ol></li><li><p>插件:增强JQuery的功能</p><ol><li>实现方式:<ol><li>$.fn.extend(object)<ul><li>增强通过Jquery获取的对象的功能 $(“#id”)</li></ul></li><li>$.extend(object)<ul><li>增强Jquery对象自身的功能 $/jQuery</li><li>调用方式$.插件名</li></ul></li></ol></li></ol></li></ol></li></ol><h4 id="案例"><a href="#案例" class="headerlink" title="案例:"></a>案例:</h4><ul><li>需求:<ol><li>提供index.html页面,页面中有一个省份 下拉列表</li><li>当页面加载完成后 发送ajax请求,请求json省份信息</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> front-end </tag>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jdbc中的crud操作</title>
      <link href="2021/04/28/jdbc%E4%B8%AD%E7%9A%84Crud/"/>
      <url>2021/04/28/jdbc%E4%B8%AD%E7%9A%84Crud/</url>
      
        <content type="html"><![CDATA[<h3 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h3><ul><li>预编译的SQL语句</li></ul><h3 id="SQL中的CRUD"><a href="#SQL中的CRUD" class="headerlink" title="SQL中的CRUD"></a>SQL中的CRUD</h3><ul><li><p>总的流程</p><ol><li>获取数据库连接</li><li>预编译sql语句,返回PreparedStatement实例</li><li>填充占位符</li><li>执行</li><li>关闭资源</li></ol></li><li><p>小技巧</p><ol><li>占位符:?<ul><li>将自己想要改变的参数填上占位符</li><li>表不能用占位符</li></ul></li><li>将获得连接与关闭流写在一个工具类里面</li></ol></li><li><p>INSERT</p><pre><code>    //预编译sql语句,返回PreparedStatement实例  String sql = &quot;INSERT INTO customers(name,email,birth) VALUES (?,?,?)&quot;;//?:占位符  pr = connection.prepareStatement(sql);  //填充占位符,数据索引从1开始  pr.setString(1,&quot;哪吒&quot;);  pr.setString(2,&quot;nezha@gmail.com&quot;);  SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);  java.util.Date date = sdf.parse(&quot;1001-01-01&quot;);  pr.setDate(3,new Date(date.getTime()));  //执行操作  pr.execute();</code></pre></li><li><p>UPDATE</p><pre><code>  //1.获取数据库连接  Connection connection = JDBCUtils.getConnection();  //2.预编译sql语句,返回PreparedStatement的实例  String sql = &quot;UPDATE customers SET name = ? WHERE id = ?&quot;;  //预编译SQL语句  PreparedStatement ps = connection.prepareStatement(sql);  //3.填充占位符  ps.setObject(1,&quot;莫扎特&quot;);  ps.setObject(2,18);  //4.执行  ps.execute();  //5.资源的关闭  JDBCUtils.closeResource(connection,ps);</code></pre></li><li><p>通用的增删改操作</p><pre><code>  Connection connection = null;  PreparedStatement ps = null;  try &#123;      //1.获取连接      connection = JDBCUtils.getConnection();      //2.获取PreparedStatement类      ps = connection.prepareStatement(sql);      //3.填充占位符      for (int i = 0; i &lt; objects.length; i++) &#123;          ps.setObject(i + 1, objects[i]);      &#125;      //4.执行      ps.execute();      //5.关闭流  &#125; catch (Exception e)&#123;      JDBCUtils.closeResource(connection, ps);  &#125;</code></pre></li><li><p>SELECT</p><ul><li><p>针对单个表的查询的固定查询</p><pre><code>  Connection connection = null;  PreparedStatement ps = null;  ResultSet resultSet = null;  try &#123;      //1.获取数据库连接      connection = JDBCUtils.getConnection();      //2.预编译SQL      ps = connection.prepareStatement(sql);      //3.填充占位符      for (int i = 0; i &lt; objects.length; i++) &#123;          ps.setObject(i + 1, objects[i]);      &#125;      //4.获取结果Set      resultSet = ps.executeQuery();      //5.打印结果      while (resultSet.next()) &#123;          int id = resultSet.getInt(1);          String name = resultSet.getString(2);          String email = resultSet.getString(3);          java.sql.Date date = resultSet.getDate(4);          Customers customers = new Customers(id, name, email, date);          System.out.println(customers);      &#125;  &#125;catch (Exception e)&#123;      e.printStackTrace();  &#125;finally &#123;      //6.关闭流      JDBCUtils.closeResource(connection,ps,resultSet);  &#125;</code></pre></li><li><p>针对单个表的通用查询:</p><ul><li>需要获取ResultSetMetaDate()来获取列长度,列名</li><li>如果有order_id等字段与java属性不符,需要将查询出来的字段label改为java属性名<pre><code>  List&lt;Customers&gt; list = new ArrayList&lt;&gt;();  Connection connection = null;  PreparedStatement ps = null;  ResultSet rs = null;  try &#123;      //1.获取sql连接      connection = JDBCUtils.getConnection();      //2.执行sql预编译      ps = connection.prepareStatement(sql);      //3.编译sql      for (int i = 0; i &lt; objects.length; i++) &#123;          ps.setObject(i + 1, objects[i]);      &#125;      //4.1获得结果集合      rs = ps.executeQuery();      //4.2获得结果元集合      ResultSetMetaData rsmd = rs.getMetaData();      //4.3得到列的长度      int colCounts = rsmd.getColumnCount();      //4.4循环添加对象      while (rs.next()) &#123;          //创建Customer对象          Customers cus = new Customers();          for (int i = 0; i &lt; colCounts; i++) &#123;              //得到每一列的值              Object val = rs.getObject(i + 1);              //得到每一列的名字              String colName = rsmd.getColumnLabel(i + 1);              //根据列名和值通过反射设置              Field field = Customers.class.getDeclaredField(colName);              field.setAccessible(true);              field.set(cus, val);          &#125;          //将设置好的cus对象存入队列          list.add(cus);      &#125;  &#125;catch (Exception e)&#123;      e.printStackTrace();  &#125;finally &#123;      JDBCUtils.closeResource(connection,ps,rs);  &#125;  return list;</code></pre></li></ul></li><li><p>针对多个表的通用查询&lt;运用泛型&gt;</p><pre><code>  List&lt;T&gt; list = new ArrayList&lt;&gt;();  Connection connection = null;  PreparedStatement ps = null;  ResultSet rs = null;  try &#123;      //1.建立连接     connection = JDBCUtils.getConnection();      //2.获取PreparedStatement      ps = connection.prepareStatement(sql);      //3.填充占位符      for (int i = 0; i &lt; objects.length; i++) &#123;          ps.setObject(i+1,objects[i]);      &#125;      //4结果处理      //4.1获取结果集      rs = ps.executeQuery();      //4.2获取结果元组      ResultSetMetaData rsmd = rs.getMetaData();      //4.3获取列的长度      int colCounts = rsmd.getColumnCount();      //4.4循环进行操作      while(rs.next())&#123;          T t = clazz.getDeclaredConstructor().newInstance();          for (int i = 0; i &lt; colCounts; i++) &#123;              //获取每一列的val              Object val = rs.getObject(i+1);              //反射设置每一列的值              String colName = rsmd.getColumnLabel(i+1);              Field field = clazz.getDeclaredField(colName);              field.setAccessible(true);              field.set(t,val);          &#125;          list.add(t);      &#125;  &#125;catch (Exception e)&#123;      e.printStackTrace();  &#125;finally &#123;      JDBCUtils.closeResource(connection,ps,rs);  &#125;  return list;</code></pre><p>  }</p><h4 id="PreparedStatement好处"><a href="#PreparedStatement好处" class="headerlink" title="PreparedStatement好处"></a>PreparedStatement好处</h4></li></ul></li><li><p>解决Statement拼串问题</p></li><li><p>解决sql注入问题,预编译之后数据的关系不会改变</p></li><li><p>PreparedStatement可以操作Blob数据,而Statement做不到</p></li><li><p>PreparedStatement可以更高效实现批量操作</p><ul><li>预编译只需要对sql语句校验一次</li><li>Statement每一次sql语句都需要校验</li><li>提高效率方式1:可以使用batch减少与磁盘的io次数,但是Mysql默认不支持Batch操作,需要我们在url中添加参数rewriteBatchedStatements=true(8.0以后mysql默认支持batch)</li><li>提高效率方式2:在获取连接时设置不允许自动提交数据,在结束后再提交</li><li>关键语句:addBatch(),ExecuteBatch(),clearBatch,setAutoCommit(),commit()<pre><code>  public void testAbandont()&#123;      Connection connection = null;      PreparedStatement ps = null;      long start = System.currentTimeMillis();      try &#123;          connection = JDBCUtils.getConnection();          connection.setAutoCommit(false);          ps = connection.prepareStatement(&quot;INSERT INTO test1(name) VALUES(?)&quot;);          for (int i = 0; i &lt; 200000; i++) &#123;              ps.setObject(1,&quot;tom&quot;+i);              ps.addBatch();              if(i%500 == 0||i==200000)&#123;                  ps.executeBatch();                  ps.clearBatch();              &#125;          &#125;          connection.commit();          System.out.println(System.currentTimeMillis()-start);      &#125;catch (Exception e)&#123;          e.printStackTrace();      &#125;finally &#123;          JDBCUtils.closeResource(connection,ps);      &#125;</code></pre></li></ul></li></ul><h4 id="实现通用查询的方法"><a href="#实现通用查询的方法" class="headerlink" title="实现通用查询的方法"></a>实现通用查询的方法</h4><ul><li>反射<ul><li>设置属性</li></ul></li><li>泛型<ul><li>针对不同对象</li></ul></li></ul><h4 id="BLOB类"><a href="#BLOB类" class="headerlink" title="BLOB类"></a>BLOB类</h4><ul><li><p>blob的类型</p><ul><li>TINYBLOB 1B</li><li>BLOB 64KB</li><li>MEDIUMBLOB 16MB</li><li>LONGBLOB 4GB</li></ul></li><li><p>tips</p><ul><li>相对路径的根路径是proj项目文件不是src</li><li>如果引入Blob文件大于mysql配置文件的限定大小,会出现Date too long异常,设置max_allowd_packet=16M</li></ul></li><li><p>添加到数据库</p><pre><code>  InputStream is = new InputStream(url)  ps.setBlob(index,is)</code></pre></li><li><p>从数据库读取Blob类型并下载至本地</p><pre><code>  Blob b = resultSet.getBlob(lable)  //获取流  InputStream is = b.getBinaryStream();  //设置输出流  FileOutputStream fos = new FileOutputStream(url);  //读取输入流设置缓存  byte[] buffer = new byte[1024]  int len = 0  //利用缓存区读取          while((len = is.read(buffer))!=0)&#123;      fos.write(buffer,0,len);  &#125;</code></pre></li><li><p>Blob类型的插入</p><ul><li>Blob类型的插入需要用到setBlob方法(index,inputStream)</li><li>其中inputStream指向需要插入文件 <pre><code>  public void insertBlob()&#123;  Connection connection = null;  PreparedStatement ps = null;  InputStream is = null;  try &#123;      //建立连接      connection = JDBCUtils.getConnection();      //预编译sql      String sql = &quot;INSERT INTO customers VALUES(?,?,?,?,?)&quot;;      ps = connection.prepareStatement(sql);      //填充占位符      ps.setObject(1,&quot;24&quot;);      ps.setObject(2,&quot;刘亦菲&quot;);      ps.setObject(3,&quot;yifei@gmail.com&quot;);      ps.setObject(4,&quot;1990-02-06&quot;);      //获取读入流      is = new FileInputStream(&quot;src//liuyifei1.png&quot;);      ps.setBlob(5,is);      //执行      ps.execute();  &#125;catch (Exception e)&#123;      e.printStackTrace();  &#125;finally &#123;      JDBCUtils.closeResource(connection,ps);      try&#123;          if(is != null) is.close();      &#125;catch (Exception e)&#123;          e.printStackTrace();      &#125;  &#125;  </code></pre></li></ul></li></ul><ul><li><p>Blob类型的读取</p><ul><li><p>Blob类型的读取需要用java的java.sql.Blob类型接取</p></li><li><p>Blob类型有一个方法得到其二进制输入流Blob.inputBinaryStream</p><p>  Connection connection = null;<br>  PreparedStatement ps = null;<br>  InputStream is = null;<br>  OutputStream os = null;<br>  ResultSet rs = null;<br>  try {</p><pre><code>  //建立连接  connection = JDBCUtils.getConnection();  //查询  String sql = &quot;SELECT id,name,email,birth,photo FROM customers WHERE id = ?&quot;;  ps = connection.prepareStatement(sql);  ps.setObject(1,20);  rs = ps.executeQuery();  if(rs.next()) &#123;      Customers cus = new Customers();      cus.setId(rs.getInt(&quot;id&quot;));      cus.setBirth(rs.getDate(&quot;birth&quot;));      cus.setEmail(rs.getString(&quot;email&quot;));      cus.setName(rs.getString(&quot;name&quot;));      //获取blob      Blob blob = rs.getBlob(&quot;photo&quot;);      //获取输入流      is = blob.getBinaryStream();      //设置输出流      os = new FileOutputStream(&quot;output.png&quot;);      byte[] buffer = new byte[1024];      int len = 0;      while((len = is.read(buffer)) != -1)&#123;          os.write(buffer,0,len);      &#125;  &#125;</code></pre><p>  }catch (Exception e){</p><pre><code>  e.printStackTrace();</code></pre><p>  }finally {</p><pre><code>  JDBCUtils.closeResource(connection,ps,rs);  try&#123;      if(os != null) os.close();  &#125;catch (Exception e)&#123;      e.printStackTrace();  &#125;  try&#123;      if(is != null) is.close();  &#125;catch (Exception e)&#123;      e.printStackTrace();  &#125;</code></pre><p>  }</p></li></ul></li></ul><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><ol><li><p>插入操作</p><ul><li>mysqldate隐式转换”yyyy-MM-dd”;</li><li>ps.execute()<ul><li>查询操作,有返回结果,则此方法返回true</li><li>如果时曾删改没有返回结果,返回false</li></ul></li><li>ps.executeUpdate()<ul><li>返回值是影响的行数</li></ul></li></ul></li><li><ol><li>创立数据库表examStudent,表结构如下<ul><li>FlowID 流水号 int(10)</li><li>Type 四级/六级 int(5)</li><li>IDCard 身份证号码 varchar(18)</li><li>ExamCard 准考证号码 varchar(15)</li><li>StudentName 学生姓名 varchar(20)</li><li>Location 区域 varchar(20)</li><li>Grade 成绩 int(10)</li></ul></li><li>向表中添加数据</li></ol></li></ol><h4 id="PreparedStatement与Statement区别"><a href="#PreparedStatement与Statement区别" class="headerlink" title="PreparedStatement与Statement区别"></a>PreparedStatement与Statement区别</h4><ul><li>都是Sun公司提供的</li><li>Pre是Statement的子接口</li><li>PreparedStatement可以防止SQL注入</li><li>PreparedStatement可以最大程度提高性能</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jdbc_crud </tag>
            
            <tag> jdbc_preparedStatment </tag>
            
            <tag> java_reflect </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC获取数据库连接</title>
      <link href="2021/04/28/jdbc%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5/"/>
      <url>2021/04/28/jdbc%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="获取数据库连接"><a href="#获取数据库连接" class="headerlink" title="获取数据库连接"></a>获取数据库连接</h3><ol><li>Driver接口实现类:驱动<ul><li>mysql 8.0驱动 com.mysql.cj.jdbc.Driver</li><li>加载与注册JDBC驱动<ul><li>加载驱动:加载JDBC驱动需调用Class类的静态方法forName(),向其传递要加载的JDBC驱动的类名<ul><li>Class.forName(“com.mysql.cj.jdbc.Driver”) /* 反射 */</li></ul></li><li>注册驱动:DreiverManager类是驱动程序管理器类,负责管理驱动程序<ul><li>使用DriverManage.registerDriver(com.mysql.cj.jdbc.Driver)注册驱动</li><li>通常不显示调用DriverManager类的registerDriver方法来注册驱动程序类的实例?</li></ul></li></ul></li><li>数据库厂商根据jdk的Driver接口编写Driver的实现类</li></ul></li></ol><p>2 URL</p><ul><li><p>JDBC URL用于标识一个被注册的驱动程序,驱动程序管理器通过这个URL选择正确的驱动程序,从而建立到数据库的连接</p></li><li><p>JDBC URl的标准由三部分组成,各部分间用冒号分隔</p><ul><li>jdbc:子协议:子名称</li><li>协议:JDBC URL中的协议总是jdbc</li><li>子协议:子协议用于标识一个数据库驱动程序</li><li>子名称:一种标识数据库的方法。子名称额可以依不同的子协议而变化,用子名称的目的是为了定位数据库提供足够的信息。包括<strong>主机名</strong>(对应的服务端的ip地址),<strong>端口号</strong>,<strong>数据库名</strong><ul><li>举例</li><li>jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone = GMT</li><li>在 mysql 8.0应该这样写,加上时区</li></ul></li></ul></li><li><p>几种常用的数据库的jdbc url</p><ul><li>mysql连接URL编写的方法<ul><li>jdbc:mysql://主机名称:mysql服务端口号/数据库名称?参数=值&amp;参数=值</li><li>jdbc:mysql://localhost:3306/test</li><li>jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf8(如果jdbc程序与服务器段的字符集不一致,会导致乱码,那么可以通过参数指定服务器端的字符集)</li><li>jdbc:mysql://localhost:3306/test?user=root&amp;password=123456</li></ul></li><li>Oracle 9i的连接URL编写方式：<ul><li>jdbc:oracle:thin:@主机名称:oracle服务端口号:数据库名称</li><li>jdbc:oracle:thin:@localhost:1521:atguigu</li></ul></li><li>SQLServer的连接URL编写方式：<ul><li>jdbc:sqlserver://主机名称:sqlserver服务端口号:DatabaseName=数据库名称</li><li>jdbc:sqlserver://localhost:1433:DatabaseName=atguigu</li></ul></li></ul></li></ul><ol start="3"><li><p>用户名和密码</p><ul><li>user,password可以用”属性名=属性值”方式告诉数据库</li><li>可以调用DriverManager类的getConnection()方法建立到数据库的连接 <h3 id="获取数据库连接的方法"><a href="#获取数据库连接的方法" class="headerlink" title="获取数据库连接的方法"></a>获取数据库连接的方法</h3></li></ul></li><li><p>连接的方式1(出现了第三方API)</p><pre><code> //方式一    Driver driver = new com.mysql.cj.jdbc.Driver();    String url = &quot;jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone = GMT&quot;;    //将用户名和秘密码封装在Properties中    Properties info = new Properties();    info.setProperty(&quot;user&quot;, &quot;root&quot;);    info.setProperty(&quot;password&quot;, &quot;123456&quot;);    Connection connection = driver.connect(url,info);    System.out.println(connection);</code></pre></li><li><p>连接的方式2(利用反射实现Dynamic动态性,使程序具有更好的可移植性)</p><pre><code>     //方式二     //1.根据反射获取Driver的mysql接口子类实现类     Class clazz = Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);     Driver driver = (Driver) clazz.getDeclaredConstructor().newInstance();     //2.提供要连接的数据库     String url =&quot;jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone = GMT&quot;;     //3.提供连接需要的用户名和密码     Properties info = new Properties();     info.setProperty(&quot;user&quot;, &quot;root&quot;);     info.setProperty(&quot;password&quot;, &quot;123456&quot;);     //4.获取连接     Connection connection = driver.connect(url,info);     System.out.println(connection);</code></pre></li><li><p>连接的方式3(利用DriverManager实现的管理Driver)</p><pre><code> //方式三 利用DriverManager类而不用Driver获取连接,需要注册驱动 //1.根据反射获取Driver的mysql接口子类实现类 Class clazz = Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); Driver driver = (Driver) clazz.getDeclaredConstructor().newInstance(); //2.提供另外三个连接的基本信息 String url = &quot;jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone = GMT&quot;; String user = &quot;root&quot;; String password = &quot;123456&quot;; //注册驱动 DriverManager.registerDriver(driver); //获取连接 Connection connection = DriverManager.getConnection(url,user,password); System.out.println(connection);</code></pre></li><li><p>连接方式4(优化获取Driver实现类的对象)</p><pre><code> //方式四 优化方式三 优化获取Driver实现类的对象 // ※可以省略创建Driver对象,注册driver的操作mysql的Driver实现类中在类加载时注册了driver实现类 //1.加载mysql的Driver Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); //Driver driver = (Driver) clazz.getDeclaredConstructor().newInstance(); //2.提供另外三个连接的基本信息 String url = &quot;jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone = GMT&quot;; String user = &quot;root&quot;; String password = &quot;123456&quot;; //获取连接 Connection connection = DriverManager.getConnection(url,user,password); System.out.println(connection); </code></pre></li><li><p>连接方式5(最终版,将数据库的驱动与程序解耦写入配置文件)</p><pre><code> //方式五 将数据与程序结构,写入配置文件 //得到properties文件 InputStream is = ConnectionTest.class.getClassLoader().getResourceAsStream(&quot;mysql.properties&quot;); Properties initial = new Properties(); initial.load(is); String driver = initial.getProperty(&quot;driver&quot;); String url = initial.getProperty(&quot;url&quot;); String user = initial.getProperty(&quot;user&quot;); String password = initial.getProperty(&quot;password&quot;); //加载驱动 Class.forName(driver); //获得连接 Connection connection = DriverManager.getConnection(url,user,password); System.out.println(connection);</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jdbc_connection </tag>
            
            <tag> java_sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL中的变量</title>
      <link href="2021/04/24/MYSQL%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F/"/>
      <url>2021/04/24/MYSQL%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul><li>分类<ul><li>系统变量<ul><li>全局变量</li><li>会话变量</li></ul></li><li>自定义变量<ul><li>用户变量</li><li>局部变量</li></ul></li></ul></li></ul><h4 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h4><ul><li><p>说明:变量由系统提供,不是用户定义,属于服务器层面</p></li><li><p>语法:</p><ol><li><p>查看所有的系统变量</p><pre><code> SHOW (GLOBAL 全局,SESSION 会话)VARIABLES;</code></pre></li><li><p>查看满足条件的部分系统变量</p><pre><code> SHOW GLOBAL|SESSION VARIABLES LIKE &#39;%char%&#39;;</code></pre></li><li><p>查看指定的某个系统变量的值</p><pre><code> SELECT @@global|session.系统变量名;</code></pre></li><li><p>为某个系统变量赋值<br> 方式1:</p><pre><code>     SET GLOBAL|SESSION 系统变量名 = 值;</code></pre><p> 方式2:</p><pre><code>     SET @@GLOBAL|SESSION.系统变量名 = 值;</code></pre></li></ol></li><li><p>注意</p><ul><li>如果时全局级别,则需要加global</li><li>如果时会话级别,默认或session<h4 id="系统变量-1"><a href="#系统变量-1" class="headerlink" title="系统变量"></a>系统变量</h4></li></ul></li></ul><ol><li>全局变量<pre><code> * 跨连接有效 * 作用域:服务器每次启动将为所有的全局变量赋初始值,针对于所有的会话(连接),但是不能跨重启 * 如果需求每次重启服务器都为自己预想的变量,则需要修改配置文件</code></pre><ol><li>查看所有的全局变量<pre><code> SHOW GLOBAL VARIABLES;</code></pre></li><li>查看部分的全局变量<pre><code> SHOW GLOBAL VARIABLES LIKE &#39;%char%&#39;;</code></pre></li><li>查看指定的全局变量的值<pre><code> SELECT @@global.autocommit; SELECT @@TRANSACTION_ISOLATION;</code></pre></li><li>为某个指定的全局变量赋值<pre><code> SET global autocommit = 0; SET @@global.autocommit = 0;</code></pre></li></ol></li><li>会话变量<pre><code> * 仅仅针对于当前会话(连接)有效 </code></pre><ol><li>查看所有的会话变量<pre><code> SHOW [SESSION] VARIABLES</code></pre></li><li>查看部分的会话变量<pre><code> SHOW [SESSION] VARIABLES LIKE&#39; &#39;</code></pre></li><li>查看指定的全局变量的值<pre><code> SELECT @@SESSION.autocommit; SELECT @@TRANSACTOIN_ISOLATION; </code></pre></li><li>为某个会话变量赋值<ol><li>方式一<pre><code> SET @@TRANSACIONT = &#39;read-uncommitted&#39;;</code></pre></li><li>方式二<pre><code> SET SESSION TRANSACTION_ISOLATION = &#39;read_committed&#39;; </code></pre><h4 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h4></li></ol></li></ol><ul><li>变量由用户自定义的,不是由系统定义的</li><li>使用步骤:<pre><code>      声明      赋值      使用(查看、比较、运算等)</code></pre></li></ul></li><li>用户变量<ul><li>作用域<ul><li>针对于当前会话(连接)连接有效,等同关于会话变量的作用域</li><li>应用在任何地方,也就是begin end里面或begin end外面    </li></ul></li><li>使用:用户变量使用时需要加@<pre><code>  1. 声明并初始化:赋值的操作符: = 或 :=      SET @用户变量名 = 值;      SET @用户变量名:= 值;      SELECT @用户变量名:=值;  2. 赋值(更新用户变量的值)      方式一:通过SET 或 SELECT          SET @用户变量名=值          SET @用户变量名:=值          SELECT @用户变量名:=值      方式二:通过SELECT INTO          SELECT 字段 INTO @变量名          FROM 表;    </code></pre></li></ul></li><li>局部变量<ul><li>作用域<ul><li>仅仅在定义它的begin end 中有效</li><li>begin end中的第一句话</li></ul></li><li>使用</li></ul></li></ol><pre><code>        1. 声明            DECLARE 变量名 类型;            DECLARE 变量名 类型 DEFAULT 值;        2. 赋值            方式一:通过SET 或 SELECT                SET 局部变量名=值                SET 局部变量名:=值                SELECT @局部变量名:=值            方式二:通过SELECT INTO                SELECT 字段 INTO 局部变量名                FROM 表;            3. 使用            SELECT 局部变量名</code></pre><h4 id="用户变量与局部变量对比"><a href="#用户变量与局部变量对比" class="headerlink" title="用户变量与局部变量对比"></a>用户变量与局部变量对比</h4><ul><li>作用域<ul><li>用户变量针对当前会话</li><li>局部变量针对BEGIN END中</li></ul></li><li>定义和使用位置<ul><li>用户变量会话中的任何地方</li><li>局部变量只能在BEGIN END中,且为第一句话</li></ul></li><li>语法<ul><li>用户变量必须加@符号,不用限定类型</li><li>局部变量一般不用加@符号,需要限定类型</li><li>用户变量与局部变量的声明不同,赋值相似,使用相似</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> MYSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> VARIABLES </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL中的视图</title>
      <link href="2021/04/24/MYSQl%E4%B8%AD%E7%9A%84%E8%A7%86%E5%9B%BE/"/>
      <url>2021/04/24/MYSQl%E4%B8%AD%E7%9A%84%E8%A7%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h4 id="视图-VIEW"><a href="#视图-VIEW" class="headerlink" title="视图:VIEW"></a>视图:VIEW</h4><ul><li>含义: 虚拟表,和普通表一样使用<ul><li>保存的查询语句,可以直接调用,需要查询的时候直接调用视图<ul><li>类似于java的方法</li></ul></li><li>mysql 5.1版本出现的新特性,是通过表动态生成的数据</li></ul></li><li>特点<ul><li>临时性:视图只有在被调用时虚拟表才会产生,没有保存数据,只保存了SQL逻辑,不保存查询结果</li></ul></li><li>应用场景<ul><li>多个地方用到同样的查询结果</li><li>该查询结果使用的SQL语句较复杂</li></ul></li><li>好处<ul><li>重用了sql语句</li><li>简化复杂的SQL操作,不必知道它的查询细节</li><li>保护数据、提高安全性,只提供了一个接口,没提供原表<h4 id="视图的创建与使用"><a href="#视图的创建与使用" class="headerlink" title="视图的创建与使用"></a>视图的创建与使用</h4></li></ul></li><li>案例<ol><li>查询姓名中中包含a字符的员工名、部门名和工种信息<ul><li>创建<pre><code>  CREATE VIEW       myv1  AS      SELECT       last_name,department_id,j.job_title  FROM      employees e  JOIN          jobs j  ON      e.job_id = j.job_id;</code></pre></li><li>使用<pre><code>  SELECT      *      FROM      myv1  WHERE      last_name LIKE &quot;%a%&quot;;</code></pre></li></ul></li><li>查询各部门的平均工资级别<ul><li>创建视图查看每个部门的平均工资<pre><code>  CREATE VIEW      deparment_avg_salary  AS  SELECT          department_id,AVG(salary) ag  FROM      employees  GROUP BY      department_id</code></pre></li><li>使用<pre><code>  SELECT      department_id,grade_level  FROM      department_avg_salary d  JOIN      job_grades j  ON      d.ag BETWEEN j.lowest_sal AND j.highest_sal;    </code></pre></li></ul></li><li>查询平均工资最低的部门信息<ul><li>创建视图:同2</li><li>使用视图:同4</li></ul></li><li>查询平均工资最低的部门名和工资<ul><li>创建视图:同2、3</li><li>使用视图<pre><code>  SELECT      *  FROM      department_avg_salary  WHERE      ag = (  SELECT      MIN(ag)  FROM      department_avg_salary);</code></pre><h4 id="视图的修改"><a href="#视图的修改" class="headerlink" title="视图的修改"></a>视图的修改</h4></li></ul></li></ol></li><li>方式一<ul><li>语法<pre><code>  CREATE OR REPLACE VIEW       视图名  AS          查询语句；</code></pre></li><li>作用<ul><li>创建或者改变视图<ul><li>视图不存在创建</li><li>视图存在改变</li></ul></li></ul></li></ul></li><li>方式二<ul><li>语法<pre><code>  ALTER VIEW      视图名  AS      查询语句</code></pre></li><li>作用<ul><li>改变视图,不能创建视图</li></ul></li></ul></li></ul><h4 id="视图的删除"><a href="#视图的删除" class="headerlink" title="视图的删除"></a>视图的删除</h4><ul><li><p>语法</p><pre><code>  DROP VIEW      视图名,视图名;</code></pre><h4 id="视图结构的查看"><a href="#视图结构的查看" class="headerlink" title="视图结构的查看"></a>视图结构的查看</h4></li><li><p>语法</p><ol><li>展示视图结构,和展示表结构类似<pre><code> DESC     视图名;</code></pre></li><li>展示详细信息(创建语句,视图名,字符集等等)<pre><code> SHOW CREATE VIEW     视图名;</code></pre><h4 id="视图的更新"><a href="#视图的更新" class="headerlink" title="视图的更新"></a>视图的更新</h4></li></ol></li><li><p>视图不允许更新的特点</p><ol><li><p>具有以下关键字的SQL语句:分组函数、distinct、group by、having、union、union all</p><ul><li>不是原表原数据的数组不允许更改</li></ul></li><li><p>常量视图</p></li><li><p>SELECT 中包含子查询</p></li><li><p>SELECT 中包含join,92,99语法都不行</p></li><li><p>FROM一个不能更新的视图</p></li><li><p>WHERE子句的子查询引用了FROM子句中的表    </p></li></ol></li><li><p>总结</p><ul><li>视图更新时必须只能参照原表的数据,不能更新由原表数据进行任何操作形成的视图。</li><li>视图的更新会对原表的数据进行更新,这就是为什么视图更新只能参照原表的数据。</li><li>对于创建视图时引用了不能跟新的视图时也不能更新,级联更新</li><li>视图的更新只能对单个表,单行数据更新</li><li>视图中不允许更新可能是不允许CRUD中的某一项也可能都不支持</li></ul></li></ul><h4 id="视图和表的对比"><a href="#视图和表的对比" class="headerlink" title="视图和表的对比"></a>视图和表的对比</h4><pre><code>* 创建语法    * CREATE VIEW    * CREATE TABLE* 是否占用物理空间    * 视图不占用数据存储空间,占用逻辑语句存储的空间,只保留了SQL逻辑    * 表占用数据空间* 使用    * VIEW可以使用增删改查,但一般不用,且使用起来有限制    * TABLE使用见DML</code></pre>]]></content>
      
      
      <categories>
          
          <category> MYSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VIEW </tag>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaScript DOM树基础</title>
      <link href="2021/04/22/js-dom/"/>
      <url>2021/04/22/js-dom/</url>
      
        <content type="html"><![CDATA[<h4 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h4><ul><li><p>概念: Document Object Model 文档对象模型</p><ul><li>将标记语言文档的各个组成部分,封装为对象.可以使用这些对象,都标记语言文档进行CRUD的动态操作</li></ul></li><li><p>W3C DOM标准被分为3个不同的部分:</p><ul><li><p>核心 DOM - 针对任何结构化文档的标准模型</p><ul><li><p>Document : 文档对象</p></li><li><p>Element: 元素对象</p></li><li><p>Attribute: 属性对象</p></li><li><p>Text: 文本对象</p></li><li><p>Comment: 注释对象</p></li><li><p>Node: 节点对象,其它5个的父对象</p></li></ul></li><li><p>XML DOM - 针对XML文档的标准模型</p></li><li><p>HTML DOM - 针对HTML文档的标准类型                 </p></li></ul></li><li><p>核心DOM模型:                                                 </p><ul><li>Document:文档对象<ol><li>创建(获取):在html dom模型中可以使用windox对象获取<ol><li>window.document</li><li>document</li></ol></li><li>方法<ol><li>获取Element对象:<ol><li>getElementById():根据id属性值获取元素对象。id属性值一般唯一</li><li>getElementsByTagName():根据元素名称获得元素对象们,返回值时元素数组</li><li>getElementsByClassName():根据Class属性值获取元素对象们。返回值是一个数组</li><li>getElementsByName():根据name属性值获取元素对象们</li></ol></li><li>创建其他DOM对象:<ol><li>createAttribute(name)</li><li>createComment()</li><li>createElement()</li><li>createaTextNode()</li></ol></li></ol></li><li>属性</li></ol></li><li>Element:元素对象<ul><li>创建/获取：通过document来获取和创建</li><li>方法:<ol><li>removeAttribute():删除属性</li><li>setAttribute():设置属性</li></ol></li></ul></li><li>Node:节点对象,其他5个的父对象<ul><li>特点:所有dom对象都可以被认为是一个节点</li><li>方法:<ul><li>CRUD dom树:<ul><li>appendChild():向节点的子节点列表的结尾添加新的子节点</li><li>removeChild():删除(并返回)当前节点的指定子节点</li><li>replaceChild():用新节点替换一个子节点</li></ul></li></ul></li><li>属性<ul><li>parentNode:返回节点的父节点</li></ul></li></ul></li></ul></li><li><p>HTML DOM                                    </p><ol><li><p>标签体的设置和获取:innerHTML</p><pre><code>  &lt;div id=&quot;div1&quot;&gt;     div   &lt;/div&gt; &lt;script&gt;   var div = document.getElementById(&quot;div1&quot;);   var innerHTML = div.innerHTML;   div.innerHTML += &quot;&lt;input type=&#39;text&#39;&#39;&gt;&quot;;   //div标签追加一个文本输入框   &lt;/script&gt;</code></pre></li><li><p>使用html元素对象的属性</p></li><li><p>控制元素样式        </p><pre><code> &lt;div id=&quot;div1&quot;&gt;   div &lt;/div&gt;   &lt;script&gt;   var div1 = document.getElementById(&quot;div1&quot;);   div1.onclick = function ()&#123;     //修改样式方式1,使用元素的style属性设置     div1.style.border = &quot;1px solid red&quot;     div1.style.fontSize = &quot;20px&quot;;     //修改样式方式2     提前定义好class选择器的样式,通过元素的className属性来设置class属性     &#125;     div2.onclick = function ()&#123;     div2.className = &quot;d2&quot;;     &#125;                  &lt;/script&gt;    </code></pre></li></ol></li></ul><h4 id="事件监听机制"><a href="#事件监听机制" class="headerlink" title="事件监听机制:"></a>事件监听机制:</h4><ul><li>概念:某些组件被执行了某些操作后,出发某些代码的执行        <ul><li>事件:某些操作,如:单击,双击,键盘按下,鼠标移动                                    <ul><li>事件源：组件 如:按钮 文本输入框…</li><li>监听器: 代码</li><li>注册监听: 将事件,事件源,监听器结合在一起。当事件源上发生了某个事件，则出发执行某个监听器代码</li></ul></li><li>常见的事件<ol><li>点击事件:<ol><li>onclick 单机事件</li><li>ondbclick 双击事件</li></ol></li><li>焦点事件<ol><li>onblur:失去焦点<ul><li>一般用于表单校验(失去焦点时判断内容是否符合规则)    </li></ul></li><li>onfocus:元素获得焦点</li></ol></li><li>加载事件<ol><li>onload：一张页面或一幅图像完成加载<ul><li>window.onload<pre><code>     window.onload = function ()&#123;        document.getElementById(&quot;username&quot;).onblur = function ()&#123;         alert(&quot;失去焦点了&quot;);        &#125;      &#125;</code></pre></li></ul></li></ol></li><li>鼠标事件<ol><li>onmousedown 鼠标被按下<ul><li>定义方法时，定义一个形参，接受event对象</li><li>event对象俺的button属性可以后去鼠标按钮被点击了</li><li>左中右 012</li></ul></li><li>onmouseup 鼠标被松开</li><li>onmousemove 鼠标被移动</li><li>onmouseover 鼠标移到某元素</li><li>onmouseout 鼠标从某元素移开</li></ol></li><li>键盘事件    <ol><li>onkeydown 某个键被按下</li><li>onkeyup 某个键被松开</li><li>onkeypress 某个键被按下并松开</li></ol></li><li>选择和改变<ol><li>onchange 域的内容被改变</li><li>onselect 文本被选中</li></ol></li><li>表单事件<ol><li>onsubmit 确认按钮被点击<ul><li>可以阻止表单提交<ul><li>方法 return false:表单被阻止提交</li></ul></li></ul></li><li>onreset 重置按钮被重置 </li></ol></li></ol></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> javaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaScript </tag>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL中的事务</title>
      <link href="2021/04/21/MySQL%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1/"/>
      <url>2021/04/21/MySQL%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h4 id="TCL-Transaction-Control-Language-事务控制语言"><a href="#TCL-Transaction-Control-Language-事务控制语言" class="headerlink" title="TCL:Transaction Control Language 事务控制语言"></a>TCL:Transaction Control Language 事务控制语言</h4><ul><li><p>简介</p><ul><li>事务:一个或一组sql语句组成一个执行单元,这个执行单元要么全部执行,要么全部不执行.如果单元中某条sql语句一旦执行失败或产生错误,整个单元将会回滚。所有受到影响的数据将返回到事务开始以前的状态</li><li>引入案例: 转账<ul><li>不能一个转出后发生Exception另一个不转入</li></ul></li></ul></li><li><p>事务的acid属性</p><ol><li>原子性(Atomicity):事务不可分割,食物中的操作要么都发生,要么都不发生</li><li>一致性(Consistency):事务必须从数据库从一个状态切换到另一个一致性的状态</li><li>隔离性(Isolation):一个事务的执行不能被其他事务干扰.即一个事务内部的操作及使用的数据对并发的其他事务时隔离的,并发执行的各个事务之间不能互相干扰.</li><li>持久性(Durability):一个事务一旦被提交,它对数据库中数据的改变就是永久性的,接下来的其他操作和数据库故障不应该对其有任何影响</li></ol></li><li><p>使用</p><ul><li>事务的创建<ul><li>隐式事务:事务没有明显的开启和结束的标记<ul><li>INSERT</li><li>UPDATE</li><li>DELETE</li></ul></li><li>显示事务:事务具有明显的开启和结束的标记<ul><li>前体:必须先设置自动提交功能为禁用<pre><code>  步骤1:              SET           autocommit = 0      start          transaction; 可选,只要autocommit = 0 默认开启事务  步骤2:编写事务中的sql语句(SELECT,INSERT,UPDATE,DELETE)  步骤3:结束事务      commit;提交事务      rollback;回滚事务  SAVEPOINT 节点名;设置保存点</code></pre></li></ul></li></ul></li></ul></li><li><p>并发    </p><ul><li><p>并发问题</p><ul><li>脏读:对于两个事务T1,T2,T1读取了已经被T2更新但还没有被提交的字段之后,若T2回滚,T1 读取的内容就是临时且无效的。</li><li>不可重复读;对于两个事务T1,T2,T1读取了一个字段,然后T2更新了该字段之后,T1再次读取同一个字段,值就不同了</li><li>幻读:对于两个事务T1,T2,T1从一个表中读取了一个字段,然后T2再该表中插入了一些新的行之后,如果T1再次读取同一个表,就会多出几行</li></ul></li><li><p>事务隔离级别</p><ul><li>READ UNCOMMITTED:脏读、不可重复读、和幻读都不能阻止</li><li>READ COMMITED:能阻止脏读、不能阻止不可重复读、不能阻止幻读</li><li>REPEATABLE READ:能阻止脏读、不可重复读、不能阻止幻读</li><li>SERIALIZABLE:脏读、不可重复读、幻读都能阻止,效率较慢</li></ul></li><li><p>MYSQL 支持4种事务隔离级别.MYSQL默认的事务隔离级别 REPEATABLE READ;</p><h4 id="DELETE和TRUNCATE在事务使用时的区别"><a href="#DELETE和TRUNCATE在事务使用时的区别" class="headerlink" title="DELETE和TRUNCATE在事务使用时的区别"></a>DELETE和TRUNCATE在事务使用时的区别</h4></li></ul></li><li><p>DELETE ROLLBACK可以回滚</p></li><li><p>TRUNCATE ROLLBACK不可以回滚</p><pre><code>  SET autocommit = 0;  START TRANSACTION;    DELETE FROM account;  ROLLBACK;</code></pre></li></ul><h4 id="savepoint"><a href="#savepoint" class="headerlink" title="savepoint"></a>savepoint</h4><ul><li>回滚点</li></ul><ul><li>回滚点的使用<pre><code>  SET autocommit = 0;  START TANSACTION;  DELETE FROM       account WHERE id = 25;  SAVEPOINT a;//设置保存点  DELETE FROM account WHERE id = 28;  ROLLBACK TO a;  //回滚到25被删除28被保留的时候</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> transaction </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql Basic</title>
      <link href="2021/04/21/MySQL%E5%9F%BA%E7%A1%80/"/>
      <url>2021/04/21/MySQL%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h3 id="MySQL服务端的登陆和退出"><a href="#MySQL服务端的登陆和退出" class="headerlink" title="MySQL服务端的登陆和退出"></a>MySQL服务端的登陆和退出</h3><pre><code>方式一:通过mysql自带的客户端只限于root用户方式二:通过windows自带的客户端登陆:(如果有-h -P)就是另一台主机    mysql -h主机名 -P端口号 -u用户名 -p密码退出:exit</code></pre><h3 id="MYSQL的常见命令"><a href="#MYSQL的常见命令" class="headerlink" title="MYSQL的常见命令"></a>MYSQL的常见命令</h3><pre><code>1.查看当前所有的数据库SHOW databases;2.打开指定的库USE 库名3.查看当前库的所有表SHOW tables4.查看其它库的所有表SHOW tables FROM 库名5.创建表CREATE table 表名(    列名 列类型,    列名 列类型,    。。。    列名 列类型);6.查看表结构desc 表名;7.查看服务器的版本方法一:登陆到mysql服务端SELECT version();方法二:cmdmysql --version OR mysql -V</code></pre><h3 id="MYSQL语言规范"><a href="#MYSQL语言规范" class="headerlink" title="MYSQL语言规范"></a>MYSQL语言规范</h3><pre><code>1.不区分大小写,但建议关键字大写,表明、列名小写2.每条命令用分号结尾3.每条命令根据需要,可以进行缩进或换行4.注释    单行注释:# 注释文字    单行注释:- - 注释文字(空格)    多行注释:/* 注释文字 */</code></pre>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/04/21/hello-world/"/>
      <url>2021/04/21/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> inital </category>
          
      </categories>
      
      
        <tags>
            
            <tag> init </tag>
            
            <tag> hello </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
